# 动态规划

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212221152809.png)

记忆化搜索和动态规划的本质都是一样的

动态规划表示的是一堆集合的某种属性，而DFS是一个一个的枚举



记忆化搜素代码复制度比较低，自顶向下的方式容易调试，特别是一些区间，二维面积的问题，

一些线性的问题比较适合枚举的方式

## 经典问题



### 斐波那契数

#### 题目描述

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

#### 题解

**记忆化搜索**

```java
// memory都初始化为-1
    private int[] memory;

    // 记忆化搜索-自顶向下的解决问题 调用2n - 1次
    public int fib(int n) {
        if (n < 2) {
            return n;
        }
        memory = new int[n + 1];
        for (int i = 0; i < n + 1; i++) {
            memory[i] = -1;
        }
        memory[0] = 0;
        memory[1] = 1;
        return dfs(n);
    }

    private int dfs(int n) {
        if (memory[n] == -1) {
            memory[n] = dfs(n - 1) + dfs(n - 2);
        }
        return memory[n];
    }
```



**动态规划**

```java
// 动态规划 自底向上
public int fib(int n) {
    if (n < 2) {
        return n;
    }
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```





### 爬楼梯

#### 题目描述

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)



#### 题解

这个问题和斐波那契本质就是一样的



**记忆化搜索**

自顶向下思考：

爬上n阶楼梯，只有两类，第一类是从n-1阶再爬一阶，第二类是从n-2阶再爬两阶

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212222102767.png)

最底层就是爬0阶的可能性有1种，爬1阶的可能性有1中，爬2阶 = 爬0阶 + 爬1阶

```java
private int[] memory;
// 记忆化搜索
public int climbStairs(int n) {
    memory = new int[n + 1];
    for (int i = 0; i < n + 1;i++) {
        memory[i] = -1;
    }
    memory[0] = 1;
    memory[1] = 1;
    return dfs(n);
}
private int dfs(int n) {
    if (memory[n] == -1) {
        memory[n] = dfs(n - 1) + dfs(n - 2);
    }
    return memory[n];
}
```



**动态规划**

```java
// 动态规划
public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```



**进阶**

每次可以爬 $k$ 阶，那就再枚举一遍 $ k $ 就好了

### 三角形最小路径和

#### 题目描述

[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

```java
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

**数据范围：**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-104 <= triangle[i][j] <= 104`

**进阶：**

- 你可以只使用 `O(n)` 的额外空间（`n` 为三角形的总行数）来解决这个问题吗？

#### 题解



**回溯**

按题目给的数据范围，回溯肯定是会超时的，但是顺便复习下回溯的思路解法

```java
private List<Integer> res = new ArrayList<>();
private int path;

public int minimumTotal(List<List<Integer>> triangle) {
    if (triangle == null || triangle.size() == 0) {
        return 0;
    }
    backTracking(triangle, 0, 0);
    // 选取最小路径和
    Collections.sort(res);
    return res.get(0);
}

// index 记录上次横向遍历的位置 下次只能从[index,index + 1]做选择 row记录当前层
private void backTracking(List<List<Integer>> triangle, int index, int row) {
    if (row == triangle.size()) {
        res.add(path);
        return;
    }
    for (int i = index; i < index + 2; i++) {
        // 检查每一层的i是否越界
        if (i != triangle.get(row).size()) {
            path += triangle.get(row).get(i);
            backTracking(triangle, i, row + 1);
            path -= triangle.get(row).get(i);
        }
    }
}
```

结果就是内存超了

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220213001048117.png)





**递归**

先自顶向下思考问题，再用记忆化搜索优化，再尝试自底向上使用动态规划

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/007S8ZIlgy1ggqa6f1notj317c0o8jti.jpg)

整颗树的最小路径，就是以3为根节点的树和以4为根节点的树其中路径和的最小值加上2这个顶点

```java
// 自顶向下递归
public int minimumTotal3(List<List<Integer>> triangle) {
    return dfs(triangle, 0, 0);
}

private int dfs(List<List<Integer>> triangle, int index, int j) {
    if (index == triangle.size() - 1) {
        return triangle.get(index).get(j);
    }
    int path1 = dfs(triangle, index + 1, j);
    int path2 = dfs(triangle, index + 1, j + 1);
    return Math.min(path1, path2) + triangle.get(index).get(j);
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220213164852659.png)

毫无疑问也是超时，接下来用记忆化搜索优化



**记忆化搜索**

```java
// 记忆化搜索
private int[][] memory;

public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    memory = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 数据范围 -10^4 <= triangle[i][j] <= 10^4
            memory[i][j] = Integer.MIN_VALUE;
        }
    }
    return dfs(triangle, 0, 0);
}

private int dfs(List<List<Integer>> triangle, int index, int j) {
    if (index == triangle.size() - 1) {
        return triangle.get(index).get(j);
    }
    if (memory[index][j] == Integer.MIN_VALUE) {
        int path1 = dfs(triangle, index + 1, j);
        int path2 = dfs(triangle, index + 1, j + 1);
        memory[index][j] = Math.min(path1, path2) + triangle.get(index).get(j);
    }
    return memory[index][j];
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220213170040073.png)



**动态规划**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/007S8ZIlgy1ggqa51dsbdj319w0q840q.jpg)

```java
// 4 动态规划
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    // 使用一维数组是只要求顶点一个位置的最小路径，只要底部拿到数据累加覆盖就行
    // 设置成n + 1是为了防止当j为一层的最后一个时，j + 1越界
    int[] dp = new int[n + 1];
    for (int i = n - 1; i >= 0; i--) {
        // j是小于等于i 因为i是对应的索引
        for (int j = 0; j <= i; j++) {
            // 有个隐含的点是 数组new出来后初始化都为0 所以最底层的局部最小就是0+0+本身
            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
        }
        System.out.println("第" + i + "层 " + Arrays.toString(dp));
    }
    return dp[0];
}
```

打印的结果

```java
第3层 [4, 1, 8, 3, 0]
第2层 [7, 6, 10, 3, 0]
第1层 [9, 10, 10, 3, 0]
第0层 [11, 10, 10, 3, 0]
```





### 最小路径和

#### 题目描述

[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/minpath.jpg)

**数据范围：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

#### 题解



**回溯**

练练回溯的思路，但是题目给的数据范围使用回溯肯定是超时或超内存

回溯法的优势是可以求出所有的路径

```java
private int[][] directs = new int[][]{{0, 1}, {1, 0}};
private int m;
private int n;
private int path = 0;
private List<Integer> paths = new ArrayList<>();
public int minPathSum(int[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    // 先把左顶点加进去
    path += grid[0][0];
    backTracking(grid, 0, 0);
    // 将所求的所有路径和排序
    Collections.sort(paths);
    return paths.get(0);
}

private void backTracking(int[][] grid, int x, int y) {
    // 终止条件 到达右下顶点 因为是path已经先加的值的再dfs 所以位于[m - 1][n - 1]位置时已经添加了该位置
    if (x == m - 1 && y == n - 1) {
        paths.add(path);
        return;
    }
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY)) {
            path += grid[newX][newY];
            backTracking(grid, newX, newY);
            path -= grid[newX][newY];
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**动态规划**

题目中给出了 `grid[i][j]` 非负整数，可以保证走得越长，sum 的值越大；**只能向右走或者向下走**，即为单调性，保证了在非负整数矩阵的情况下，**sum 的最小值存在**。



因为题目说明移动**只能从下或往右走**，所以对于每个位置来说，只能从上或左边到达

- 对于i = 0的位置（上边界），每个位置只能从左边到达

- 对于j = 0的位置（左边界），每个位置只能从上边到达
- 其他位置（里面的位置），每个位置可以从上或左边到达，只要选最短路径和最短的前一个位置加上本身

我们在每次移动时，都**记录下起点(0,0)到该位置的最短路径**

只需要用一个一维长度为n的滚动数组即可

```java
// 动态规划
public int minPathSum1(int[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    int m = grid.length;
    int n = grid[0].length;
    // 空间优化，只用一维 只记录一层，下一层的直接覆盖上一层就行
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 && j == 0) {
                // 先加入起点
                dp[0] = grid[0][0];
            } else if (i == 0) {
                // 上边界,只能从左边来
                dp[j] = dp[j - 1] + grid[0][j];
            } else if (j == 0) {
                // 左边界,只能从上边来 j是相等的 dp[j]是上一层的记录，现在要刷新
                dp[j] = dp[j] + grid[i][0];
            } else {
                // 其他位置，可以从从上或左边到，选取最小的
                dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
            }
        }
    }
    return dp[n - 1];
}
```

也可以不用dp数组，直接在原数组上操作



### 整数拆分

#### 题目描述

[LeetCode343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)



#### 题解

**最优子结构**

通过其子问题的最优解，可以获得原问题的最优解

所以对于递归问题应该同时满足**重叠子问题**和**最优子结构**两种性质的情况下，才可以用**记忆化搜索**和**动态规划**来解决



**回溯**

画出递归树

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220214230447448.png)

```java
// 回溯
public int integerBreak(int n) {
    return backTracking(n);
}

// 将n分割 至少分割两部分
private int backTracking(int n) {
    if (n == 1) {
        return 1;
    }
    // 用res来记录分割n产生的乘积的最大值 不断更新
    // 因为最小分割成两个且n为大于等于2的正整数 所以res初始值只要小于等于1都可以
    int res = 0;
    for (int i = 1; i < n; i++) {
        // 注意这里是取3个值比较，一个是之前的res，另一个是子问题产生的乘积的最大值，最容易漏的一个就是当前的分割方案的值i * (n - i)，
        // 因为有可能当前方案就是最优解
        res = max3(res, i * (n - i), i * backTracking(n - i));
    }
    return res;
}

private int max3(int num1, int num2, int num3) {
    return Math.max(Math.max(num1, num2), num3);
}
```



**记忆化搜索**

```java
// 记忆化搜索
private int[] memory;

public int integerBreak(int n) {
    // 加一个偏移量 方便理解  memory[1]表示的就是分割1的最优解
    memory = new int[n + 1];
    for (int i = 0; i < n + 1; i++) {
        memory[i] = -1;
    }
    memory[0] = 0;
    memory[1] = 1;

    return backTracking(n);
}

private int backTracking(int n) {
    if (n == 1) {
        return 1;
    }
    int res = 0;
    if (memory[n] == -1) {
        for (int i = 1; i < n; i++) {
            res = max3(res, i * (n - i), i * backTracking(n - i));
        }
        memory[n] = res;
    }
    return memory[n];
}
```



**动态规划**

可以发现递归树里存在相同的子问题

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220214230550280.png)

```java
// 动态规划
public int integerBreak(int n) {
    // 加一个偏移量 方便理解  dp[1]表示的就是分割1的最优解
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        // 求解dp[i]
        int res = 0;
        for (int j = 1; j < i; j++) {
            res = max3(res, j * (i - j), j * dp[i - j]);
        }
        dp[i] = res;
    }
    return dp[n];
}

private int max3(int num1, int num2, int num3) {
    return Math.max(Math.max(num1, num2), num3);
}
```



### 完全平方数

#### 题目描述

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)



#### 题解

贪心算法为什么不行？

假设贪心策略：**先将比所求数小的最大平方数加入结果中**

反例

12 = 9 + 1 + 1 + 1

12 = 4 + 4 + 4



递归结构



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220217002218747.png)





![image-20220216234807478](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220216234807478.png)

**动态规划**

```java
/**
 * 拉格朗日四平方和定理
 * 拉格朗日四平方和定理说明任何一个数，都可以由小于等于4个的完全平方数相加得到。
 * 所以dp值可以初始化为4
 *
 * @param n
 * @return
 */
// 完全背包
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    for (int i = 1; i < n + 1; i++) {
        dp[i] = Integer.MAX_VALUE;
    }

    for (int i = 1; i <= n; i++) {
        int res = Integer.MAX_VALUE;
        for (int j = 1; j * j <= i; j++) {
            // 这里的1 + dp[i - j * j]用自顶向下更容易理解一些 因为可以拆出一个j*j的平方数所以得加1
            // 拆出一个平方数后 剩余的数是i - j * j，必然小于等于当前的i 这个之前已经求过了
            res = Math.min(res, 1 + dp[i - j * j]);
        }
        dp[i] = res;
    }
    return dp[n];
}
```



**BFS**

这题可以转化成多叉树的广度优先遍历，依然是这个递归图

问题转化成，求按照完全平方数和凑成 target 的最短路径，也就是第一个结点值为0的那条路径的深度 - 1



![image-20220216234807478](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220216234807478.png)

```java
// BFS
public int numSquares1(int n) {
    // visited数组用来剪枝 避免重复访问相同值的结点
    boolean[] visited = new boolean[n + 1];
    Queue<Integer> queue = new ArrayDeque<>();
    queue.offer(n);
    visited[n] = true;
    int depth = 0;
    while (!queue.isEmpty()) {
        int levelCount = queue.size();
        depth++;
        // 多叉数的BFS
        for (int i = 0; i < levelCount; i++) {
            int cur = queue.poll();
            // 访问当前节点的子节点，类比于二叉树的左右子节点 这里是多叉树
            for (int j = 1; j * j <= cur; j++) {
                int next = cur - j * j;
                if (next == 0) {
                    return depth;
                }
                // next的值未被访问才考虑这条路径，
                // 因为如果这个值之前已经被访问过，说明之前有更短的路径达到这个值，那么当前这个比它长的路径就没有必要尝试下去了
                if (!visited[next]) {
                    queue.offer(next);
                    visited[next] = true;
                }
            }
        }
    }
    // 这个问题必有解因为n可以被n个1相加 正常情况是不会走到这里的 必然能在BFS中找到解
    throw new IllegalArgumentException();
}
```



### 解码方法

#### 题目描述

[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)



#### 题解

这题与爬楼梯很类似



对于字符串 s 的某个位置 i 而言，我们只关心**位置 i 自己能否形成合法独立编码**和**位置 i 能够与上一位置（i-1）能否形成合法的编码**，而不关心 i-1 之前的位置。

因为合法编码为0~26，最多只有两位

对于字符串 s 的任意位置 i 而言，其存在三种情况：

- 只能由位置 i 的单独作为一个独立合法编码，设为one，转移的前提是one的数值范围为 [1,9][1,9]，转移逻辑为 `f[i] = f[i - 1]`。
- 只能由位置 i 的与前一位置（i-1）共同作为一个合法编码，设为two，转移的前提是two的数值范围为 [10,26][10,26]，转移逻辑为 `f[i] = f[i - 2]`(i位置为0的情况，比如10只能由两个位置作为一个合法编码)。
- 位置 i 既能作为独立合法编码也能与上一位置形成合法编码，转移逻辑为` f[i] = f[i - 1] + f[i - 2]`。
  因此，我们有如下转移方程：

$$
\begin{cases} f[i] = f[i - 1], 1 \leqslant a \leq 9 \\ f[i] = f[i - 2], 10 \leqslant b \leqslant 26 \\ f[i] = f[i - 1] + f[i - 2], 1 \leqslant a \leq 9, 10 \leqslant b \leqslant 26 \\ \end{cases}
$$

我们用dp[i]来表示前i个字符可以解码回去的字符串个数，对于字符串的最后一个字符要么对应一个数字要么对应两个数字，所以是加法

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int n = s.length();
    // 这里加了个空格 配合循环从1开始可以简化越界[i - 2]的处理
    char[] str = (" " + s).toCharArray();
    int[] dp = new int[n + 1];
    Arrays.fill(dp,0);
    // 对于dp[0]设置成1 与爬楼梯一样 递推的边界
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        int one = str[i] - '0';
        int two = (str[i - 1] - '0')* 10 + one;
        if (one >= 1 && one <= 9) {
            dp[i] = dp[i] + dp[i - 1];
        }
        if (two >= 10 && two <= 26) {
            dp[i] = dp[i] + dp[i - 2];
        }
    }
    return dp[n];
}
```







### 不同路径

#### 题目描述

[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)



#### 题解

**回溯**

现在回溯倒是写得很顺畅，动态规划还是不熟

```java
// 超时
private int[][] directs = new int[][]{{1, 0}, {0, 1}};
private int m;
private int n;
private int path = 0;

public int uniquePaths(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    this.m = m;
    this.n = n;
    backTracking(0, 0);
    return path;
}

private void backTracking(int x, int y) {
    if (x == m - 1 && y == n - 1) {
        path++;
        return;
    }
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY)) {
            backTracking(newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**动态规划**

这题跟最小路径和一模一样

由于机器人只能往下或往右走，所以对于每一个位置来说，机器人只能从该位置的左边或上边到达

```java
// 动态规划
public int uniquePaths(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    // 只需要用一个一维长度为n的滚动数组
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 分状态讨论即可
            // 对于边界位置来说 由于机器人只能往下或往右走，所以只有一种走法，下面前三种可以简化一条语句
            if (i == 0 && j == 0) {
                dp[j] = 1;
            } else if (i == 0) {
                dp[j] = 1;
            } else if (j == 0) {
                dp[j] = 1;
            } else {
                // 对于里面的位置 只能从该位置的左边或上边 分类用加法
                dp[j] = dp[j] + dp[j - 1];
            }

        }
    }
    return dp[n - 1];
}
```



添加哨兵，简化边界，代码可以简洁很多

```java
// 动态规划 添加哨兵 简化边界处理
public int uniquePaths3(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    int[] dp = new int[n];
    // dp[0] 概括了j = 0的边界，并且dp[j]初始化为0 i = 0时 dp[j] = dp[j] + dp[j - 1] = 0;
    dp[0] = 1;
    for (int i = 0; i < m; i++) {
        // 从第一行第二个开始
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j] + dp[j - 1];
        }
    }
    return dp[n - 1];
}
```



### 不同路径 II

#### 题目描述

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

#### 题解

注意这里的边界处理

dp[0] = 1 然后j从1开始遍历这样做是不行的，不同于上一题没有障碍物，所以对于j=0的情况只有一条路可以走，但是这题出现在j = 0的位置存在障碍物的话，那么dp[0] 就等于0，所以是不能这么设置的

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220218235857697.png)

所以我们要对j从0开始遍历，这就又会出现一个问题，因为第二个状态转移方程为`dp[j] = dp[j] + dp[j - 1]   `，就会出现越界的情况，为了简化边界我们将所有状态方程的dp数组的索引都往后挪一位，变成`dp[j + 1] = dp[j + 1] + dp[j]   `和`dp[j + 1] = 0   `

```java
// 动态规划
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if (obstacleGrid == null || obstacleGrid.length == 0) {
        return 0;
    }
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[] dp = new int[n + 1];
    // 哨兵 简化边界
    // 注意这里为什么不能用dp[0] = 1 然后j从1开始遍历
    dp[1] = 1;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 到达障碍物的路径为0条
            if (obstacleGrid[i][j] == 1) {
                dp[j + 1] = 0;
            } else {
                dp[j + 1] = dp[j + 1] + dp[j];
            }
        }
    }
    return dp[n];
}
```



### 打家劫舍

#### 题目描述

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)



#### 题解

![image-20220220154213324](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220220154213324.png)

**回溯**

计算出所有盗窃方案，选取最大值

```java
// 回溯 超时
private List<Integer> res = new ArrayList<>();
private int path;

public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    backTracking(nums, 0);
    Collections.sort(res);
    return res.get(res.size() - 1);
}

private void backTracking(int[] nums, int index) {
    if (index >= nums.length) {
        res.add(path);
        return;
    }
    for (int i = index; i < nums.length; i++) {
        path += nums[i];
        // 注意传的是i + 2 而不是index + 2
        backTracking(nums, i + 2);
        path -= nums[i];
    }
}
```



**记忆化搜索**

从上面的递归树中可以看出，该问题属于最优子结构且存在重复子问题，所以可以用记忆化搜索和动态规划来解决

```java
// 记忆化搜索
private int[] memory;
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    memory = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        memory[i] = -1;
    }
    return backTracking(nums, 0);
}
private int backTracking(int[] nums, int index) {
    if (index >= nums.length) {
        return 0;
    }
    if (memory[index] == -1) {
        int res = 0;
        for (int i = index; i < nums.length; i++) {
            res = Math.max(res, nums[i] + backTracking(nums, i + 2));
        }
        memory[index] = res;
    }
    return memory[index];
}
```



**动态规划**

定义状态：**考虑偷取[x...n - 1]范围里的房子**

得出状态转移方程

```java
f(0) = max{ v(0) + f(0 + 2), v(1) + f(1 + 2), v(2) + f(2 + 2), ..., v(n - 3) + f(n - 3 + 2), v(n - 2), v(n - 1)}
```

```java
// 动态规划
// 转移方程f(0) = max{ v(0) + f(0 + 2), v(1) + f(1 + 2), v(2) + f(2 + 2), ..., v(n - 3) + f(n - 3 + 2), v(n - 2), v(n - 1)}
// 自底向上就是上面方程的从右到左
public int rob3(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int[] dp = new int[n];
    // 最基础的子问题考虑抢劫[n - 1, n - 1]只有一个房子
    dp[n - 1] = nums[n - 1];
    // 自底向上
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            // 注意索引越界
            dp[i] = Math.max(dp[i], nums[j] + (j + 2 < n ? dp[j + 2] : 0));
        }
    }
    return dp[0];
}
```



还有另一种状态的定义方式：**考虑偷取[0 ... x]的房子**，时间复制度可以降到O(N)

那么对于每个x只有两个状态，偷和不偷

可以推出状态转移方程：

```java
取房子x：dp[i] = dp[i - 1]
不偷取房子x：dp[i] = dp[i - 2] + nums[i]
```

```java
public int rob4(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    // 防越界
    if (nums.length == 1) {
        return nums[0];
    }
    int n = nums.length;
    int[] dp = new int[n];
    // 最基础的子问题
    dp[0] = nums[0];
    dp[1] = Math.max(dp[0],nums[1]);
    for (int i = 2; i < n; i++){
        // 对于房子i 在偷与不偷中选择一个最大值
        dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);
    }
    return dp[n - 1];
}
```



### 打家劫舍 II

#### 题目描述

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)



#### 题解

相比打家劫舍1的单排列，这题的区别是一个环状排列，其实本质是一样的，分类讨论就可以转换成打家劫舍1，取金额最大的一类

- 选择了偷窃第一个房子，就**不能选**最后一间房子
- 没有选择偷窃第一个房子，就**可以选择**最后一间房子(不一定选)

那就是可以定义两个状态

- 状态一：**考虑偷取[0 ... n - 2]的房子**
- 状态二：**考虑偷取[1 ... n - 1]的房子**

状态转移方程跟上一题的一样

```java
取房子x：dp[i] = dp[i - 1]
不偷取房子x：dp[i] = dp[i - 2] + nums[i]
```

```java
// 这类的判断不能放在fun方法里，否则样例只有一个元素时，数组复制都为空，答案错误
    if (nums == null || nums.length == 0) {
        return 0;
    }
    if (nums.length == 1) {
        return nums[0];
    }
    // 因为数组复制的原因 所以要保证原数组要大于等于3个元素，或者对dp数组进行偏移也可以
    if (nums.length == 2) {
        return Math.max(nums[0], nums[1]);
    }
    // 分两类转化成打家劫舍1 取最大值
    int[] nums1 = Arrays.copyOfRange(nums,0,nums.length - 1);
    int[] nums2 = Arrays.copyOfRange(nums, 1,nums.length);
    return Math.max(fun(nums1),fun(nums2));
}
// 动态规划 打家劫舍1的方法
private int fun(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    dp[0] = nums[0];
    dp[1] = Math.max(dp[0],nums[1]);
    for (int i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i - 1],dp[i - 2] + nums[i]);
    }
    return dp[n - 1];
}
```



### 打家劫舍 III

树形dp问题

[点击跳转](#house-robber-iii)





## 背包模型

关于背包问题，如果是ACM模式自己控制输入的话，**最好输入从1开始**，就可以避免对物品0的特殊处理



### 0 - 1背包

#### 题目描述

[AcWing2. 01背包问题](https://www.acwing.com/problem/content/description/2/)

有 `N` 件物品和一个容量是 `C` 的背包。**每件物品只能使用一次**。

每一件物品的重量是 `w(i)`，价值是 `v(i)`。

求解将哪些物品装入背包，使得不超过背包容量的基础上，物品总价值最大。



#### 题解

贪心算法解决0 - 1背包为什么不对

按平均价值顺序放入背包：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220221231446899.png)

不按平均价值顺序放入背包：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220221231633901.png)

结果显而易见，我们举出了贪心算法的一个反例

**状态定义：**

`F(n, C)`：考虑将n个物品放入容量为C的背包的最大价值

**状态转移：**

`F(i, c) = max(F(i - 1, c), v(i) + F(i - 1, c - w(i)))`



**DFS**

其实状态转移方程本来就是自顶向下的方法，先用自顶向下看待问题

```java
public int bestValue(int[] w, int[] v, int C) {
    int n = w.length;
    return dfs(w, v, n - 1, C);
}

private int dfs(int[] w, int[] v, int index, int c) {
    if (index < 0 || c <= 0) {
        return 0;
    }
    // 对于索引为index的物品，不放入背包中
    int res = dfs(w, v, index - 1, c);
    // 对于索引为index的物品，背包容量充足 放入背包中
    if (w[index] <= c) {
        // 两种策略取最值
        res = Math.max(res, v[index] + dfs(w, v, index - 1, c - w[index]));
    }
    return res;
}
```



**记忆化搜索**

存在重叠子问题和最优子结构，重叠子问题来源于`index`和`c`构成的数据对，在整个的求解的过程中存在重复的数据对，因为背包问题是有两个约束条件，所以开辟二维数组来记忆化

```java
// 记忆化搜索
private int[][] memory;
public int bestValue(int[] w, int[] v, int C) {
    int n = w.length;
    // 一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    memory = new int[n][C + 1];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= C; j++) {
            memory[i][j] = -1;
        }
    }
    return dfs(w, v, n - 1, C);
}

private int dfs(int[] w, int[] v, int index, int c) {
    if (index < 0 || c <= 0) {
        return 0;
    }
    if (memory[index][c] == -1) {
        // 对于索引为index的物品，不放入背包中
        int res = dfs(w, v, index - 1, c);
        // 对于索引为index的物品，背包容量充足 放入背包中
        if (w[index] <= c) {
            // 两种策略取最值
            res = Math.max(res, v[index] + dfs(w, v, index - 1, c - w[index]));
        }
        memory[index][c] = res;
    }
    return memory[index][c];
}
```



**动态规划**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222174325641.png)

```java
public int bestValue(int[] w, int[] v, int C) {
    if (w == null || w.length == 0) {
        return 0;
    }
    int n = w.length;
    // dp数组：所持最大价值，一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    int[][] dp = new int[n][C + 1];
    // 最基础的问题 对于0这个物品
    for (int j = 0; j <= C; j++) {
        dp[0][j] = (w[0] <= j ? v[0] : 0);
    }
    // 考虑[1,n)个物品
    for (int i = 1; i < n; i++) {
        // 背包容量为j
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            dp[i][j] = dp[i - 1][j];
            if (w[i] <= j) {
                // 放入背包
                dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - 1][j - w[i]]);
            }
        }
    }
    return dp[n - 1][C];
}
```



**动态规划的空间优化**

根据转移方程`F(i, c) = max(F(i - 1, c), v(i) + F(c - w(i)))`可知第`i`行元素只依赖第`i- 1`行元素，所以理论上只需要维持两行元素

空间复杂度：`O(n * C) ==> O(2C)  `

```java
// 空间优化
public int bestValue4(int[] w, int[] v, int C) {
    if (w == null || w.length == 0) {
        return 0;
    }
    int n = w.length;
    // dp数组：所持最大价值，一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    int[][] dp = new int[2][C + 1];
    // 最基础的问题 对于0这个物品
    for (int j = 0; j <= C; j++) {
        dp[0][j] = (w[0] <= j ? v[0] : 0);
    }
    // 考虑[1,n)个物品
    for (int i = 1; i < n; i++) {
        // 背包容量为j
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            // 使用余数 只使用两行
            dp[i % 2][j] = dp[(i - 1) % 2][j];
            if (w[i] <= j) {
                // 放入背包
                dp[i % 2][j] = Math.max(dp[i % 2][j], v[i] + dp[(i - 1) % 2][j - w[i]]);
            }
        }
    }
    return dp[(n - 1) % 2][C];
}
```



**动态规划进一步空间优化**

直接使用一维dp数组

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222212506866.png)

每次更新下一行的`dp[i][j]`时，我们永远只会使用`dp[i][j]`上面的元素及上一行左边的元素，永远不会使用上一行右边的元素，这就提示我们如果只使用一维dp数组的话，我们可以**从右向左**刷新元素

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222213003360.png)

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222213236130.png)

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220223221114105.png)

我们可以看到使用一维数组从右向左更新，还可以提前结束

```java
// O(C)空间复杂度 代码更加简洁
public int bestValue5(int[] w, int[] v, int C) {
    if (w == null || w.length == 0) {
        return 0;
    }
    int n = w.length;
    // dp数组：所持最大价值，一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    int[] dp = new int[C + 1];
    // 最基础的问题 对于0这个物品
    for (int j = 0; j <= C; j++) {
        dp[j] = (w[0] <= j ? v[0] : 0);
    }
    // 考虑[1,n)个物品
    for (int i = 1; i < n; i++) {
        // 背包容量为j 从右到左更新
        for (int j = C; j >= w[i]; j--) {
            // 不放入背包:dp[j] 放入背包：v[i] + dp[j - w[i]]
            dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
        }
    }
    return dp[C];
}
```

ACM 模式

```java
import java.util.Scanner;

public class Test {
    static int n;
    static int C;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int[] w = new int[n];
        int[] v = new int[n];
        int[] dp = new int[C + 1];
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }

        for (int i = 0; i < n; i++) {
            for (int j = C; j >= w[i]; j--) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
        System.out.println(dp[C]);
    }
}
```



### 完全背包

#### 题目描述

[AcWing3. 完全背包问题](https://www.acwing.com/problem/content/description/3/)

有 `N` 件物品和一个容量是 `C` 的背包。**每件物品可以无限使用**。

每一件物品的重量是 `w(i)`，价值是 `v(i)`。

求解将哪些物品装入背包，使得不超过背包容量的基础上，物品总价值最大。



#### 题解



**朴素解法**

对于每个dp[i, j]的来源：第 i 个物品有 k 种选法，可以选1个i物品，可以选两个i物品...

![image-20220327211424210](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327211424210.png)

```java
import java.util.*;

public class Test {
    static int n;
    static int C;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int[] w = new int[n];
        int[] v = new int[n];
        int[][] dp = new int[n][C + 1];
        
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }
        // 注意考虑物品0的时候要将所有值都填正确
        for (int j = 1; j <= C; j++) {
            dp[0][j] = dp[0][j - 1];
            if (j % w[0] == 0) {
                dp[0][j] = (j / w[0]) * v[0];
            }
        }
        // 朴素的完全背包
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= C; j++) {
                for (int k = 0; k * w[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], k * v[i] + dp[i - 1][j - k * w[i]]);
                }
            }
        }
        
        System.out.println(dp[n - 1][C]);
    }
}
```



完全背包二维公式推导：
朴素的状态转移：

```
f(i,j) = Max(f(i-1,j), v + f(i-1,j-w), 2v + f(i-1, j-2w)), 3v + f(i-1, j-3w), ... k*v + f(i-1, j-k*w))
```

那么将`j = j-w`代入上式有

```
f(i,j-w) = Max(f(i-1,j-w), v + f(i-1,j-2w), 2v + f(i-1, j-3w)), 3v + f(i-1, j-4w), ... (k-1)*v + f(i-1, j-k*w))
```

因为k是取不完的，所有我们可以将两式对齐吗，所以可以将`f(i,j-w)`+`v`代替朴素公式后面的项

```
f(i,j) = Max(f(i-1,j), v + f(i,j-w))
```

此时`f(i,j)`只依赖两项，从而由三维降到二维



**状态定义：**

`F(n, C)`：考虑将n个物品放入容量为C的背包的最大价值

**状态转移：**

`F(i, c) = max(F(i - 1, c), v(i) + F(i, c - w(i)))`

> 注意：完全背包与01背包的区别就是在转移方程这里，放入背包的转移方程为`v(i) + F(i, c - w(i))`，而不是`v(i) + F(i - 1, c - w(i))`，为什么不是`i - 1`，因为对于前`i`件物品，背包容量为`c - w[i]`时可能已经放入了第`i`件物品，而每件物品是可以放入无限次的，所以容量为`c`时还可以放入第i件物品，所以用`f[i][j - w(i)]`来更新`f[i][j]`

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220223223021946.png)

而且可以看到，对于同一行来说每个不同容量的背包更新的跨度为`v(i)`，`f[j]`的更新依赖的是同一行的新值`f[j - w(i)]`和上一行的旧值`f[j]`，所以在空间优化时使用顺序更新，如果逆序更新的话`f[j]`的更新拿到的是旧值`f[j - w(i)]`

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220223234350891.png)

```java
// 动态规划 空间复杂度O(n * C)
public int bestValue(int[] w, int[] v, int C) {
    int n = w.length;
    int dp[][] = new int[n][C + 1];
	// 对于第一行的初始化二维不能放进下面的循环里 因为第一维依赖于i - 1不能从0开始
    for (int j = 0; j <= C; j++) {
        dp[0][j] = dp[0][j - 1];
        if (j % w[0] == 0) {
            dp[0][j] = (j / w[0]) * v[0];
        }
    }

    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            dp[i][j] = dp[i - 1][j];
            if (w[i] <= j) {
                // 放入背包 两种策略取最优值
                dp[i][j] = Math.max(dp[i][j], v[i] + dp[i][j - w[i]]);
            }
        }
    }
    return dp[n - 1][C];
}
```

**空间优化**

```java
// 空间优化
public int bestValue2(int[] w, int[] v, int C) {
    int n = w.length;
    int dp[] = new int[C + 1];
	// 对于第一行的初始化也可以放进下面的循环里 i从0开始
    for (int j = 0; j <= C; j++) {
        dp[j] = (w[0] <= j ? v[0] 
                 : 0);
    }

    /*for (int i = 1; i < n; i++) {
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            dp[j] = dp[j];
            if (w[i] <= j) {
                // 放入背包 两种策略取最优值
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
    }*/

    // 可以省略if判断 背包容量从装得下w[i]的物品开始，前面装不下w[i]的直接使用旧值，不需要更新
    for (int i = 1; i < n; i++) {
        for (int j = w[i]; j <= C; j++) {
            // 两种策略取最优值
            dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
        }
    }
    return dp[C];
}
```



ACM模式

```java
import java.util.*;

public class Test {
    static int n;
    static int C;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int[] w = new int[n];
        int[] v = new int[n];
        int[] dp = new int[C + 1];
        
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }

        // 一维
        for (int i = 0; i < n; i++) {
            for (int j = w[i]; j <= C; j++) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
        
        System.out.println(dp[C]);
    }
}
```



### 多重背包

#### 题目描述

[AcWing4. 多重背包问题](https://www.acwing.com/problem/content/description/4/)

有 `N` 件物品和一个容量是 `C` 的背包。**每件物品不止一个，有`num[i]`个**。

每一件物品的重量是 `w(i)`，价值是 `v(i)`。

求解将哪些物品装入背包，使得不超过背包容量的基础上，物品总价值最大。

#### 题解



**朴素版**



其实和完全背包朴素版的状态转移方程一样，第三维都是枚举所有的数量

![image-20220328153816241](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220328153816241.png)

多重背包朴素的状态转移方程：

```
f(i,j) = Max(f(i-1,j), v + f(i-1,j-w), 2v + f(i-1, j-2w)), 3v + f(i-1, j-3w), ... s[i]*v + f(i-1, j-s[i]*w))
```



朴素版

```java
import java.util.*;

public class Test {
    static int n;
    static int C;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        
        int[] w = new int[n + 1];
        int[] v = new int[n + 1];
        int[] s = new int[n + 1];
        int[][] dp = new int[n + 1][C + 1];
        
        for (int i = 1; i <= n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
            s[i] = sc.nextInt();
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= C; j++) {
                // k小于i件物品的总数量且背包能够装得下
                for (int k = 0; k <= s[i] && k * w[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], k * v[i] + dp[i - 1][j - k * w[i]]);
                }
            }
        }
        
        System.out.println(dp[n][C]);
    }
}
```



**二维优化**

我们能否用完全背包的思路取优化朴素版的多重背包

我们来看一下
朴素的状态转移：

```
f(i,j) = Max(f(i-1,j), v + f(i-1,j-w), 2v + f(i-1, j-2w)), 3v + f(i-1, j-3w), ... s*v + f(i-1, j-s*w))
```

那么将`j = j-w`代入上式有

```
f(i,j-w) = Max(f(i-1,j-w), v + f(i-1,j-2w), 2v + f(i-1, j-3w)), 3v + f(i-1, j-4w), ... s*v + f(i-1, j-(s+1)*w))
```

因为多重背包的s是确定的，我们没办法对齐后面的项，会多出来最后一项

![image-20220328160759763](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220328160759763.png)

我们没有办法通过`f(i,j-w)`的最大值再减去某一项的值而推出剩下项的最大值，最大值是不可以做减法的



所以不能通过完全背包的优化思路来优化多重背包。



**将多重背包通过二进制数组合转化为01背包**

```java
import java.util.*;

public class Test {
    static int n;
    static int C;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int count = 1;

        // 新物品的数量是 n * ([logSmax] + 1) --> 上取整 n为原不同物品的数量，所以wv的数组只要比它大就行
        int[] w = new int[20 * n];
        int[] v = new int[20 * n];
        int[] dp = new int[C + 1];

        for (int i = 1; i <= n; i++) {
            int W = sc.nextInt();
            int V = sc.nextInt();
            int S = sc.nextInt();
            int k = 1;
            // 按二进制拆分多个物品组合成一个新的物品，我们就可以当每一件组合成的物品都是不一样的，从而转化为01背包求解
            while (k <= S) {
                w[count] = k * W;
                v[count] = k * V;
                S -= k;
                k <<= 1; // 左移一位
                count++;
            }
            // 还有剩余
            if (S > 0) {
                w[count] = S * W;
                v[count] = S * V;
                count++;
            }
        }

        // 组合后新物品的总数量
        n = count;
		// 直接使用空间优化后的01背包套路
        for (int i = 1; i <= n; i++) {
            for (int j = C; j >= w[i]; j--) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }

        System.out.println(dp[C]);
    }
}

```



### 二维费用背包

#### 题目描述

[AcWing8. 二维费用的背包问题](https://www.acwing.com/problem/content/description/8/)

有 $N$ 件物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。

每件物品只能用一次。体积是 $vi$，重量是 $mi$，价值是 $wi$。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。

**输入格式**

第一行三个整数，$N,V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。

接下来有 $N$ 行，每行三个整数 $vi,mi,wi$，用空格隔开，分别表示第 ii 件物品的体积、重量和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N≤1000$
$0<V,M≤100$
$0<vi,mi≤100$
$0<wi≤1000$

**输入样例**

```
4 5 6
1 2 3
2 4 4
3 4 5
4 5 6
```

**输出样例：**

```
8
```



#### 题解

二维费用可以绑定到任意背包问题上，这题绑定的是01背包。

其实二维费用背包仅仅是对状态多加了一维而已，思路还是与01背包一样

**状态定义：**

$F(n, V, M)$：考虑将 $n$ 个物品放入最大承受重量 $M$ 且最大体积 $V$ 的背包的最大价值

**状态转移：**

$F(i, j, k) = max(F(i - 1, j, k), w(i) + F(i, j - v(i), k - m(i)))$

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int V = read.nextInt();
        int M = read.nextInt();
        
        int[] v = new int[n + 1];
        int[] m = new int[n + 1];
        int[] w = new int[n + 1];
        
        for (int i = 1; i <= n; i++) {
            v[i] = read.nextInt();
            m[i] = read.nextInt();
            w[i] = read.nextInt();
        }
        
        int[][][] dp = new int[n + 1][V + 1][M + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= V; j++) {
                for (int k = 0; k <= M; k++) {
                    dp[i][j][k] = dp[i - 1][j][k];
                    // 当前物品重量和体积均小于当前背包剩余体积和重量时才考虑放入背包
                    if (v[i] <= j && m[i] <= k) {
                        dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - v[i]][k - m[i]] + w[i]);
                    }
                }
            }
        }
        
        System.out.println(dp[n][V][M]);
    }
} 
```



**空间优化**

同样可以优化掉物品的那一维：

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int V = read.nextInt();
        int M = read.nextInt();
        
        int[] v = new int[n + 1];
        int[] m = new int[n + 1];
        int[] w = new int[n + 1];
        
        for (int i = 1; i <= n; i++) {
            v[i] = read.nextInt();
            m[i] = read.nextInt();
            w[i] = read.nextInt();
        }
        
        int[][] dp = new int[V + 1][M + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int j = V; j >= v[i]; j--) {
                for (int k = M; k >= m[i]; k--) {
                    dp[j][k] = Math.max(dp[j][k], dp[j - v[i]][k - m[i]] + w[i]);
                }
            }
        }
        
        System.out.println(dp[V][M]);
    }
} 
```



### 分割等和子集

#### 题目描述

[LeetCode416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)



#### 题解

典型的**01背包问题**，在n个物品中选出一定物品，**填满sum/2的背包**，不牵涉物品的价值，只是将背包填满



**状态定义：**

`F(n, C)`：考虑将n个物品能否填满容量为C的背包（布尔值）

**状态转移：**

如果使用`i - 1`个物品能填满c，那么之后我们就不用选择其他物品，第`i`个物品肯定也能填满c

或者是我们用`i - 1`个物品已经填了`c - w(i)`的容量，那么我们就选择将`nums(i)`放入背包也能填满c

`F(i, c) = F(i - 1, c) || F(i - 1, c - w(i))  `



**DFS**

```java
// dfs超时
public boolean canPartition(int[] nums) {
    if (nums == null || nums.length == 0) {
        return false;
    }
    int n = nums.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
    }
    // 最基本的条件所有子集的和为偶数才能分割
    if (sum % 2 != 0) {
        return false;
    }
    return dfs(nums, n - 1, sum / 2);
}

// 使用nums[0...index]，是否可以完全填充一个容量为c的背包
private boolean dfs(int[] nums, int index, int c) {
    if (c == 0) {
        return true;
    }
    if (index < 0 || c < 0) {
        return false;
    }
    return dfs(nums, index - 1, c)
            || dfs(nums, index - 1, c - nums[index]);
}
```



**记忆化搜索**

```java
// 记忆化搜索
// -1 表示未计算; 1 表示可以填充; 0 表示不可以填充
// memory为什么使用int而不是用boolean，因为当前的状态除了能否填满，还要表示之前是否使用过，所以boolean不够用
private int[][] memory;
public boolean canPartition(int[] nums) {
    if (nums == null || nums.length == 0) {
        return false;
    }
    int n = nums.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
    }
    // 最基本的条件所有子集的和为偶数才能分割
    if (sum % 2 != 0) {
        return false;
    }
    memory = new int[n][sum / 2 + 1];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= sum / 2; j++) {
            memory[i][j] = -1;
        }
    }
    return dfs(nums, n - 1, sum / 2);
}

// 使用nums[0...index]，是否可以完全填充一个容量为c的背包
private boolean dfs(int[] nums, int index, int c) {
    if (c == 0) {
        return true;
    }
    if (index < 0 || c < 0) {
        return false;
    }
    if (memory[index][c] == -1) {
        memory[index][c] = ((dfs(nums, index - 1, c)
                || dfs(nums, index - 1, c - nums[index]))) ? 1 : 0;
    }
    return memory[index][c] == 1;
}
```



**动态规划**

```java
public boolean canPartition3(int[] nums) {
    int n = nums.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
    }
    if (sum % 2 != 0) {
        return false;
    }
    // 在递推的过程中肯定是从小问题去向大问题逐步递推 所以不牵涉到判断某一个值是否被计算过 这里可以使用boolean
    // 因为肯定是没有被计算过的
    int C = sum / 2;
    boolean[] dp = new boolean[C + 1];
    // 初始化 最基础的问题 对于0索引这个物品是否能将容量为j的背包填满
    for(int j = 0; j <= C; j++) {
        dp[j] = (nums[0] == j);
    }

    for (int i = 1; i < n; i++) {
        for (int j = C; j >= nums[i]; j--) {
            // dp[j]能被填满或者dp[j - nums[i]]这个背包加上当前的nums[i]可以被填满
            dp[j] = dp[j] || dp[j - nums[i]];
        }
    }
    return dp[C];
}
```



### 零钱兑换

#### 题目描述

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)



#### 题解

**典型完全背包问题**

物品可以无限使用，将背包(目标和)填满



**状态定义：**

`dp[i]`：凑齐总价值 `i` 需要的最少硬币个数

**状态转移：**

`dp[i] = min(dp[i], 1 + dp[i - coins[i]])`

填满容量为`i`的背包或者可以填满`i  - coin[i]`这个背包再加一个物品`coin[i]`，两种策略去最小值



**DFS**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.png)

```java
// dfs超时
private int res;

public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return -1;
    }
    res = Integer.MAX_VALUE;
    dfs(coins, amount, 0);
    if (res == Integer.MAX_VALUE) {
        return -1;
    }
    return res;
}

private void dfs(int[] coins, int amount, int index) {
    if (amount == 0) {
        // index从0开始 这里的index已经+1所以是正确的
        res = Math.min(res, index);
        return;
    }
    if (amount < 0) {
        // 不能凑出amount res的初始值不会被改变
        return;
    }
    for (int i = 0; i < coins.length; i++) {
        dfs(coins, amount - coins[i], index + 1);
    }
}
```



**记忆化搜索**

```java
// 记忆化搜素
private int[] memory;

public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return -1;
    }
    // 初始化为0
    memory = new int[amount + 1];
    return dfs(coins, amount);
}

private int dfs(int[] coins, int amount) {
    if (amount == 0) {
        // 填满容量为0的背包 不需要放入物品 物品个数为0
        return 0;
    }
    if (amount < 0) {
        // 不能填满容量为amount的背包
        return -1;
    }
    if (memory[amount] == 0) {
        int minCount = Integer.MAX_VALUE;
        for (int i = 0; i < coins.length; i++) {
            // res 为填满容量为amount - coin[i]的最少个数
            int res = dfs(coins, amount - coins[i]);
            if (res != -1 && res + 1 < minCount) {
                // 如果存在解 且res解所需的硬币+1 < minCount 则更新minCount
                // 可以填满amount - coin[i]这个背包 再加上当前的coins[i]这一个物品就能填满amount
                minCount = res + 1;
            }
        }
        memory[amount] = (minCount == Integer.MAX_VALUE ? -1 : minCount);
    }
    return memory[amount];
}
```



**动态规划**

直接上空间优化版

```java
// 动态规划
public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return -1;
    }
    int n = coins.length;
    // 凑齐总价值为j 需要的最少硬币个数
    int[] dp = new int[amount + 1];
    // dp数组初始化为一个不可能达到的最大值
    Arrays.fill(dp, amount + 1);
    // 容量为0的背包 最少放0个硬币
    dp[0] = 0;
    // 对物品从0开始遍历 因为每个物品都是可以重复选择，对于物品0我们也放进去遍历更方便
    for (int i = 0; i < n; i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]);
        }
    }
    return dp[amount] == (amount + 1) ? -1 : dp[amount];
}
```





### 零钱兑换 II

#### 题目描述



#### 题解

这道题和「力扣」第 39 题：[组合总和](https://leetcode-cn.com/problems/combination-sum/) 很像，只不过：

- 第 39 题问的是所有的组合列表，应该使用 **回溯算法** 求解；
- 第 518 题问的是组合有多少种，而不是问具体的解。应该使用 **动态规划** 求解。



这题是一道经典的完全背包问题，但是注意的是单纯完全背包的两个for循环的先后顺序都是可以的。

**但本题就不行了！**

因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间要求没有顺序。

所以纯完全背包是能凑成总和就行，不用管怎么凑的。

本题是求凑出来的方案个数，且每个方案个数是为组合数。

那么本题，两个for循环的先后顺序可就有说法了。

我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

代码如下：

```cpp
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序，代码如下：

```text
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**



**动态规划**

**状态定义：**

`dp[i][j]`：考虑`[0, i]`个物品凑齐总价值 `j` 需要的最少硬币个数

**状态转移：**

`dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]] `

对于每一个物品，都有选与不选两种选择，分类计数使用加法



```java
public int change(int amount, int[] coins) {
    if (coins.length < 1) {
        if (amount == 0) {
            return 1;
        }
        return 0;
    }
    int n = coins.length;
    int[][] dp = new int[n][amount + 1];
    dp[0][0] = 1;
    // 初始化 只考虑物品0 只有背包容量为物品0的倍数时 才能恰好装满 j += coins[0]
    for (int j = coins[0]; j <= amount; j += coins[0]) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= amount; j++) {
            // 不选择将coins[i] 放入背包
            dp[i][j] = dp[i - 1][j];
            if (j - coins[i] >= 0) {
                // 如果背包容量装得下coins[i] 选择放入背包 分类是加法
                dp[i][j] += dp[i][j - coins[i]];
            }
        }
    }
    return dp[n - 1][amount];
}
```



**空间优化**

```java
public int change(int amount, int[] coins) {
    if (coins == null || coins.length == 0) {
        if (amount == 0) {
            return 1;
        }
        return 0;
    }
    int n = coins.length;
    int[] dp = new int[amount + 1];
    // 初始化 只考虑物品0
    dp[0] = 1;
    // 对物品从0开始遍历 因为每个物品都是可以重复选择，对于物品0我们也放进去遍历更方便
    for (int i = 0; i < n; i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] += dp[j - coins[i]];
        }
    }
    return dp[amount];
}
```



### 组合总和 Ⅳ

#### 题目描述

<span id="combination-sum-iv">组合总和 Ⅳ</span>

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

#### 题解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220224220521637.png)





**回溯**

```java
// 回溯超时
private List<Integer> path = new ArrayList<>();
private List<List<Integer>> res = new ArrayList<>();

public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    backTracking(nums, target);
    return res.size();
}

private void backTracking(int[] nums, int target) {
    if (target <= 0) {
        if (target == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        path.add(nums[i]);
        backTracking(nums, target - nums[i]);
        path.remove(path.size() - 1);
    }
}
```



**记忆化搜索**



**状态定义：**

`dp[i]`：所有能凑齐 `i` 的所有排列数

**状态转移：**

`dp[i] = dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... + dp[i - nums[n - 1]]`

并且定义 `dp[0] = 1 `，它表示如果 `nums` 里有一个数恰好等于 `target`，它单独成为 1 种可能。



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/0794281ad38dd4fc9a47b890b27ca14d61d4be41820f36fc7f8fcf09086293ea-image.png)

```java
// 记忆化搜索
private int[] memory;

public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    memory = new int[target + 1];
    for (int i = 0; i <= target; i++) {
        memory[i] = -1;
    }
    return dfs(nums, target);
}

private int dfs(int[] nums, int target) {
    if (target <= 0) {
        // dp[0] = 1
        if (target == 0) {
            return 1;
        }
        return 0;
    }
    if (memory[target] == -1) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res = res + dfs(nums, target - nums[i]);
        }
        memory[target] = res;
    }
    return memory[target];
}
```



**动态规划**

实际意义上这道题不能算作完全背包问题，因为这题跟零钱兑换不同之处是 **对于物品是考虑放入的顺序的**，实际上是一道排列题

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```java
// 动态规划
public int combinationSum42(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] <= i) {
                dp[i] = dp[i] + dp[i - nums[j]];
            }
        }
    }

    return dp[target];
}
```





### 一和零

#### 题目描述

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)



#### 题解



**DFS**

```java
// dfs超时
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0 || (m == 0 && n == 0)) {
        return 0;
    }
    return dfs(strs,0, m, n);
}

private int dfs(String[] strs,int index, int m, int n) {
    if (index == strs.length) {
        return 0;
    }
    char[] str = strs[index].toCharArray();
    int one = 0;
    int zero = 0;
    for (int i = 0; i < str.length; i++) {
        if (str[i] == '0') {
            zero++;
        }
        if (str[i] == '1') {
            one++;
        }
    }
    // 当前str[index] 0 和 1 的个数都不超过m和n才有选与不选两种选择，否则只能不选
    if (m >= zero && n >= one) {
        return Math.max(dfs(strs, index + 1, m, n), 1 + dfs(strs, index + 1, m - zero, n - one));
    } else {
        return dfs(strs, index + 1, m, n);
    }
}
```



**记忆化搜索**

这题实际上就是一个**01背包问题**，m和n两个背包

**状态定义：**

`dp[i][j][k]`：考虑前 `i`件物品至多用`j`个0，`k`个1的`strs`的最大子集的长度

**状态转移：**

`dp[i][j][k] = max(dp[i - 1][j][k], 1 + dp[i - 1][j - zero][k - one])`

```java
// 自顶向下 记忆化搜索
private int[][][] memory;
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0 || (m == 0 && n == 0)) {
        return 0;
    }
    memory = new int[strs.length][m + 1][n + 1];
    for (int i = 0; i < strs.length; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                memory[i][j][k] = -1;
            }
        }
    }
    return dfs(strs,strs.length - 1, m, n);
}

private int dfs(String[] strs, int index, int m, int n) {
    if (index < 0) {
        return 0;
    }
    int zero = 0;
    int one = 0;
    char[] str = strs[index].toCharArray();
    for (int i = 0; i < str.length; i++) {
        if (str[i] == '0') {
            zero++;
        }
        if (str[i] == '1') {
            one++;
        }
    }
    if (memory[index][m][n] == -1) {
        // 当前str[index] 0 和 1 的个数都不超过m和n才有选与不选两种选择，否则只能不选
        if (m >= zero && n >= one) {
            memory[index][m][n] = Math.max(dfs(strs, index - 1, m, n), 1 + dfs(strs, index - 1, m - zero, n - one));
        } else {
            memory[index][m][n] = dfs(strs, index - 1, m, n);
        }
    }
    return memory[index][m][n];
}
```

因为使用三维数组和三重循环，虽然能通过效率不是很高



**动态规划**

```java
// 三维数组动态规划
public int findMaxForm(String[] strs, int m, int n) {
    int len = strs.length;
    int[][] strInfo = new int[len][2];
    // 存储所有字符的01信息
    for (int i = 0; i < len; i++) {
        char[] str = strs[i].toCharArray();
        int zero = 0;
        int one = 0;
        for (int j = 0; j < str.length; j++) {
            if (str[j] == '0') {
                zero++;
            }
            if (str[j] == '1') {
                one++;
            }
        }
        strInfo[i] = new int[] {zero, one};
    }

    int[][][] dp = new int[len][m + 1][n + 1];
    // 初始化dp数组 考虑第一件物品 这个也可以放到下面的循环一起
    for (int j = 0; j <= m; j++)  {
        for (int k = 0; k <= n; k++) {
            if (strInfo[0][0] <= j && strInfo[0][1] <= k) {
                dp[0][j][k] = 1;
            } else {
                dp[0][j][k] = 0;
            }
        }
    }

    for (int i = 1; i < len; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                // 当前strInfo 0 和 1 的个数都不超过m和n才有选与不选两种选择，否则只能不选
                if (strInfo[i][0] <= j && strInfo[i][1] <= k) {
                    dp[i][j][k] = Math.max(dp[i - 1][j][k], 1 + dp[i - 1][j - strInfo[i][0]][k - strInfo[i][1]]);
                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                }
            }
        }
    }
    return dp[len - 1][m][n];
}
```



**动态规划的空间优化**

因为本质上是一道01背包，可以取消物品维度进行空间优化，使用逆序遍历

```java
// 空间优化 取消物品维度
public int findMaxForm(String[] strs, int m, int n) {
    int len = strs.length;
    int[][] strInfo = new int[len][2];
    // 存储所有字符的01信息
    for (int i = 0; i < len; i++) {
        char[] str = strs[i].toCharArray();
        int zero = 0;
        int one = 0;
        for (int j = 0; j < str.length; j++) {
            if (str[j] == '0') {
                zero++;
            }
            if (str[j] == '1') {
                one++;
            }
        }
        strInfo[i] = new int[]{zero, one};
    }

    int[][] dp = new int[m + 1][n + 1];
    // 初始化dp数组 考虑第一件物品 这个也可以放到下面的循环一起
    for (int j = 0; j <= m; j++) {
        for (int k = 0; k <= n; k++) {
            if (strInfo[0][0] <= j && strInfo[0][1] <= k) {
                dp[j][k] = 1;
            } else {
                dp[j][k] = 0;
            }
        }
    }

    for (int i = 1; i < len; i++) {
        // 和01背包的空间优化一样 逆序遍历 可以提前结束 省去了额外的if判断
        for (int j = m; j >= strInfo[i][0]; j--) {
            for (int k = n; k >= strInfo[i][1]; k--) {
                dp[j][k] = Math.max(dp[j][k], 1 + dp[j - strInfo[i][0]][k - strInfo[i][1]]);
            }
        }
    }
    return dp[m][n];
}
```



### 单词拆分

#### 题目描述



#### 题解



**回溯**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/78fd09b2deabeae972809c2795ddb8be96720b8e62377cf01b7f70e7fb3dbf8c-image.png)



```java
// 回溯超时
public boolean wordBreak(String s, List<String> wordDict) {
    if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) {
        return false;
    }
    // 一个技巧将list转化成set，使用contains可以降低时间复杂度到大常数级别
    // 而list本质就是通过数组实现的，查找一个元素是否包含要用到遍历，时间复杂度是O（n）
    Set<String> set = new HashSet<>(wordDict);
    return backTracking(s, set, 0);
}

private boolean backTracking(String s, Set<String> set, int index) {
    if (index >= s.length()) {
        return true;
    }
    for (int i = index; i < s.length(); i++) {
        // 如果wordDict含有[index, i + 1)的子串，则继续对剩余子串做考察
        // 由于subString生成了新的字符串对象，因此不会对原来的字符串产生影响，因此回溯之后不需要做状态重置。
        if (set.contains(s.substring(index, i + 1))) {
            // 如果wordDict不含有剩余子串则回溯到上一层，i递进 继续考察[index, i + 1)
            if (backTracking(s, set, i + 1)) {
                return true;
            }
        }
    }
    return false;
}
```



**记忆化搜搜**

图中数字代表index指针，可以看到递归树中存在大量的重复子问题，所以可以用记忆化数组存储值，索引为index指针

`memory[index] = -1`表示未使用

`memory[index] = 1`表示可以用`wordDict`的元素凑出`s`0-index的子串

`memory[index] = 0`表示可以用`wordDict`的元素不能凑出`s`0-index的子串

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/5cba31457da78b75f3d593ef6f3c64c34e80db00c5e619f7e03affb1d6b829f0-image.png)



```java
private int[] memory;

public boolean wordBreak(String s, List<String> wordDict) {
    if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) {
        return false;
    }
    memory = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        memory[i] = -1;
    }
    Set<String> set = new HashSet<>(wordDict);
    return backTracking(s, set, 0);
}

private boolean backTracking(String s, Set<String> set, int index) {
    if (index >= s.length()) {
        return true;
    }
    if (memory[index] != -1) {
        return memory[index] == 1;
    }
    for (int i = index; i < s.length(); i++) {
        // 如果wordDict含有[index, i + 1)的子串，则继续对剩余子串做考察
        // 由于subString生成了新的字符串对象，因此不会对原来的字符串产生影响，因此回溯之后不需要做状态重置。
        if (set.contains(s.substring(index, i + 1))) {
            // 如果wordDict不含有剩余子串则回溯到上一层，i递进 继续考察[index, i + 1)
            if (backTracking(s, set, i + 1)) {
                memory[index] = 1;
                return true;
            }
        }
    }
    memory[index] = 0;
    return false;
}
```





**动态规划**

完全背包问题，字典可以重复使用，只要求能组合出给定字符串

**状态定义：**

`dp[i]`：表示可以从字典中组合出给定字符串索引为`0 - i`的子串

**状态转移：**

`dp[i] = dp[pre] && wordDict.contain(s.substring(pre, i)  `





![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220227202845068.png)



```java
// 动态规划
public boolean wordBreak(String s, List<String> wordDict) {
    int n = s.length();
    Set<String> set = new HashSet<>(wordDict);
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    // 遍历背包 字符串
    for (int i = 1; i <= n; i++) {
        // 遍历物品 字典
        for (String word : wordDict) {
            int pre = i - word.length();
            if (pre >= 0 && set.contains(s.substring(pre, i)) && dp[pre] == true) {
                dp[i] = true;
                // 只要有一个可以组成就break
                break;
            }
        }
    }
    return dp[n];
}
```





### 目标和

#### 题目描述





#### 题解

**DFS**

由于数据范围较小，dfs可以通过

```java
// dfs
private int count = 0;
public int findTargetSumWays(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    dfs(nums, target, 0);
    return count;
}

private void dfs(int[] nums, int target, int index) {
    if (index == nums.length) {
        if (target == 0) {
            this.count++;
        }
        return;
    }
    // 添加负号
    dfs(nums, target - nums[index], index + 1);
    // 添加正号
    dfs(nums, target + nums[index], index + 1);
}
```



**记忆化搜索**



```java
// 记忆化搜索
// 由于target可能是负权值 所以不能直接使用一维来做缓存
// index和target两个条件限制 用String来表示这两个条件
private Map<String, Integer> memory = new HashMap<>();

public int findTargetSumWays(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    return dfs(nums, target, 0);
}

private int dfs(int[] nums, int target, int index) {
    if (index == nums.length) {
        // 能凑出target 返回一种方案 否则0方案
        if (target == 0) {
            return 1;
        }
        return 0;
    }
    String key = index + "_" + target;
    if (!memory.containsKey(key)) {
        int res = dfs(nums, target - nums[index], index + 1) + dfs(nums, target + nums[index], index + 1);
        memory.put(key, res);
    }
    return memory.get(key);
}
```



**动态规划**

转化为01背包问题，**装满容量为target背包，有几种方法**

**状态定义：**

`dp[i][j]`：考虑前`i`个数，当前计算结果为`j`的方案数

**状态转移：**

`dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j + nums[i - 1]]  `



```java
// 动态规划
public int findTargetSumWays2(int[] nums, int target) {
    int n = nums.length;
    int border = 0;
    for (int i = 0; i < n; i++) {
        border += Math.abs(nums[i]);
    }
    // 如果target 大于边界的话 不存在方案
    if (Math.abs(target) > border) {
        return 0;
    }
    // target的范围只可能在[-border, border]间
    int[][] dp = new int[n + 1][2 * border + 1];
    // 因为target可能存在负权值 为了能够计算负权值 我们将所有dp的索引都做一个border的右偏移
    dp[0][0 + border] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = -border; j <= border; j++) {
            // 两个if保证索引值不为负
            if ((j - nums[i - 1]) + border >= 0) {
                dp[i][j + border] += dp[i - 1][(j - nums[i - 1]) + border];
            }
            if ((j + nums[i - 1]) + border <= 2 * border) {
                dp[i][j + border] += dp[i - 1][(j + nums[i - 1]) + border];
            }
        }
    }
    return dp[n][target + border];
}
```



01模型：

### 采药

#### 题目描述

[AcWing432. 采药](https://www.acwing.com/problem/content/description/425/)

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。

为此，他想拜附近最有威望的医师为师。

医师为了判断他的资质，给他出了一个难题。

医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

**输入格式**

输入文件的第一行有两个整数 $T$ 和 $M$，用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。

**输出格式**

输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

**数据范围**

$1≤T≤1000,$
$1≤M≤100$

**输入样例：**

```
70 3
71 100
69 1
1 2
```

**输出样例：**

```
3
```



#### 题解

01背包的裸题，时间 t 为背包容量，m 为物品数

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int t = read.nextInt();
        int m = read.nextInt();
        int[] time = new int[m + 1];
        int[] value = new int[m + 1];
        
        for (int i = 1; i <= m; i++) {
            time[i] = read.nextInt();
            value[i] = read.nextInt();
        }
        
        int[][] dp = new int[m + 1][t + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j <= t; j++) {
                dp[i][j] = dp[i - 1][j];
                if (time[i] <= j) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - time[i]] + value[i]);
                }
            }
        }
        
        System.out.println(dp[m][t]);
    }
}
```



### 装箱问题

#### 题目描述

[AcWing1024. 装箱问题](https://www.acwing.com/problem/content/description/1026/)

有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积（正整数）。

要求 $n$ 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

**输入格式**

第一行是一个整数 $V$，表示箱子容量。

第二行是一个整数 $n$，表示物品数。

接下来 $n$ 行，每行一个正整数（不超过$10000$），分别表示这 $n$ 个物品的各自体积。

**输出格式**

一个整数，表示箱子剩余空间。

**数据范围**

$0<V≤20000,$
$0<n≤30$

**输入样例：**

```
24
6
8
3
12
7
9
7
```

**输出样例：**

```
0
```



#### 题解

dfs暴搜超空间

```java
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int v = read.nextInt();
        int n = read.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = read.nextInt();
        }
        dfs(nums, 0, v);
        System.out.println(res);
    }

    static int res = Integer.MAX_VALUE;

    private static void dfs(int[] nums, int index, int v) {
        if (index == nums.length) {
            res = Math.min(res, v);
            return;
        }
        // 选与不选
        dfs(nums, index + 1, v);
        if (nums[index] <= v) {
            dfs(nums, index + 1, v - nums[index]);
        }
    }
}
```



**01背包**

我们将体积也看成价值，就等于求不超过容量的情况下使得所有的物品体积最大，也就是剩余背包容量最小

最后结果输出总容量 - 最大体积（价值）即可

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int v = read.nextInt();
        int n = read.nextInt();
        int[] nums = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            nums[i] = read.nextInt();
        }

        int[][] dp = new int[n + 1][v + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= v; j++) {
                dp[i][j] = dp[i - 1][j];
                if (nums[i] <= j) {
                    // 将体积也看成价值
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - nums[i]] + nums[i]);
                }
            }
        }

        System.out.println(v - dp[n][v]);
    }
}
```



### 双核处理问题

#### 题目描述

网易笔试

一种双核 $CPU$ 的两个核能够同时的处理任务，现在有 $n$ 个已知数据量的任务需要交给 $CPU$ 处理，假设已知 $CPU$ 的每个核 $1$ 秒可以处理 $1KB$ ，每个核同时只能处理一项任务。$n$ 个任务可以按照任意顺序放入 $CPU$ 进行处理，现在需要设计一个方案让 $CPU$ 处理完这批任务所需的时间最少，求这个最小的时间。

**输入描述:**

输入包括两行： 第一行为整数 $n$ $(1 ≤ n ≤ 50)$ 第二行为 $n$ 个整数 $length[i]$ $(1024 ≤ length[i] ≤ 4194304)$ ，表示每个任务的长度为 $length[i] KB$ ，每个数均为 $1024$ 的倍数。

**输出描述:**

```
输出一个整数，表示最少需要处理的时间
```

**输入例子1:**

```
5
3072 3072 7168 3072 1024
```

**输出例子1:**

```
9216
```



#### 题解

**01背包模型**

两个单核处理的时间越接近，（最好情况下，两个单核处理的时间相同）双核处理的总时间就越短最短

即可转化为0-1背包问题：若完成任务总共花费的时间应该为 $t$ ,不过由于是双核，要以最短时间完成任务，应该使得两核花费的时间最接近，也就是最接近 $t/2$ ,最好情况下就是两核花费时间都为 $t/2$ 了。设背包容量是 $sum/2$ . 每个物体的体积是数的大小，然后**尽可能的装满背包**。所以背包容量和价值都是任务长度。

问题实质是动态规划问题，把数组分成两部分，使得两部分的和相差最小。

**状态定义：**

$F(i, j)：$ 考虑选取 $1~i$ 个任务，使得任务总长度不超过 $j$ 的情况下，所选取的任务长度最大

**状态转移：**

$F(i, j) = Max(F(i - 1, j), F(i - 1, j - length[i])) $

```java
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] length = new int[n + 1];
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            length[i] = read.nextInt();
            sum += (length[i]);
        }

        int[][] dp = new int[n + 1][sum / 2 + 1];

        // 背包容量和价值都是任务长度
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum / 2; j++) {
                dp[i][j] = dp[i - 1][j];
                if (length[i] <= j) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - length[i]] + length[i]);
                }
            }
        }

        // dp[n][sum / 2] 的背包容量是两个背包中体积较小的那一个，因为是整除
        System.out.println((sum - dp[n][sum / 2]) / 1);
    }
}
```

### 拆分集合为相等的子集合
#### 题目描述
https://www.luogu.com.cn/problem/P1466

对于从 $1\sim n$ 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 $n=3$，对于 $\{1,2,3\}$ 能划分成两个子集合，每个子集合的所有数字和是相等的：

$\{3\}$ 和 $\{1,2\}$ 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）  
如果 $n=7$，有四种方法能划分集合 $\{1,2,3,4,5,6,7 \}$，每一种分法的子集合各数字和是相等的:

$\{1,6,7\}$ 和 $\{2,3,4,5\}$  
$\{2,5,7\}$ 和 $\{1,3,4,6\}$  
$\{3,4,7\}$ 和 $\{1,2,5,6\}$  
$\{1,2,4,7\}$ 和 $\{3,5,6\}$  

给出 $n$，你的程序应该输出划分方案总数。

**输入格式**

输入文件只有一行，且只有一个整数 $n$

**输出格式**

输出划分方案总数。

**样例 #1**

**样例输入 #1**

```
7
```

**样例输出 #1**

```
4
```

**提示**

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 39$。

翻译来自NOCOW

USACO 2.2

#### 题解

**0-1背包模型**

对于每个数 $i$ 来说，$i$ 要么存在于集合1，要么存在于集合2，所以我们表示其中一个集合的状态即可，只要确定其中一个集合的数，那么另一个集合的数就确定了，最终答案为方案数除以 $2$，因为是两个集合的组合问题。

**状态定义：**

$F(i, j)：$ 考虑选取 $1~i$ 个数字，子集1和为 $j$ 的所有方案数

**状态转移：**

$F(i, j) = F(i - 1, j) + F(i - 1, j - i) $

```java
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            nums[i] = i;
        }

        int sum = n * (n + 1) / 4; // 当且仅当两子集和相等时，和为最大值
        if ((sum & 1) == 1) {
            // 数列和为奇数时，无解，因为无法分成两个和相等的子集
            System.out.println(-1);
            return;
        }
        int[][] dp = new int[n + 1][sum + 1];
        //  考虑前i个数，它们的和恰好是j的方案数
        // dp[i][j]=dp[i−1][j](不选) + dp[i−1][j−i](选i)
        // 每个数只有2种情况，放在第一个集合和不放在第一个集合。只要确定了一个集合，另一个集合必然确定，所以结果要除以2 01背包模型
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (i <= j) {
                    dp[i][j] += dp[i - 1][j - i];
                }
            }
        }

        System.out.println(dp[n][sum] / 2);
    }
}
```


### 宠物小精灵之收服

#### 题目描述

[AcWing1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/description/1024/)

宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。

一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。

小智也想收服其中的一些小精灵。

然而，野生的小精灵并不那么容易被收服。

对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。

当皮卡丘的体力小于等于 $0$ 时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于 $0$ 的野生小精灵也不会被小智收服。

当小智的精灵球用完时，狩猎也宣告结束。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？

**输入格式**

输入数据的第一行包含三个整数：$N$，$M$，$K$，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。

之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。

**输出格式**

输出为一行，包含两个整数：$C$，$R$，分别表示最多收服 $C$ 个小精灵，以及收服 $C$ 个小精灵时皮卡丘的剩余体力值最多为 $R$。

**数据范围**

$0<N≤1000,$
$0<M≤500,$
$0<K≤100$

**输入样例1：**

```
10 100 5
7 10
2 40
2 50
1 20
4 20
```

**输出样例1：**

```
3 30
```

**输入样例2：**

```
10 100 5
8 110
12 10
20 10
5 200
1 110
```

**输出样例2：**

```
0 100
```



#### 题解

二维费用背包模型：

代价1：精灵球的数量

代价2：皮卡丘的体力

价值：小精灵的数量

第一问就是二维费用问题

第二问就是根据最优解的值，从多组最优解中找出所需体力最小的k



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int N = read.nextInt();
        int M = read.nextInt();
        int K = read.nextInt();
        int[] v1 = new int[K + 1];
        int[] v2 = new int[K + 1];
        for (int i = 1; i <= K; i++) {
            v1[i] = read.nextInt();
            v2[i] = read.nextInt();
        }

        int[][][] dp = new int[K + 1][N + 1][M];

        for (int i = 1; i <= K; i++) {
            // 精灵球数量
            for (int j = 0; j <= N; j++) {
                // 皮卡丘体力 (题意皮卡丘的体力不能等于0，所以严格小于)
                for (int k = 0; k < M; k++) {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (v1[i] <= j && v2[i] <= k) {
                        dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - v1[i]][k - v2[i]] + 1);
                    }
                }
            }
        }
        int C = dp[K][N][M - 1];
        int R = 0;

        // 从小到大枚举体力 寻找能捕捉C只宠物所需的最小体力值k
        for (int k = 0; k < M; k++) {
            if (dp[K][N][k] == C) {
                R = M - k; // 剩余体力
                break;
            }
        }
        System.out.println(C + " " + R);
    }
}
```



### 潜水员

#### 题目描述

潜水员为了潜水要使用特殊的装备。

他有一个带 $2$ 种气体的气缸：一个为氧气，一个为氮气。

让潜水员下潜的深度需要各种数量的氧和氮。

潜水员有一定数量的气缸。

每个气缸都有重量和气体容量。

潜水员为了完成他的工作需要特定数量的氧和氮。

他完成工作所需气缸的总重的最低限度的是多少？

例如：潜水员有 $5$ 个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：

```
3 36 120

10 25 129

5 50 250

1 45 130

4 20 119
```

如果潜水员需要 $5$ 升的氧和 $60$ 升的氮则总重最小为 $249$（$1$，$2$ 或者 $4$，$5$ 号气缸）。

你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

**输入格式**

第一行有 $2$ 个整数 $m$，$n$。它们表示氧，氮各自需要的量。

第二行为整数 $k$ 表示气缸的个数。

此后的 $k$ 行，每行包括 $ai$，$bi$，$ci$，$3$ 整数。这些各自是：第 $i$ 个气缸里的氧和氮的容量及气缸重量。

**输出格式**

仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

**数据范围**

$1≤m≤21,$
$1≤n≤79,$
$1≤k≤1000,$
$1≤ai≤21,$
$1≤bi≤79,$
$1≤ci≤800$

**输入样例：**

```
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
```

**输出样例：**

```
249
```



#### 题解



## 线性 DP



### 数字三角形

#### 题目描述

[AcWing898. 数字三角形](https://www.acwing.com/problem/content/description/900/)



#### 题解

![image-20220329162444629](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329162444629.png)

**自底向上**

```java
import java.util.Scanner;

public class Test {
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] triangle = new int[2 * n][2 * n];
        int[][] dp = new int[2 * n][2 * n];
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                triangle[i][j] = sc.nextInt();
            }
        }
        
        // 自底向上
        for (int i = n; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
            }
        }
        
        System.out.println(dp[1][1]);
    }
}
```



**空间优化**

```java
import java.util.Scanner;

public class Test {
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] triangle = new int[2 * n][2 * n];
        int[] dp = new int[2 * n];
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                triangle[i][j] = sc.nextInt();
            }
        }
        
        // 自底向上
        for (int i = n; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                dp[j] = Math.max(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        
        System.out.println(dp[1]);
    }
}
```



### 摘花生

#### 题目描述

[AcWing1015. 摘花生](https://www.acwing.com/problem/content/description/1017/)

$Hello Kitty$ 想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

$Hello Kitty$ 只能向东或向南走，不能向西或向北走。

问 $Hello Kitty$ 最多能够摘到多少颗花生。

![1.gif](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/19_a8509f26d5-1.gif)

**输入格式**

第一行是一个整数 $T$ ，代表一共有多少组数据。

接下来是 $T$ 组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数 $R$ 和列数 $C$。

每组数据的接下来 $R$ 行数据，从北向南依次描述每行花生苗的情况。每行数据有 $C$ 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 $M$。

**输出格式**

对每组输入数据，输出一行，内容为 $Hello Kitty$ 能摘到得最多的花生颗数。

**数据范围**

$ 1≤T≤100 $,
$ 1≤R,C≤100$,
$ 0≤M≤1000$

**输入样例：**

```
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

**输出样例：**

```
8
16
```



#### 题解

题目对应LeetCode 不同路径

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int t = read.nextInt();
        while (t-- > 0) {
            int row = read.nextInt();
            int col = read.nextInt();
            int[][] nums = new int[row + 1][col + 1];
            for (int i = 1; i <= row; i++) {
                for (int j = 1; j <= col; j++) {
                    nums[i][j] = read.nextInt();
                }
            }

            int[][] dp = new int[row + 1][col + 1];
            // 状态转移过程说白了就是最后一步是怎么来的
            for (int i = 1; i <= row; i++) {
                for (int j = 1; j <= col; j++) {
                    if (i == 1 && j == 1) {
                        dp[1][1] = nums[i][j];
                    } else if (i == 1) {
                        dp[1][j] = dp[1][j - 1] + nums[1][j]; 
                    } else if (j == 1) {
                        dp[i][1] = dp[i - 1][1] + nums[i][1];
                    } else {
                        // 因为自己写的输入 数据索引都是从1开始，所以上面的case其实都可以省略，不用特殊判断
                        dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]) + nums[i][j];
                    }
                }
            }
            
            System.out.println(dp[row][col]);
        }
    }
}
```



**空间优化**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int t = read.nextInt();
        while (t-- > 0) {
            int row = read.nextInt();
            int col = read.nextInt();
            int[][] nums = new int[row + 1][col + 1];
            for (int i = 1; i <= row; i++) {
                for (int j = 1; j <= col; j++) {
                    nums[i][j] = read.nextInt();
                }
            }
            
            // 空间优化 只记录一列的数据
            int[] dp = new int[col + 1];
            // 状态转移过程说白了就是最后一步是怎么来的
            for (int i = 1; i <= row; i++) {
                for (int j = 1; j <= col; j++) {
                    // 因为自己写的输入 数据索引都是从1开始，所以上面的case其实都可以省略，不用特殊判断
                    dp[j] = Math.max(dp[j - 1], dp[j]) + nums[i][j];
                }
            }
            
            System.out.println(dp[col]);
        }
    }
}
```





### 最低通行费

#### 题目描述

[AcWing1018. 最低通行费](https://www.acwing.com/problem/content/description/1020/)

一个商人穿过一个 $N×N$ 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 $1$ 个小方格，都要花费 $1$ 个单位时间。

商人必须在 $(2N−1)$ 个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

**输入格式**

第一行是一个整数，表示正方形的宽度 $N$。

后面 $N$ 行，每行 $N$ 个不大于 $100$ 的正整数，为网格上每个小方格的费用。

**输出格式**

输出一个整数，表示至少需要的费用。

**数据范围**

$1≤N≤100$

**输入样例：**

```
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

**输出样例：**

```
109
```

**样例解释**

样例中，最小值为 109=1+2+5+7+9+12+19+21+33109=1+2+5+7+9+12+19+21+33。



#### 题解

虽然商人可以从四个方向走，但是题目限定了商人必须在 $(2N−1)$ 个单位时间穿越出去，也就是限定了商人不能走回头路，也就是只能向下或向右走。所以最终这题和摘花生还是一样的，只不过这题取的是一个最小值。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] nums = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                nums[i][j] = read.nextInt();
            }
        }

        int[][] dp = new int[n + 1][n + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                // 因为取的是最小值, 所以要对边界进行一下特殊处理
                if (i == 1 && j == 1) {
                    dp[1][1] = nums[1][1];
                } else if (i == 1) {
                    dp[1][j] = dp[1][j], dp[1][j - 1] + nums[1][j];
                } else if (j == 1) {
                    dp[i][1] = dp[i][1], dp[i - 1][1] + nums[i][1];
                } else {
                    dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + nums[i][j];
                }
            }
        }

        System.out.println(dp[n][n]);
    }
}
```



### 方格取数

#### 题目描述

[AcWing1027. 方格取数](https://www.acwing.com/problem/content/description/1029/)

设有 $N×N$ 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字 $0$。如下图所示：

![2.gif](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/19_764ece6ed5-2.gif)

某人从图中的左上角 $A$ 出发，可以向下行走，也可以向右行走，直到到达右下角的 $B$ 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$ ）。

此人从 $A$ 点到 $B$ 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**输入格式**

第一行为一个整数 $N$ ，表示 $N×N$ 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 $1$ 开始。

一行“0 0 0”表示结束。

**输出格式**

输出一个整数，表示两条路径上取得的最大的和。

**数据范围**

$N≤10$

**输入样例：**

```
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

**输出样例：**

```
67
```



#### 题解

**在前面题的基础上加上双路径走两次**

因为两条路径并不是独立的，是要求两路径之和达到一个全局最优，而如果用两次 dp 分别求出两个局部最优的路径明显是不对的。

所以采用两条路径同时走的思路

**状态定义：**

`f(i1, j1, i2, j2)`：表示所有从`(1, 1), (1, 1)` 走到`(i1, j1), (i2, j2)`的路径和最大值

**状态转移：**

最后一步的前一个状态：

每一条路有向下或向右两种选择 一共2 * 2种可能

`f(i1 - 1, j1, i2 - 1, j2)`：（下下）
`f(i1 - 1, j1, i2, j2 - 1)`：（下右）
`f(i1, j1 - 1, i2 - 1, j2)`：（右下）
`f(i1, j1 - 1, i2, j2 - 1)`：（右右）



关键处理的问题：**同一个格子不能被重复选择**

只有当两条路径走过的步数相同时，后一步才可能在同样的坐标相遇

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] nums = new int[n + 1][n + 1];
        while (read.hasNext()) {
            int i = read.nextInt();
            int j = read.nextInt();
            int val = read.nextInt();
            if (i == 0 && j == 0 && val == 0) {
                break;
            }
            nums[i][j] = val;
        }

        int[][][][] dp = new int[n + 1][n + 1][n + 1][n + 1];

        for (int i1 = 1; i1 <= n; i1++) {
            for (int j1 = 1; j1 <= n; j1++) {
                for (int i2 = 1; i2 <= n; i2++) {
                    for (int j2 = 1; j2 <= n; j2++) {
                        // 同时走相同的步数
                        if (i1 + j1 == i2 + j2) {
                            int val = nums[i1][j1];
                            // 因为步数相同 如果横坐标相等则二维坐标相等 如果当前坐标不位于同一个格子则两个格子都要相加
                            if (i1 != i2) val += nums[i2][j2];
                            // 最后一步 每一条路有向下或向右两种选择 一共2 * 2种可能
                            dp[i1][j1][i2][j2] = Math.max(dp[i1][j1][i2][j2], dp[i1 - 1][j1][i2 - 1][j2] + val); // 下下
                            dp[i1][j1][i2][j2] = Math.max(dp[i1][j1][i2][j2], dp[i1 - 1][j1][i2][j2 - 1] + val); // 下右
                            dp[i1][j1][i2][j2] = Math.max(dp[i1][j1][i2][j2], dp[i1][j1 - 1][i2 - 1][j2] + val); // 右下
                            dp[i1][j1][i2][j2] = Math.max(dp[i1][j1][i2][j2], dp[i1][j1 - 1][i2][j2 - 1] + val); // 右右
                        }
                    }
                }
            }
        }
        System.out.println(dp[n][n][n][n]);
    }
}
```



**状态优化**

因为我们要控制步长一致，可以使用三维来表示状态：

**状态定义：**

`f(k, i1, i2)`：表示所有从`(1, 1), (1, 1)` 走到`(i1, k - i1), (i2, k - i2)`的路径和最大值

$k$ 表示两条路径当前所处位置的横纵坐标之和，也就是每一条的路径 + 1

$ k = i1 + j1 = i2 + j2$



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] nums = new int[n + 1][n + 1];
        while (read.hasNext()) {
            int i = read.nextInt();
            int j = read.nextInt();
            int val = read.nextInt();
            if (i == 0 && j == 0 && val == 0) {
                break;
            }
            nums[i][j] = val;
        }

        int[][][] dp = new int[2 * n + 1][n + 1][n + 1];
        for (int k = 2; k <= 2 * n; k++) {
            for (int i1 = 1; i1 <= n; i1++) {
                for (int i2 = 1; i2 <= n; i2++) {
                    int j1 = k - i1;
                    int j2 = k - i2;
                    // 因为通过枚举路径距离和横坐标，纵坐标有可能非法
                    if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n) {
                        int val = nums[i1][j1];
                        // 因为步数相同 如果横坐标相等则二维坐标相等 如果当前坐标不位于同一个格子则两个格子都要相加
                        if (i1 != i2) val += nums[i2][j2];

                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1 - 1][i2 - 1] + val); // 下下
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1 - 1][i2] + val); // 下右
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1][i2 - 1] + val); // 右下
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1][i2] + val); // 右右
                    }
                }
            }
        }

        System.out.println(dp[n + n][n][n]);
    }
}
```



### 传纸条

#### 题目描述

[AcWing275. 传纸条](https://www.acwing.com/problem/content/description/277/)

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。

**输入格式**

第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。

接下来的 $m$ 行是一个 $m \times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。

**输出格式**

输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

**数据范围**

$1≤n,m≤50$

**样例输入**

```
3 3
0 3 9
2 8 5
5 7 0
```

**样例输出**

```
34
```



#### 题解

这题和方格取数差不多，这类问题应该都只能同时计算状态。而不能分先后。两题只有一点区别，方格取数中可以走同一个方格但是数字只能取一遍，而这题中不能走同一个方格。但是用方格取数的代码也是可以通过的。

下面给的代码只是改了一点判断的语义，强制使其不能走同一个格子，但是功能是和方格取数的代码一样的。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int m = read.nextInt();
        int n = read.nextInt();
        int[][] nums = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                nums[i][j] = read.nextInt();
            }
        }

        int[][][] dp = new int[m + n + 1][m + 1][m + 1];
        for (int k = 2; k <= (m + n); k++) {
            for (int i1 = 1; i1 <= m; i1++) {
                for (int i2 = 1; i2 <= m; i2++) {
                    int j1 = k - i1;
                    int j2 = k - i2;
                    if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n) {
                        // 确保两条路径不会走同一个格子 除了起点和终点
                        if (i1 == i2 && k != 2 && k != m + n) {
                            // 这个状态设置为-INF 后续必然不会被用到
                            dp[k][i1][i2] = Integer.MIN_VALUE;
                            continue;
                        }
                        int val = nums[i1][j1] + nums[i2][j2];
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1 - 1][i2 - 1] + val);
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1 - 1][i2] + val);
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1][i2 - 1] + val);
                        dp[k][i1][i2] = Math.max(dp[k][i1][i2], dp[k - 1][i1][i2] + val);
                    }
                }
            }
        }

        System.out.println(dp[m + n][m][m]);
    }
}
```



### 子序列模型





### 最短编辑距离

#### 题目描述

[AcWing902. 最短编辑距离](https://www.acwing.com/problem/content/description/902/)

给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

1. 删除–将字符串 A 中的某个字符删除。
2. 插入–在字符串 A 的某个位置插入某个字符。
3. 替换–将字符串 A 中的某个字符替换为另一个字符。

现在请你求出，将 A 变为 B 至少需要进行多少次操作。

**输入格式**

第一行包含整数 n，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大小写字母。

**输出格式**

输出一个整数，表示最少操作次数。

**数据范围**

1≤n,m≤1000

**输入样例：**

```
10 
AGTCTGACGC
11 
AGTAAGTAGGC
```

**输出样例：**

```
4
```



#### 题解

**状态定义：**

`dp[i][j]`：长度为`[0,i]`A的子串变为长度为`[0,j]`B的子串的最少操作数

**状态转移：**

A 转化为 B的前一步只有三种方式，就是A 增、删、改一个字符(如果不相等则改)

`dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1], dp[i - 1][j - 1] + 1)`



![image-20220331234056331](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220331234056331.png)

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int m = read.nextInt();
        String text1 = read.next();
        int n = read.nextInt();
        String text2 = read.next();
        int[][] dp = new int[m + 1][n + 1];

        // 初始化
        // text2长度为0 text2只能做i步增加
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        // text1长度为0 text1只能做j步增加
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // A串比B串长一个字符，A串比B串短一个字符
                dp[i][j] = Math.min(1 + dp[i][j - 1], 1 + dp[i - 1][j]);
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 如果最后一个字符相等则不用操作
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i][j], 1 + dp[i - 1][j - 1]);
                }
            }
        }

        System.out.println(dp[m][n]);
    }
}
```



### 编辑距离

#### 题目描述

[AcWing899. 编辑距离](https://www.acwing.com/problem/content/description/899/)

给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。

对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。

每个对字符串进行的单个字符的插入、删除或替换算作一次操作。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含一个字符串，表示给定的字符串。

再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。

字符串中只包含小写字母，且长度均不超过 10。

**输出格式**

输出共 m 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。

**数据范围**

1≤n,m≤1000

**输入样例：**

```
3 2
abc
acd
bcd
ab 1
acbd 2
```

**输出样例：**

```
1
3
```



#### 题解

是最短编辑距离的一个应用，**对于每次询问，只需要枚举一下所有字符串的最短编辑距离是否小于给定的上限操作数**即可



```java
import java.util.Scanner;

/**
 * 编辑距离
 *
 * @author novo
 * @date 2022/4/2-15:34
 */
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int m = read.nextInt();
        String[] strings = new String[n];
        for (int i = 0; i < n; i++) {
            strings[i] = read.next();
        }

        // 处理m次询问
        while (m-- > 0) {
            String str = read.next();
            int limit = read.nextInt();
            int res = 0;
            for (int i = 0; i < n; i++) {
                if (minEdit(strings[i], str) <= limit) {
                    res++;
                }
            }
            System.out.println(res);
        }
    }

    // 最短编辑距离
    private static int minEdit(String text1, String text2) {
        int[][] dp = new int[11][11];
        int m = text1.length();
        int n = text2.length();
        // 处理边界初始化
        // text2长度为0 text2只能做i步增加
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        // text1长度为0 text1只能做j步增加
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1);
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 区间 DP

区间 DP 的一般都要先按区间长度枚举，按照区间长度从小到大来枚举，因为要保证在算`f(i,j)`时，它所需要用到的状态在此前已经被计算过





### 石子合并

#### 题目描述

[AcWing282. 石子合并](https://www.acwing.com/problem/content/description/284/)

设有 N 堆石子排成一排，其编号为 1，2，3，…，N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 4 堆石子分别为 1 3 5 2， 我们可以先合并 1、2 堆，代价为 4，得到 4 5 2， 又合并 1，2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；

如果第二步是先合并 2，3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。



#### 题解



**状态定义：**

`dp[i][j]`：考虑区间`[i, j]`合并成一堆石子的**所有方式**的最小代价

**状态转移：**

`dp[i][j] = min(dp[i][k] + dp[k + 1][j] + (preSum[j] - preSum[i - 1]))，枚举所有分界点k`

即最后一次合并必定由两堆石子合并而来，所以可以枚举合并的分界线



![image-20220331170500619](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220331170500619.png)

需要用到**前缀和**来计算合并石子的代价

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        int[] preSum = new int[n + 1];
        int[][] dp = new int[n + 1][n + 1];
        
        for (int i = 1; i <= n; i++) {
            nums[i] = read.nextInt();
            preSum[i] = preSum[i - 1] + nums[i];
        }
        // 要按区间长度枚举  可以从2开始 因为合并一堆石子代价为0 因为dp初始值就为0
        for (int len = 2; len <= n; len++) {
            // 枚举起点
            for (int i = 1; i + len - 1 <= n; i++) {
                int j = i + len - 1;
                // 注意这里 除了一堆石子的区间初始值为0，其他区间（len>=2）的初始值都要设一个最大值，不然都是0
                dp[i][j] = Integer.MAX_VALUE;
                // 枚举分界点
                for (int k = i; k < j; k++) { // k严格小于j 保证存在两堆
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + (preSum[j] - preSum[i - 1]));
                }
            }
        }
        
        System.out.println(dp[1][n]);
    }
}
```





### 矩阵连乘最少相乘次数

#### 题目描述

给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的相乘次数最少 。



#### 题解

区间 dp

**状态定义：**

`dp[i][j]`：考虑将区间`[i, j]`的矩阵相乘的**所有方式**的最小代价

**状态转移：**

`dp[i][j] = min(dp[i][k] + dp[k + 1][j] + matrix[l][0] * matrix[k][1] * matrix[r][1])，枚举所有分界点k`

即最后一次乘法必定由两个矩阵相乘而来

```java
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt(); // 矩阵数量
    int[][] matrix = new int[n + 1][2];
    int[][] dp = new int[n + 1][n + 1];
    for (int i = 1; i <= n; i++) {
        matrix[i][0] = read.nextInt(); // 行数
        matrix[i][1] = read.nextInt(); // 列数
    }

    // 枚举区间长度
    for (int len = 2; len <= n; len++) {
        // 枚举左右边界
        for (int i = 1; i + len - 1 <= n; i++) {
            int l = i;
            int r = i + len - 1;
            dp[l][r] = Integer.MAX_VALUE;
            // 枚举分界点
            for (int k = l; k < r; k++) {
                dp[l][r] = Math.min(dp[l][r], dp[l][k] + dp[k + 1][r] + matrix[l][0] * matrix[k][1] * matrix[r][1]);
            }
        }
    }

    System.out.println(dp[1][n]);
}
```



### 最长回文子串

#### 题目描述

[LeetCode5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 **提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成



#### 题解

**状态定义：**

`F(i, j)`：子串 $s[i...j]$ 是否为回文串

**状态转移：**

`F(i, j) = F(i + 1, j - 1) && s[i] == s[j]`



```java
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    boolean[][] dp = new boolean[s.length()][s.length()];

    // 长度为1都为回文串
    for (int i = 0; i < s.length(); i++) {
        dp[i][i] = true;
    }

    /*for (int i = 0; i < s.length(); i++) {
        Arrays.fill(dp[i], true);
    }*/

    int maxLen = 1;
    int begin = 0;
    // 枚举长度
    for (int len = 2; len <= s.length(); len++) {
        // 枚举左右边界
        for (int i = 0; i + len - 1 < s.length(); i++) {
            int l = i;
            int r = i + len - 1;
            // 如果两端不相等
            if (s.charAt(l) != s.charAt(r)) {
                dp[l][r] = false;
            } else {
                // 如果两端相等且长度小于等于3必为回文串， 也可以将dp数组初始值都设置为true，就不用这个特殊判断
                if (r - l + 1 <= 3) {
                    dp[l][r] = true;
                } else {
                    // 如果两端相等 等于上一个状态 因为可能出现某段是回文串但两端不是，整体就不是
                    dp[l][r] = dp[l + 1][r - 1];
                }
            }

            if (dp[l][r] && r - l + 1 > maxLen) {
                maxLen = r - l + 1;
                begin = l;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}
```



### 最长回文子序列

#### 题目描述

[LeetCode516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。



**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

**示例 2：**

```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

 **提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成



#### 题解

**状态定义：**

`F(i, j)`：子串 $s[i...j]$ 内最长回文子序列的长度

**状态转移：**

- 情况 1：当 `s[left] == s[right]` ，字符区间 `s[i..j]` 里最长回文子序列的长度，看去掉头和尾以后的区间的最长子序列的长度。

![image.png](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1628702345-OtQlpQ-image.png)

- 情况 2：当 s[left] != s[right] ，字符区间 s[i..j] 里最长回文子序列的长度，看「去掉头以后的区间的最长子序列的长度」和「去掉尾以后的区间的最长子序列的长度」，二者取最大值。

![image.png](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1628702386-FUJZsu-image.png)

**结果：**

$ dp[0][s.length() - 1]$

下图中用 l 表示 left，用 r 表示 right，蓝色部分需要先计算出来，才可以保证红色部分计算出的结果是正确的（这一点由状态转移方程决定）。

![image.png](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1628704476-CICnWY-image.png)

填表顺序，枚举区间长度，从对角线往右上角推进

![image-20220518235850195](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220518235850195.png)

```java
public int longestPalindromeSubseq(String s) {
    int[][] dp = new int[s.length()][s.length()];

    // 长度为1的子序列最长回文长度为1
    for (int i = 0; i < s.length(); i++) {
        dp[i][i] = 1;
    }

    // 枚举区间长度
    for (int len = 2; len <= s.length(); len ++) {
        // 枚举左右边界
        for (int i = 0; i + len - 1 < s.length(); i++) {
            int l = i;
            int r = i + len - 1;
            if (s.charAt(l) == s.charAt(r)) {
                // 如果两端相等
                dp[l][r] = dp[l + 1][r - 1] + 2;
            } else {
                // 两端不相等
                dp[l][r] = Math.max(dp[l + 1][r], dp[l][r - 1]);
            }
        }
    }
    return dp[0][s.length() - 1];
}
```



## 计数 DP



### 整数划分

#### 题目描述

[AcWing900. 整数划分](https://www.acwing.com/problem/content/description/900/)

一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数n的一种划分。

现在给定一个正整数n，请你求出n共有多少种不同的划分方法。

**输入格式**
共一行，包含一个整数n。

**输出格式**
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对10^9+7取模。

**数据范围**
1≤n≤1000

**输入样例:**

```
5
```

**输出样例:**

```
7
```

#### 题解

**完全背包解法**

 O(n3)

可以看成完全背包

背包容量为n，物品的重量为1，2，3...n

每种物品可以选无数次

**状态定义：**

`dp[i][j]`：考虑从`[0, i]`的数字中选，恰好凑出`j`的方案数量

**状态转移：**

`f(i,j) = f(i-1,j) + f(i-1,j-i) + f(i-1, j-2i) + f(i-1, j-3i), ...+ f(i-1, j-k*i) `

对于每一个物品，在背包容量充足的情况下，可以分别选 1，2，3...k 次，分类计数使用加法

```java
import java.util.*;
public class Main {
	static final int M = (int) (1e9 + 7);

    // 完全背包朴素解
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] dp = new int[n + 1][n + 1];
        // 凑出0只有一种方案
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k * i <= j; k++) {
                    dp[i][j] = dp[i][j] + dp[i - 1][j - k * i];
                    dp[i][j] = dp[i][j] % M;
                }
            }
        }

        System.out.println(dp[n][n]);
    }
}
```



**空间优化**

二维：

```java
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt();
    int[][] dp = new int[n + 1][n + 1];
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = dp[i - 1][j];
            if (i <= j) {
                dp[i][j] = dp[i][j] + dp[i][j - i];
            }
            dp[i][j] = dp[i][j] % M;
        }
    }
    System.out.println(dp[n][n]);
}
```

一维：

```java
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            dp[j] = dp[j] + dp[j - i];
            dp[j] = dp[j] % M;
        }
    }
    System.out.println(dp[n]);
}
```



**另外一种转移方程**

**状态定义：**

`dp[i][j]`：一共选`j`个数，它们总和恰好凑出`i`的方案数量

**状态转移：**

![image-20220402203238006](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220402203238006.png)

- 使用j个数能够凑成`i`，这j个数中最小值为1的方案中，**去掉一个1**，则状态变为：`f(i,j)=f(i−1,j−1)`
- 使用j个数能够凑成`i`，这j个数中最小值不为1的方案中，**将这j个数都减去一个1**，则状态变为：`f(i,j)=f(i−j,j)`，此时状态表示为`j`个数能够凑成`i-j`的所有方案的数量。（因为最小值都严格大于1，都减去一个1后仍为`j`个数）

`dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j] `

最终答案就枚举一次第二维个数就行

```
res = dp[n][0] + dp[n][1] + dp[n][2] + ... + dp[n][n] 
```



```java
// 另一种转移方程
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt();
    int[][] dp = new int[n + 1][n + 1];
    int res = 0;
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        // 凑出n 个数最多的方案最多为 n个1 所以 j <= i
        for (int j = 1; j <= i; j++) {
            dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];
        }
    }

    for (int j = 0; j <= n; j++) {
        res += dp[n][j];
    }

    System.out.println(res);
}
```



## 数位 DP

分类讨论



### 计数问题

#### 题目描述

[AcWing338. 计数问题](https://www.acwing.com/problem/content/description/340/)

给定两个整数 $a$ 和 $b$，求 $a$ 和 $b$ 之间的所有数字中 $0∼9$ 的出现次数。

例如，$a=1024，b=1032$，则 $a$ 和 $b$ 之间共有 $9$ 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 1010 次，`1` 出现 1010 次，`2` 出现 77 次，`3` 出现 33 次等等…

**输入格式**

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 $a$ 和 $b$。

当读入一行为 `0 0` 时，表示输入终止，且该行不作处理。

**输出格式**

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

**数据范围**

$0<a,b<1000000000$

**输入样例：**

```
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

**输出样例：**

```
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```



#### 题解

**前缀和思想**

求区间 $[a, b]$ 内 $x$ 出现的次数，等价于区间 $[1, b]$ 上 $x$ 出现的次数 $-$ $[1, a - 1]$ 上 $x$ 出现的次数。

那么我们只需要实现一个可以求出$[1, n]$ 上 $x$ 出现的次数的方法即可。



**核心函数：**

用数学思维降低时间复杂度

n 用字符串形式来表示$n = abcdefg$ ($abcdefg$ 代表`n`每一位上的数字)，求出`x`在`[1, n]`这个区间的所有正整数每一位上出现的次数

**分类讨论：**

$???x\$\$\$$ 代表`[1, n]`这个区间上的某一个数字

$1 <= ???x\$\$\$ <= abcdefg$



1) 当 $??? \in [000, abc - 1]$ 时，那么 $\$\$\$$ 就可以取任意数$[000, 999]$，因为此时高位 $??? < abc$ ，所以无论低位取何数，$???x\$\$\$$ 都在`[1, n]`内。
2) 当 $??? = abc$ 时，分为三种情况：

- $x > d$ 时，此时高位 $abcx > abcd$，所以无论低位 $\$\$\$$ 取何数，这个数都不在区间内。

- $x = d$ 时，此时前面的高位都相等，只要 $\$\$\$ \in [000, efg]$，这个数就在`[1, n]`内。

- $x < d$ 时，此时高位 $abcx < abcd$，所以低位可以取任意数。 

3) 当 $??? > abc$ 时，此时高位已经大于 n 了，所以这个数不在区间内。



综上所述，我们只需要累加所有区间内数据的情况，就可以求出$[1, n]$内 $x$ 出现的次数 

1) $??? \in [000, abc - 1]$，可取的合法个数就为$abc * 1000$（这里000~999就是1000种，就是x所在位置的10的次方）


2) $??? = abc$

- $x = d$，可取的合法个数 $efg + 1$ (000~efg)
- $x < d$，可取的合法个数 $1000$（这里000~999就是1000种，就是x所在位置的10的次方）



**特殊判断**

1、$??? \in [001, abc - 1]$ 这种情况要 $abc \geq 1$，所以在枚举非最高位时才有这种情况，因为x在最高位置，前面就没有 $abc$ 了

2、当 $ x = 0$ 时，由于不能含有前导零所以 $???$ 要从1开始，$??? \in [001, abc - 1]$ 。可取的合法个数就为 $abc * 1000 - 1$

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @author novo
 * @date 2022/4/3-20:43
 */
public class Main {
    
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        while (read.hasNext()) {
            int a = read.nextInt();
            int b = read.nextInt();
            if (a == 0 && b == 0) {
                break;
            }
            // 确保a 小于 b
            if (a > b) {
                int temp = a;
                a = b;
                b = temp;
            }
            // 前缀和思想 [a, b]上x出现的次数 = [1, b]上x出现的次数 - [1, a - 1]上x出现的次数
            for (int i = 0; i < 10; i++) {
                System.out.print(count(b, i) - count(a - 1, i) + " ");
            }
            System.out.println();
        }
    }

    // 统计1~n这个区间 x出现的次数
    private static int count(int n, int x) {
        if (n == 0) {
            return 0;
        }
        // 存储每一位
        List<Integer> list = new ArrayList<>();
        while (n != 0) {
            list.add(n % 10);
            n /= 10;
        }
        // 对 x == 0 做特判，如果 x == 0 i从次高位开始枚举
        int bit = (x == 0 ? 1 : 0);
        int bitSize = list.size();
        int res = 0;
        // 从高位开始枚举
        for (int i = bitSize - 1 - bit; i >= 0; i--) {
            // base 1 x不为最高位时才有这种情况
            if (i < bitSize - 1) {
                res += (getNum(list, bitSize - 1, i + 1)) * Math.pow(10, i);
                if (x == 0) {
                    // x == 0 时 可取个数为(getNum(list, bitSize - 1, i + 1)) - 1) * Math.pow(10, i)，所以要减回去
                    res -= Math.pow(10, i);
                }
            }

            // base 2.2 x == d
            if (x == list.get(i)) {
                res += getNum(list, i - 1, 0) + 1;
            } else if (x < list.get(i)) {
                // base 2.3 x < d
                res += Math.pow(10, i);
            }
        }
        return res;
    }
    
	// 获取一个数 在l~r位上的数字
    private static int getNum(List<Integer> list, int l, int r) {
        int res = 0;
        for (int i = l; i >= r; i--) {
            res = res * 10 + list.get(i);
        }
        return res;
    }
}
```



**时间复杂度**

数据 $0<a,b<1000000000$ ，所以枚举位时，至多枚举10次，一个数的数位为`lgN`，需要枚举0~9 10个数字出现的次数，也就是一组样例的时间为`O(10 * 2 * lgN)`=`O(lgN)`

再看看如果用暴力枚举来求$[1, n]$ 上 $x$ 出现的次数，时间复杂度为`O(N * lgN)`

> 不得不说，暴力枚举是真的简单，暴力枚举是区间上的数一个一个枚举，而用数位 DP 是一次性算出一个区间上 x 出现的次数

```java
// 统计1~n 内 x出现的次数
private static int forceCount(int n, int x) {
    int res = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = i; j != 0; j /= 10) {
            if (j % 10 == x) {
                res++;
            }
        }
    }
    return res;
}
```



## 状态压缩 DP

一般n不会特别大 n <= 20



### 蒙德里安的梦想

#### 题目描述

[AcWing291. 蒙德里安的梦想](https://www.acwing.com/problem/content/description/293/)

求把 $N×M$ 的棋盘分割成若干个 $1×2$ 的长方形，有多少种方案。

例如当 $N=2，M=4$ 时，共有 55 种方案。当 $N=2，M=3$ 时，共有 $3$ 种方案。

如下图所示：

![2411_1.jpg](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/19_4dd1644c20-2411_1.jpg)

**输入格式**

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 $N$ 和 $M$。

当输入用例 $N=0，M=0$ 时，表示输入终止，且该用例无需处理。

**输出格式**

每个测试用例输出一个结果，每个结果占一行。

**数据范围**

$1≤N,M≤11$

**输入样例：**

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

**输出样例：**

```
1
0
1
2
3
5
144
51205
```

#### 题解



**朴素解**

只要确定了合法的横放的方案数，那么总的方案数就确定了



我们按列枚举，某列的各行用表示摆放状态。

如果某行是1，表示横放，并且向下一列伸出。

如果某行是0，表示竖放或者由前一列伸出。

例：

![image-20220404202720151](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220404202720151.png)



**状态定义：**

$F(i, j)$ ：表示摆放到第 $i$ 列，状态为 $j$ 的方案数

**状态转移：**

$F(i, j) \gets F(i - 1, k)$

例如：

第二列0011的状态可以从0000或1100分别转移过来，$F(2, 3) = 2$

![image-20220404203739695](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220404203739695.png)

将所有能够从$F(i - 1, k)$ 转移到 $F(i, j)$ 状态的方案数累加起来

$F(i, j) =\sum F(i - 1, k)$



**初值：**

$F(0, 0) = 1，其他为0$，表示第 $0$ 列不放矩形是一种合法的方案

**结果：**

$F(m, 0)$ 表示已摆放都 $m$ 列，且第 $m$ 列都没有出现横放，也就是没有向下一列伸出，那么就是刚刚好填充完毕。



**代码：**

预处理判断合并列的合法性

为什么会有不合法的情况呢，比如：

![image-20220404205635736](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220404205635736.png)

情况一，第一列的状态为$1100$ ，第二列的状态为 $0011$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1111$ 是合法的，因为前合并完成的前两列中没有任何空隙。

情况二，第一列的状态为$1100$ ，第二列的状态为 $0000$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1100$ 是合法的，因为前合并完成的前两列中没有任何空隙。

情况三，第一列的状态为$1100$ ，第二列的状态为 $0001$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1101$ 是非法的，因为前合并完成的前两列中有一个空隙。

情况四，第一列的状态为$1100$ ，第二列的状态为 $0010$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1110$ 是非法的，因为前合并完成的前两列中有一个空隙。

从上面的规律我们可以看出，如果合并列的状态中出现连续奇数个 $0$ 那么就是非法的，因为只有偶数个 $0$ 才能被长度为 $1× 2$ 的长方体竖着填充，如果是被前一列伸出的填充的话，合并列的状态是 $1$ 而不是 $0$。所以我们需要先进行预处理，记录出合并列的非法状态。

```java
import java.util.Scanner;

/**
 * 291. 蒙德里安的梦想
 * @author novo
 * @date 2022/4/4-15:58
 */
public class Main {

    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        while (read.hasNext()) {
            int n = read.nextInt();
            int m = read.nextInt();
            if (n == 0 && m == 0) {
                break;
            }

            boolean[] isValid = new boolean[1 << n];
            long[][] dp = new long[m + 1][1 << n];
            dp[0][0] = 1;

            // 预处理 记录合并列中的非法状态
            // 枚举列中所有的状态 比如一共有四行 就要枚举 0000~1111共16个状态
            for (int i = 0; i < (1 << n); i++) {
                isValid[i] = true;
                int zeroNum = 0; // 记录连续0的个数
                // 枚举每一个状态里面的位
                for (int j = 0; j < n; j++) {
                    // 低位开始枚举
                    if ((i >> j & 1) == 1) { // 如果第j位为1
                        // 判断之前是否存在奇数个连续个零
                        if ((zeroNum & 1) == 1) {
                            // 位运算判断奇偶数
                            isValid[i] = false;
                            break;
                        }
                        zeroNum = 0; // 也可以不清零，因为没有break掉说明前面出现的都是偶数个0
                    } else {
                        zeroNum++;
                    }
                }
                // 因为内循环里遇到1时才会进行0的检查，循环如果以高位为0枚举退出时，会漏了高位为0的检查
                if ((zeroNum & 1) == 1) {
                    isValid[i] = false;
                }
            }

            // 状态转移
            // 枚举列
            for (int i = 1; i <= m; i++) {
                // 枚举当前列中的状态
                for (int j = 0; j < (1 << n); j++) {
                    // 枚举前一列的状态
                    for (int k = 0; k < (1 << n); k++) {
                        // 当前列和前一列不能有重叠，且合并列后状态合法，才允许转移
                        if ((j & k) == 0 && isValid[j | k]) {
                            dp[i][j] += dp[i - 1][k];
                            //System.out.println("dp[" + i +" "+ j+"]=" + dp[i][j] + " " + "dp[" + (i-1) +" "+ k+"]=" + dp[i - 1][k]);
                        }
                    }
                }
            }
        }
    }
}

```



### 最短Hamilton路径

#### 题目描述

[AcWing91. 最短Hamilton路径](https://www.acwing.com/problem/content/description/93/)

给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 $Hamilton$ 路径。

$Hamilton$ 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。

**输入格式**

第一行输入整数 $n$。

接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i, j]$）。

对于任意的 $x,y,z$ 数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。

**输出格式**

输出一个整数，表示最短 $Hamilton$ 路径的长度。

**数据范围**

$1≤n≤20$
$0≤a[i,j]≤10^7$

**输入样例：**

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

**输出样例：**

```
18
```



#### 题解

我们用二进制来压缩从结点 $0$ 到 终点 $n - 1$ 路径访问的情况，$1 $ 表示已访问，$0$ 表示未被访问

例如：

假设共有 $ 5 $ 个结点，结点从 $ 0 $ 开始，已访问过的结点集 $\left\{0, 2, 4\right\}$ ，用二进制来表示 $ 10101 $



在终点确定的情况下，我们要求从结点 $0$ 到 终点 $n - 1$ 的最短哈密顿路径，假设终点前一个访问的结点为 $k$ ，那么

$ 0 \rightarrow n - 1$ 这条路径就等价于 $0 \rightarrow k$ 这段路径再加上 $edges[k][n - 1]$ 这段距离即可，而 $edges[k][n - 1]$ 是已知的，那么我们只要枚举所有结点 $k$ 选出 $Min(0 \rightarrow k)$ 即可

**状态定义：**

$F(i, j)$ ：表示路径状态为 $i$ ，起点是 $0$ 终点为 $j$ 的最短哈密顿路径

**状态转移：**

$F(i, j) = Min(F(i - (1 << j), k) + edges[k][j])$



$i - (1 << j)$  的意思是 $i$ 状态除去 $j$ 被访问过的一个状态
例如：
在被访问过的结点集 $\left\{ 0, 3, 5, 6, 9 \right\}$, 假设终点为 $3$
那么从结点 $0$ 到终点 $3$ 这一条最短哈密顿路径只能由，除去终点结点 $ 3 $ 的一个已被访问结点集$\left\{0, 5, 6, 9 \right\}$ 中转化而来，因为在哈密顿路径中一个结点只能被访问一次

从结点 $0$ 到终点 $3$ 这一条最短哈密顿路径为下面路径和中最短的一条：

$0 \rightarrow 5\rightarrow 6\rightarrow 9\rightarrow 3$

$0 \rightarrow 5\rightarrow 9\rightarrow 6\rightarrow 3$

$0 \rightarrow 6\rightarrow 5\rightarrow 9\rightarrow 3$

$0 \rightarrow 6\rightarrow 9\rightarrow 5\rightarrow 3$

$0 \rightarrow 9\rightarrow 5\rightarrow 6\rightarrow 3$

$0 \rightarrow 9\rightarrow 6\rightarrow 5\rightarrow 3$

**代码**

注意枚举的顺序，因为路径状态的转移依赖于前一个路径状态，所以的先枚举路径状态，后枚举终点

```java
import java.util.Arrays;
import java.util.Scanner;

/**
 * 91. 最短Hamilton路径
 *
 * @author novo
 * @date 2022/4/5-14:14
 */
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] edges = new int[n][n];
        // i 是压缩的状态
        int[][] dp = new int[1 << n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                edges[i][j] = read.nextInt();
            }
        }

        // 初始值INF
        for (int i = 0; i < (1 << n); i++) {
            for (int j = 0; j < n; j++) {
                // 只访问过自己结点且终点为自身的最短距离为0 dp[1][0] = dp[2][1] = dp[4][2] ... = 0
                if ((1 << j) == i) {
                    dp[i][j] = 0;
                } else {
                    // 不能取MAX 因为状态转移时有加法会溢出
                    dp[i][j] = (Integer.MAX_VALUE / 2);
                }
            }
        }
        // 因为这题只能从0点出发，所以只设置一个初始值其他设为INF也是可以的
        dp[1][0] = 0;

        // 枚举路径的所有状态
        for (int i = 0; i < (1 << n); i++) {
            // 枚举终点
            for (int j = 0; j < n; j++) {
                // 一种路径状态中的已访问的结点集必须包含终点 这条状态为i 终点为j的路径才合法
                if ((i >> j & 1) == 1) {
                    // 枚举走到j之前 以k为终点的最短距离 也就是前一个状态
                    for (int k = 0; k < n; k++) {
                        if ((i >> k & 1) == 1) {
                            // f(i, j) 由 f(i - {j}, k)转化而来 因为前一个状态要转移到f(i, j)，所以前一个状态j是不能被访问过的
                            dp[i][j] = Math.min(dp[i][j], dp[i - (1 << j)][k] + edges[k][j]);
                        }
                    }
                }
            }
        }
        // 结果 所有结点均被访问过一次 且终点为 n - 1
        System.out.println(dp[(1 << n) - 1][n - 1]);
    }
}
```



如果用暴力枚举来算，确定起点和终点，枚举所有路径排列，也就是$ O((n - 2)!)$ 的时间复杂度，计算每一条路径和为 $O(n)$ ，总时间复杂度就为 $O(n*(n - 2)!)$，这是不可取的。



## 树形 DP



### 打家劫舍 III

#### 题目描述

<span id="house-robber-iii">打家劫舍 III</span>

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)



#### 题解

**状态定义：**

`dp[node][j]` ：这里 `node` 表示一个结点，以 `node` 为根结点的树，并且规定了 `node` 是否偷取能够获得的最大价值。

- `j = 0` 表示 `node` 结点不偷取；
- `j = 1` 表示 `node` 结点偷取。

**状态转移：**

对于每个结点来说只有两个状态：偷与不偷

- 如果没有偷窃当前结点，说明可以选择左右子结点(也可以不选)，选最大者；
- 如果偷窃当前结点，左右子结点均不能偷。

```java
public int rob(TreeNode root) {
    int[] res = dfs(root);
    return Math.max(res[0],res[1]);
}
private int[] dfs(TreeNode root) {
    if (root == null) {
        return new int[]{0,0};
    }
    int[] leftInfo = dfs(root.left);
    int[] rightInfo = dfs(root.right);
    // 后序处理
    // 当前结点的状态只有两种，偷取或不偷 dp[0]代表不偷 dp[1]代表偷
    int[] dp = new int[2];
    // 当前结点不偷 说明可以选择偷窃左右子结点
    dp[0] = Math.max(leftInfo[0],leftInfo[1]) + Math.max(rightInfo[0],rightInfo[1]);
    // 当前结点选择偷 说明不能选择偷窃左右子结点
    dp[1] = root.val + leftInfo[0] + rightInfo[0];
    return dp;
}
```



### 没有上司的舞会

#### 题目描述

[AcWing285. 没有上司的舞会](https://www.acwing.com/problem/content/description/287/)

Ural 大学有 $N$ 名职员，编号为 $1∼N$。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 $Hi$ 给出，其中 $1≤i≤N$。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

**输入格式**

第一行一个整数 $N$。

接下来 $N$ 行，第 $i$ 行表示 $i$ 号职员的快乐指数 $Hi$。

接下来 $N−1$ 行，每行输入一对整数 $L,K$，表示 $K$ 是 $L$ 的直接上司。

**输出格式**

输出最大的快乐指数。

**数据范围**

$1≤N≤6000$,
$−128≤Hi≤127$



#### 题解

**状态定义：**

$F(u, 0)$ ：表示考虑以 $u$ 为根结点的整棵树，不选择 $u$ 这个结点的方案数

$F(u, 1)$ ：示考虑以 $u$ 为根结点的整棵树，选择 $u$ 这个结点的方案数



**状态转移：**

$F(u, 0)  =  F(u, 0) + Max(F(son(u), 0), F(son(u), 1))$

$F(u, 1) = F(u, 1) + F(son(u), 0)$

如果没有选择 $ u $ 结点，则可以考虑 $ u $ 的孩子结点，可以选也可以不选，取 $ u $ 中所有直接孩子的最值方案。

如果选择了 $ u $ 结点，则不可以选 $ u $ 的孩子结点。



**结果：**

$  res = Max(F(u, 1), F(u, 0))$



```java
import java.util.*;

/**
 * @author novo
 * @date 2022/4/6-12:51
 */
public class Main {
    static int N = 100000;

    static class Edge {
        int to;
        int next;

        Edge(int to, int next) {
            this.to = to;
            this.next = next;
        }
    }

    static Edge[] edges = new Edge[N]; // 边域
    static int[] head = new int[N]; // 顶点域
    static int index = 0;
    static boolean[] hasFather = new boolean[N];
    static int[][] dp = new int[N][2]; // 根节点为N这颗树的最大happy值
    static int[] happy = new int[N];

    // 插入一条边 (form, to)
    private static void insert(int from, int to) {
        // 链表头插
        // 新结点的next指向from的原头结点head[from] from的头结点再更新为新插入的结点
        edges[index] = new Edge(to, head[from]);
        head[from] = index;
        index++;
    }

    public static void main(String[] args) {
        Arrays.fill(head, -1);
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();

        for (int i = 1; i <= n; i++) {
            happy[i] = read.nextInt();
        }
        // 插入n-1条边
        for (int i = 0; i < n - 1; i++) {
            int l = read.nextInt();
            int k = read.nextInt();
            insert(k, l);
            hasFather[l] = true;
        }

        // 找出根节点 没有父节点的即为整棵树的根节点
        int root = 1; // 初始值为第一个结点
        while (hasFather[root]) {
            root++;
        }
        dfs(root);

        int res = Math.max(dp[root][0], dp[root][1]);
        System.out.println(res);
    }

    private static void dfs(int root) {
        dp[root][1] = happy[root];
        // 横向搜索子树
        for (int i = head[root]; i != -1; i = edges[i].next) {
            int to = edges[i].to;
            dfs(to);
            dp[root][0] += Math.max(dp[to][0], dp[to][1]);
            dp[root][1] += dp[to][0];
        }
    }
}
```



## 股票问题

### 买卖股票的最佳时机

#### 题目描述

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)



#### 题解

**暴力枚举**

```java
// 暴力枚举 超时
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    // 利益为负不选择交易
    int res = 0;
    // 枚举所有交易差
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            res = Math.max(res, prices[j] - prices[i]);
        }
    }
    // 利益为负 都不交易
    return res;
}
```



**贪心**

因为全程只能**买卖一次**, 所以**贪心的思想很自然就是取最左最小值, 取最右最大值, 那么得到的差值就是最大利润**.



**动态规划**

**状态定义：**

对于每一天来说只有两种状态，持股与不持股

`dp[i]` ：

- `i= 0` 表示当天持股手上所持有的现金
- `i = 1` 表示当前不持股手上所持有的现金

**状态转移：**

- 当天不持股的情况：
  - 之前也不持股
  - 之前持股，当天卖出
- 当天持股的情况：
  - 之前就持股
  - 当天才买入

```java
// 动态规划
public int maxProfit1(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    // 滚动数组 因为只需要两种状态
    int[] dp = new int[2];
    // 初始化第一天的状态
    dp[0] = 0;
    dp[1] = -prices[0];
    // 从第二天开始遍历
    for (int i = 1; i < n; i++) {
        // 今天不持股的情况 之前也不持股或者今天卖出
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        // 今天持股的情况 之前就持股或者今天买入（只能买入）
        dp[1] = Math.max(dp[1], -prices[i]);
    }
    // 返回不持股时手上的现金
    return dp[0];
}
```





### 买卖股票的最佳时机 II

#### 题目描述

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

与第一个问题相比，可以进行多次买入和卖出



#### 题解

**DFS**

由于不限制交易次数，在每一天，就可以根据当前是否持有股票选择相应的操作。

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/3ede46d543e0fcd2ec1b4f9031637fd404b4bdf73505bb1233d870ac92ea8283-image.png)

```java
// dfs超时
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    return dfs(prices, 0, 0);
}

private int dfs(int[] prices, int index, int status) {
    if (index == prices.length) {
        return 0;
    }
    // 局部变量 因为每次dfs并没有回溯
    int stay = 0, buy = 0, sell = 0;
    // 保持状态不变
    stay = dfs(prices, index + 1, status);
    if (status == 1) {
        // 持股状态卖出
        sell = prices[index] + dfs(prices, index + 1, 0);
    } else {
        // 不持股状态买入
        buy = -prices[index] + dfs(prices, index + 1, 1);
    }
    // 取三种策略的收益最大值
    return Math.max(Math.max(stay,buy),sell);
}
```



**贪心**

由于不限制交易次数，每一天都做买卖 只要今天股价比昨天股价高，昨天就选择交易，即可获得所有收益，贪心算法仅可以用于计算，但 **计算的过程并不是真正交易的过程**

```java
// 贪心
public int maxProfit2(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    int res = 0;
    // 每一天都做买卖 只要今天股价比昨天股价高，昨天就选择交易
    for (int i = 1; i < n; i++) {
        res += Math.max(0, prices[i] - prices[i - 1]);
    }
    return res;
}
```



**动态规划**

**状态定义：**

对于每一天来说只有两种状态，持股与不持股

`dp[i][j]` ：

- `i`为天数

- `j = 0` 表示当天持股手上所持有的现金
- `j = 1` 表示当天不持股手上所持有的现金

**状态转移：**

- 当天不持股的情况：
  - 之前也不持股
  - 之前持股，当天卖出
  - 之前已经卖出
- 当天持股的情况：
  - 之前就持股
  - 当天才买入

其实跟问题一的状态转移都是一样的，代码也是一样的，虽然是可以多次交易，但是最终都是最每个状态的最值，对于当天不持股之前卖出过的情况是已经被dp[0]记录下来了

```java
// 动态规划
public int maxProfit3(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    int[] dp = new int[2];
    dp[0] = 0;
    dp[1] = -prices[0];
    int pre0 = dp[0];
    for (int i = 1; i < n; i++) {
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        dp[1] = Math.max(dp[1], pre0 - prices[i]);
        pre0 = dp[0];
    }
    return dp[0];
}
```



### 最佳买卖股票时机含冷冻期

#### 题目描述

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)



#### 题解

**动态规划**

虽然这题比之前的多了一个冷冻期，但每天的状态依然是只有持股和不持股两种，只不过不持股里分为两种情况，一种当天可以买入，另一个则处于冷冻期不能买入

**状态定义**

- `dp[i][j]` ：

  - `i`为天数

  - `j = 0` 表示当天持股手上所持有的现金
  - `j = 1` 表示当天不持股(非冷冻期)手上所持有的现金
  - `j = 2` 表示当天冷冻期手上所持的现金


**状态转移：**

- 当天不持股(非冷冻期)的情况：
  - 之前也不持股
  - 前一天为冷冻期
- 当天不持股(冷冻期)的情况：
  - 卖出的第二天

- 当天持股的情况：
  - 之前就持股
  - 当天才买入

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    int[][] dp = new int[n][3];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[0][2] = 0;
    for (int i = 1; i < n; i++) {
        // 注意dp[][0]非冷冻期不持股的状态只能 由 非冷冻期不持股或冷冻期转化而来 而不能由持股卖出转化
        dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][2]);
        // 持股状态
        dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
        // 冷冻期状态
        dp[i][2] = dp[i - 1][1] + prices[i];
    }
    // 返回不持股状况的最大值
    return Math.max(dp[n - 1][0],dp[n - 1][2]);
}
```



滚动数组空间优化

使用滚动数组时，需要注意状态转移时，参数是否为上一次的状态，这题有三个状态，所以需要用两个pre变量来记录上个状态，避免前个状态在一个转移方程后发生更改

```java
public int maxProfit2(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    // 滚动数组 空间优化
    int[] dp = new int[3];
    dp[0] = 0;
    dp[1] = -prices[0];
    dp[2] = 0;
    int pre0 = dp[0];
    int pre1 = dp[1];
    for (int i = 1; i < n; i++) {
        // 注意dp[][0]非冷冻期不持股的状态只能 由 非冷冻期不持股或冷冻期转化而来 而不能由持股卖出转化
        dp[0] = Math.max(dp[0],dp[2]);
        // 持股状态
        dp[1] = Math.max(dp[1],pre0 - prices[i]);
        // 冷冻期状态
        dp[2] = pre1 + prices[i];
        pre0 = dp[0];
        pre1 = dp[1];
    }
    // 返回不持股状况的最大值
    return Math.max(dp[0],dp[2]);
}
```



## 子序列模型

### 最长上升子序列

#### 题目描述

[LeetCode300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)



#### 题解

**DFS**

```java
// dfs暴力
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int res = 1;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dfs(nums, i));
    }
    return res;
}

// 枚举以不同元素结尾的所有情况
private int dfs(int[] nums, int index) {
    int res = 1;
    for (int j = 0; j < index; j++) {
        if (nums[j] < nums[index]) {
            res = Math.max(res, 1 + dfs(nums, j));
        }
    }
    return res;
}
```



**记忆化搜索**

**状态定义：**

`LIS(i)`：表示以第`i`个数字为结尾的最长递增子序列的长度

**状态转移：**

`LIS(i) = max(1 + LIS(j) if nums[j] < nums[i] && j < i)`



```java
// 记忆化搜索
private int[] memory;

public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    memory = new int[n];
    // res表示以第i个数字为结尾的最长递增子序列的长度
    int res = 1;
    for (int i = 0; i < n; i++) {
        memory[i] = -1;
    }
    // 枚举所有以第i个数字为结尾的最长递增子序列的长度 取最大值
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dfs(nums, i));
    }
    return res;
}

private int dfs(int[] nums, int index) {
    if (memory[index] == -1) {
        int res = 1;
        for (int j = 0; j < index; j++) {
            if (nums[j] < nums[index]) {
                res = Math.max(res, 1 + dfs(nums, j));
            }
        }
        memory[index] = res;
    }
    return memory[index];
}
```



**动态规划**

遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间，使用dp[n]

```java
// 动态规划
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    // 表示以第i个数字为结尾的最长递增子序列的长度
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
	// 得到所有LIS(i)后 取最大值
    int res = 1;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```



ACM模式：

题目链接https://www.nowcoder.com/questionTerminal/d83721575bd4418eae76c916483493de

```java
import java.util.Scanner;
import java.util.Arrays;

public class M {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        // 多组数据
        while (read.hasNext()) {
            int n = read.nextInt();
            int[] nums = new int[n];
            int[] dp = new int[n];
            int res = 1;

            for (int i = 0; i < n; i++) {
                nums[i] = read.nextInt();
            }
            Arrays.fill(dp, 1);

            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[j] < nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
                res = Math.max(res, dp[i]);
            }
            System.out.println(res);
        }
    }
}
```





<span id="longest-increasing-subsequence">**贪心 + 二分（最优解）**</span>

贪心思想：依然着眼于某个递增子序列的结尾的元素，如果已经得到的递增子序列的结尾的数越小，那么遍历的时候后面接上一个数，**会有更大的可能构成一个长度更长的上升子序列**。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，不断更新。



**定义：**

`dp[i]` 表示所有长度为`i`的 递增子序列结尾的最小值

并且`dp`数组是严格递增的

证明：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220301204317080.png)

因为只需要维护状态数组 `dp` 的定义，它的长度就是最长递增子序列的长度。因为`dp`已经是一个有序数组，所以我们使用二分来更新最小值

看下动画就懂了

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/Honeycam%202022-03-01%2020-47-36.gif)

时间复杂度`O(NlogN)`

```java
// 贪心 + 二分
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    // 表示长度为 i 的 所有递增子序列的结尾的最小值 用的不是动态规划数组名随便起的
    int[] dp = new int[n + 1];
    // 做一个位置的偏移
    dp[1] = nums[0];
    int len = 1;
    for (int i = 1; i < n; i++) {
        if (dp[len] < nums[i]) {
            dp[++len] = nums[i];
        } else {
            // 因为做了右一位偏移 所以二分初始值为 1 和 len
            int index = binarySearch(dp, 1, len, nums[i]);
            if (index != -1) {
                dp[index] = nums[i];
            }
        }
    }
    return len;
}

private int binarySearch(int[] sortedArr, int L, int R, int target) {
    if (sortedArr == null || sortedArr.length == 0) {
        return -1;
    }
    int left = L;
    int right = R;
    int mid = 1;
    // 循环条件至少有两个数
    while (left < right) {
        mid = left + ((right - left) >> 1);
        // 因为是严格递增 所以如果target等于dp里的数的话不更新
        if (sortedArr[mid] == target) {
            return -1;
        } else if (sortedArr[mid] < target) {
            left = mid + 1;
        } else if (sortedArr[mid] > target){
            // 为了保证找出的数一定是第一个大于target的，right指针赋值为mid而不是mid - 1
            // 如果世上mid - 1找出的数只是最邻近target的值，而不能确定这个数比target大还是小
            right = mid;
        }
    }
    return left;
}
```







### 最长上升子序列的个数

#### 题目描述

[673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)



#### 题解

不同于最长递增子序列问题，这题我们还需要多维护一个数组



**动态规划**



**状态定义：**

`LIS(i)`：表示以第`i`个数字为结尾的最长递增子序列的长度

`count(i)`：表示以第`i`个数字为结尾的最长递增子序列的个数

**状态转移：**

`LIS(i) = max(1 + LIS(j) if nums[j] < nums[i] && j < i)`



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220302235400607.png)

```java
public int findNumberOfLIS(int[] nums) {
    if (nums.length < 2) {
        return nums.length;
    }
    int n = nums.length;
    int[] dp = new int[n];
    int[] count = new int[n];
    Arrays.fill(dp, 1);
    Arrays.fill(count, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                if (dp[j] + 1 > dp[i]) {
                    // 说明找到了一个更长的递增子序列 还是只有一条最长的 以nums[i]结尾的长度就等于以nums[j]结尾的长度
                    count[i] = count[j];
                } else if (dp[j] + 1 == dp[i]) {
                    /* 说明在一次内循环寻找dp[i最大值中找到了两个相同长度的递增子序列 注意这里是累加而不是+1
                        因为这是有多种方案可以达到最长递增子序列 而count[i]的定义是以nums[i]结尾的最长递增子序列的数量
                     */
                    count[i] += count[j];
                }
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    int res = 0;
    int maxLen = 0;
    // 找出最大长度
    for (int x : dp) {
        maxLen = Math.max(maxLen, x);
    }
    // 将所有最大长度对应的count[i]累加就是结果
    for (int i = 0; i < n; i++) {
        if (dp[i] == maxLen) {
            res += count[i];
        }
    }
    return res;
}
```



**常数优化**

```java
public int findNumberOfLIS1(int[] nums) {
    if (nums.length < 2) {
        return nums.length;
    }
    int n = nums.length;
    int[] dp = new int[n];
    int[] count = new int[n];
    int maxLen = 1;
    int res = 1;
    Arrays.fill(dp, 1);
    Arrays.fill(count, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                if (dp[j] + 1 > dp[i]) {
                    // 把dp的更新写在dp[j] + 1 > dp[i]就不用额外判断内循环的最值了
                    dp[i] = dp[j] + 1;
                    count[i] = count[j];
                } else if (dp[j] + 1 == dp[i]) {
                    count[i] += count[j];
                }
            }
        }
        // 同时找出最大长度
        maxLen = Math.max(maxLen,dp[i]);
    }

    // 将所有最大长度对应的count[i]累加就是结果
    for (int i = 0; i < n; i++) {
        if (dp[i] == maxLen) {
            res += count[i];
        }
    }
    return res;
}
```



### 最长上升子序列的一个解

#### 题目描述

求一个具体的LIS序列



#### 题解

前面求`LIS`长度的分析中，我们知道LIS可能出现在任意一个以`nums[i]`结尾的子序列中，但是我们并不知道会出现在哪里。在求LIS长度的问题中，我们是求`dp[i]`中的最大值。那这里，在求具体的`LIS`中，对于每一个`dp[i]`，我们需要用一个列表`res`存下一个结束于`nums[i]`的`LIS`。这样，最后找到值最大的`dp[i]`时，对应的`res[i]`即为所求整个串的`LIS`。



动态规划求方案，就是将我们转移的过程记录下来即可



牛客网上有题类似的

https://www.nowcoder.com/questionTerminal/30fb9b3cab9742ecae9acda1c75bf927

不过他要求的解是如果有多个答案，请输出其中字典序最小的

下面代码只是求出一个解



**使用数组记录解**

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n];
        int[] dp = new int[n];
        int[] memory = new int[n]; // 用于记录转移的过程
        int index = 0;
        int res = 1;

        for (int i = 0; i < n; i++) {
            nums[i] = read.nextInt();
        }
        Arrays.fill(dp, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    // 记录下每个状态从哪里来的
                    memory[i] = j;
                }
            }
            // 求出最大长度 和 该序列结尾的索引
            if (dp[i] > res) {
                res = dp[i];
                index = i;
            }
        }

        Deque<Integer> stack = new ArrayDeque<>();
        // 倒序输入栈
        for (int i = 0, len = dp[index]; i < len; i++) {
            stack.push(nums[index]);
            index = memory[index];
        }
        // 最后再输出栈即可
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + " ");
        }
    }
}
```



显然使用数组来存储解是不太方便的，我们使用list

```java
public List<Integer> getSeqOfLIS(int[] nums) {
    if (nums.length < 2) {
        if (nums.length == 0) {
            return new ArrayList<>();
        }
        else {
            return new ArrayList<>(nums[0]);
        }
    }

    int n = nums.length;
    // 表示以nums[i]为结尾的最长递增子序列的长度
    int[] dp = new int[n];
    int maxLen = 1;
    int maxId = 1;
    // res.get(i) 表示以nums[i]结尾的最长递增子序列
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    Arrays.fill(dp, 1);
    // 初始化索引为0的res
    path.add(nums[0]);
    res.add(path);
    for (int i = 1; i < n; i++) {
        path = new ArrayList<>();
        int index = -1;
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                dp[i] = dp[j] + 1;
                index = j;
            }
        }
        // 下面两步是将res.get(index)复制并挂到nums[i]作为以nums[i]结尾的最长递增子序列
        if (index > -1) {
            path.addAll(res.get(index));
        }
        path.add(nums[i]);

        res.add(path);
        // 同步更新最大长度和最大长度递增子序列尾元素的索引
        if (dp[i] > maxLen) {
            maxLen = dp[i];
            maxId = i;
        }
    }
    return res.get(maxId);
}
```



### 摆动序列

#### 题目描述

[LeetCode376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)



#### 题解

**动态规划**

**状态定义：**

摆动序列要么以降序结尾要么以升序结尾

`dp[i][0]`：考虑`[0, i - 1]`内**以降序结尾**的摆动数组的最长子序列的长度

`dp[i][1]`：考虑`[0, i - 1]`内**以升序结尾**的摆动数组的最长子序列的长度

**状态转移：**

`num[i] > nums[i - 1]`：

- `dp[i][1] = 1 + dp[i - 1][0]  `
- `dp[i][0] = dp[i - 1][0]  `

`num[i] < nums[i - 1]`：

- `dp[i][1] = dp[i - 1][1]  `
- `dp[i][0] = 1 + dp[i - 1][1]  `

`num[i] = nums[i - 1]`：

- `dp[i][1] = dp[i - 1][1]  `
- `dp[i][0] = dp[i - 1][0]  `



```java
public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 1;
    dp[0][1] = 1;
    for (int i = 1; i < n; i++) {
        // 如果下一数大于前一个数 则新升序结尾数组 = 旧降序结尾数组+1 新降序结尾数组不变 维护摆动
        if (nums[i] > nums[i - 1]) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = 1 + dp[i - 1][0];
        } else if (nums[i] < nums[i - 1]) {
            // 如果下一数小于于前一个数 则新降序结尾数组 = 旧升序结尾数组 + 1 维护摆动
            dp[i][0] = 1 + dp[i - 1][1];
            dp[i][1] = dp[i - 1][1];
        } else {
            // 相等都不变
            dp[i][1] = dp[i - 1][1];
            dp[i][0] = dp[i - 1][0];
        }
    }
    // 返回考虑[0, i - 1]内最长子序列的长度
    return Math.max(dp[n - 1][0], dp[n - 1][1]);
}
```

第一维度也可以优化掉，因为只与前一个状态有关，可以达到O1



**贪心**

画出折线图显而易见，我们只需要关注峰谷和封顶，峰谷和封顶的数量就是所求



![image-20220301233729694](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220301233729694.png)

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220301235214081.png)

```java
public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int cur = 0;
    int pre = 0;
    // 声明一个res 注意边界 有一个峰值出现摆动序列长度就是2 所以初始化为1
    int res = 1;
    for (int i = 1; i < n; i++) {
        cur = nums[i] - nums[i - 1];
        // 当出现峰谷和峰顶时 res+1 并且pre将升序切换到降序或降序切换到升序
        if ((cur > 0 && pre <= 0) || (cur < 0 && pre >= 0)) {
            res++;
            pre = cur;
        }
    }
    return res;
}
```



### 最长公共子序列

#### 题目描述

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

可以应用在基因工程、基因相似度



#### 题解

**DFS**

递归树：

从A、B两个字符串的末尾的字符开始比对，如果字符相等，则说明存在一个公共字符，长度+1，

如果不相等，则分出两条分支，**A字符串指针往前移一位、B字符串指针不动继续比较** 和 **B字符串指针往前移一位、A字符串指针不动继续比较**，**两个分支取最大值**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220302204143508.png)

```java
// dfs超时
public int longestCommonSubsequence(String text1, String text2) {
    if (text1.length() == 0 || text2.length() == 0) {
        return 0;
    }
    return dfs(text1.toCharArray(), text2.toCharArray(), text1.length() - 1, text2.length() - 1);
}
private int dfs(char[] test1, char[] test2, int i, int j) {
    if (i == -1 || j == -1) {
        return 0;
    }
    if (test1[i] == test2[j]) {
        return 1 + dfs(test1, test2, i - 1, j - 1);
    }else {
        return Math.max(dfs(test1, test2, i - 1, j), dfs(test1, test2, i, j - 1));
    }
}
```



**记忆化搜索**

可以看到上面的递归树存在着重复子问题和最优子结构，所以可以用记忆化优化

因为是两个字符串，所以使用二维来定义A串`i`位置和B串`j`位置是否相等

```java
// 记忆化搜索
private int[][] memory;

public int longestCommonSubsequence(String text1, String text2) {
    if (text1.length() == 0 || text2.length() == 0) {
        return 0;
    }
    int m = text1.length();
    int n = text2.length();
    memory = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            memory[i][j] = -1;
        }
    }
    return dfs(text1.toCharArray(), text2.toCharArray(), m - 1, n - 1);
}

private int dfs(char[] text1, char[] text2, int i, int j) {
    if (i == -1 || j == -1) {
        return 0;
    }
    if (memory[i][j] == -1) {
        if (text1[i] == text2[j]) {
            memory[i][j] = 1 + dfs(text1, text2, i - 1, j - 1);
        } else {
            memory[i][j] = Math.max(dfs(text1, text2, i - 1, j), dfs(text1, text2, i, j - 1));
        }
    }
    return memory[i][j];
}
```



**动态规划**

**状态定义：**

`dp[i][j]`：长度为`i`的`text1`子串与长度为`j`的`text2`字串的公共子串长度（是指text1前i个字符构成的子串和text2前j个字符构成的子串的最长公共子序列长度）

**状态转移：**

`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), if text1[i] != text2[j]`

`dp[i][j] = 1 + dp[i - 1][j - 1], if text1[i] == text2[j] `



```java
// 动态规划 自底向上
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    // 初始化默认为0
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```



ACM模式

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int m = read.nextInt();
        int n = read.nextInt();
        String text1 = read.next();
        String text2 = read.next();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        } 
        
        System.out.println(dp[m][n]);
    }
}
```





### 怪盗基德的滑翔翼

#### 题目描述

[AcWing1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/description/1019/)

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。

而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。

有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。

不得已，怪盗基德只能操作受损的滑翔翼逃脱。

假设城市中一共有 $N$ 幢建筑排成一条线，每幢建筑的高度各不相同。

**初始时，怪盗基德可以在任何一幢建筑的顶端。**

他可以选择一个方向逃跑，但是**不能中途改变方向**（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他**只能往下滑行**（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

**输入格式**

输入数据第一行是一个整数 $K$，代表有 $K$ 组测试数据。

每组测试数据包含两行：第一行是一个整数 $N$ ，代表有 $N$ 幢建筑。第二行包含 $N$ 个不同的整数，每一个对应一幢建筑的高度 $h$ ，按照建筑的排列顺序给出。

**输出格式**

对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

**数据范围**

$ 1≤K≤100$ ,
$ 1≤N≤100 $ ,
$ 0<h<10000 $ 

**输入样例：**

```
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
```

**输出样例：**

```
6
6
9
```



#### 题解

虽然说起点可以在任意点，但是显然可知，最优解一定是在两端开始，所以该问题实际上就是一个下降的LIS问题，只不过要从两个不同的方向都求一遍最长下降子序列，取一个最大值。

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int k = read.nextInt();
        while (k-- > 0) {
            int n = read.nextInt();
            int[] nums = new int[n + 1];
            for (int i = 1; i <= n; i++) {
                nums[i] = read.nextInt();
            }

            int res = 1;
            int[] dp = new int[n + 1];

            // 正向下降LIS问题
            Arrays.fill(dp, 1);
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j < i; j++) {
                    if (nums[j] > nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
                res = Math.max(res, dp[i]);
            }

            // 反向下降LIS问题
            Arrays.fill(dp, 1);
            for (int i = n; i >= 1; i--) {
                for (int j = n; j > i; j--) {
                    if (nums[j] > nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
                res = Math.max(res, dp[i]);
            }

            // 两个方向取个最值
            System.out.println(res);
        }
    }
}
```



### 登山

#### 题目描述

[AcWing1014. 登山](https://www.acwing.com/problem/content/description/1016/)

五一到了，ACM队组织大家去登山观光，队员们发现山上一共有 $N$ 个景点，并且决定按照顺序来浏览这些景点，即**每次所浏览景点的编号都要大于前一个浏览景点的编号。**

同时队员们还有另一个登山习惯，就是**不连续浏览海拔相同的两个景点**，并且**一旦开始下山，就不再向上走**了。

队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

**输入格式**

第一行包含整数 $N$ ，表示景点数量。

第二行包含 $N$ 个整数，表示每个景点的海拔。

**输出格式**

输出一个整数，表示最多能浏览的景点数。

数据范围

$2≤N≤1000$

**输入样例：**

```
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```
4
```



#### 题解

每次所浏览景点的编号都要大于前一个浏览景点的编号（下标）：即从左到右选子序列

不连续浏览海拔相同的两个景点和一旦下山就不能上升这两个条件可以推出我们所走的路径一定是一个峰图：

![image-20220524203549483](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220524203549483.png)





最简单的思路就是枚举最高点，分成两段不同方向的LIS求和的最大值。

时间复制度：$O(n ^ 3)$

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            nums[i] = read.nextInt();
        }

        int[] dp = new int[n + 1];
        int res = 1;

        // 枚举最高点
        for (int k = 1; k <= n; k++) {
            int left = 1, right = 1;
            // 正向LIS
            Arrays.fill(dp, 1);
            for (int i = 1; i <= k; i++) {
                for (int j = 1; j < i; j++) {
                    if (nums[j] < nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
                left = Math.max(left, dp[i]);
            }

            // 反向LIS
            Arrays.fill(dp, 1);
            for (int i = n; i >= k; i--) {
                for (int j = n; j > i; j--) {
                    if (nums[j] < nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
                right = Math.max(right, dp[i]);
            }
            // 因为正向反向的k都是取的等号，所以一个点算了两遍 要减去1
            res = Math.max(res, left + right - 1);
        }

        System.out.println(res);
    }
}
```

其实我们可以牺牲一点空间复杂度，使用两个数组分别来记录正向的和反向的状态，从而可以省掉一层循环。最后在外枚举正向和反向和的最大值

```java
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            nums[i] = read.nextInt();
        }

        int res = 1;
        int[] f = new int[n + 1];
        int[] g = new int[n + 1];

        Arrays.fill(f, 1);
        Arrays.fill(g, 1);
        // 正向求解LIS
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (nums[j] < nums[i]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        // 反向求解LIS
        for (int i = n; i >= 1; i--) {
            for (int j = n; j > i; j--) {
                if (nums[j] < nums[i]) {
                    g[i] = Math.max(g[i], g[j] + 1);
                }
            }
        }
        // 枚举正向和反向长度和的最大值
        for (int i = 0; i <= n; i++) {
            res = Math.max(res, f[i] + g[i] - 1);
        }
        System.out.println(res);
    }
}
```





### 合唱队形

#### 题目描述

[AcWing482. 合唱队形](https://www.acwing.com/problem/content/description/484/)

$N$ 位同学站成一排，音乐老师要请其中的 $(N−K)$ 位同学出列，使得剩下的 $K$ 位同学排成合唱队形。     

合唱队形是指这样的一种队形：设 KK 位同学从左到右依次编号为 $1，2…，K$，他们的身高分别为 $T1，T2，…，TK$，  则他们的身高满足 $T1<…<Ti>Ti+1>…>TK(1≤i≤K)$。     

你的任务是，已知所有 $N$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**输入格式**

输入的第一行是一个整数 $N$，表示同学的总数。

第二行有 $N$ 个整数，用空格分隔，第 $i$ 个整数 $Ti$ 是第 $i$ 位同学的身高(厘米)。

**输出格式**

输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

**数据范围**

$2≤N≤100$,
$130≤Ti≤230$

**输入样例：**

```
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```
4
```



#### 题解

题目意思就是剔除最少的人数使得队形可以形成一个峰型，**等价于求出一个最长的一个峰型**。实际上就是登山的问题，两边求LIS

返回值为总人数 - 最长的峰型序列长度

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        for (int i = 1;i <= n; i++) {
            nums[i] = read.nextInt();
        }
        
        int res = 1;
        int[] f = new int[n + 1];
        int[] g = new int[n + 1];
        Arrays.fill(f, 1);
        Arrays.fill(g, 1);
        
        // 正向LIS
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (nums[j] < nums[i]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        
        // 反向LIS
        for (int i = n; i >= 1; i--) {
            for (int j = n; j > i; j--) {
                if (nums[j] < nums[i]) {
                    g[i] = Math.max(g[i], g[j] + 1);
                }
            }
        }
        
        for (int i = 1; i <= n; i++) {
            res = Math.max(res, f[i] + g[i] - 1);
        }
        
        System.out.println(n - res);
    }    
}
```



### 友好城市

#### 题目描述

[AcWing1012. 友好城市](https://www.acwing.com/problem/content/description/1014/)

$Palmia$ 国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$个城市。

北岸的每个城市**有且仅有一个**友好城市在南岸，而且**不同城市的友好城市不相同**。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

**输入格式**

第 $1$ 行，一个整数 $N$，表示城市数。

第 $2$ 行到第 $n+1$ 行，每行两个整数，中间用 $1$ 个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

**输出格式**

仅一行，输出一个整数，表示政府所能批准的最多申请数。

**数据范围**

$1≤N≤5000$,
$0≤xi≤10000$

**输入样例：**

```
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
```

**输出样例：**

```
4
```



#### 题解

先要找出LIS的模型

只有x坐标，城市均分布在岸上

![image-20220526213521341](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220526213521341.png)



我们选取其中一岸的坐标，对其排序，如图选南岸排序，那么我们依照这个顺序去选取北岸对应的友好城市：$B->A->D->F->C->E->G$

若按照这个顺序选取的两个北岸城市中存在 $x1$ 的顺序先于 $x2$，但是，$x1 $ 的坐标比 $x2$ 大，则说明这两个桥相交，如 B A

所以这个问题就转化为了LIS问题

![image-20220526220629728](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220526220629728.png)



```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] nums = new int[n + 1][2];
        for (int i = 1; i <= n; i++) {
            nums[i][0] = read.nextInt();
            nums[i][1] = read.nextInt();
        }
        // 选取一岸进行排序
        Arrays.sort(nums, (o1, o2) -> o1[0] - o2[0]);

        int[] dp = new int[n + 1];
        int res = 1;
        Arrays.fill(dp, 1);

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (nums[j][1] < nums[i][1]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }

        System.out.println(res);
    }
}
```



### 最大上升子序列和

#### 题目描述

[AcWing1016. 最大上升子序列和](https://www.acwing.com/problem/content/description/1018/)

一个数的序列 $bi$，当 $b1<b2<…<bS$ 的时候，我们称这个序列是上升的。

对于给定的一个序列($a1,a2,…,aN$)，我们可以得到一些上升的子序列($ai1,ai2,…,aiK$)，这里$1≤i1<i2<…<iK≤N$。

比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。

这些子序列中和最大为18，为子序列(1,3,5,9)的和。

你的任务，就是对于给定的序列，求出最大上升子序列和。

注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。

**输入格式**

输入的第一行是序列的长度N。

第二行给出序列中的N个整数，这些整数的取值范围都在0到10000(可能重复)。

**输出格式**

输出一个整数，表示最大上升子序列和。

**数据范围**

$1≤N≤1000$

**输入样例：**

```
7
1 7 3 5 9 4 8
```

**输出样例：**

```
18
```





#### 题解

**状态定义：**

`F(i)`：表示以第`i`个数字为结尾的最大上升子序列和

**状态转移：**

`F(i) = max(F(i), F(j) + nums[i] if nums[j] < nums[i] && j < i)`



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            nums[i] = read.nextInt();
        }

        int[] dp = new int[n + 1];
        // dp初始值就是nums[i]本身
        for (int i = 1; i <= n; i++) {
            dp[i] = nums[i];
        }

        int res = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + nums[i]);
                }
            }
            res = Math.max(res, dp[i]);
        }

        System.out.println(res);
    }
}
```



### 拦截导弹

#### 题目描述

[AcWing443. 拦截导弹](https://www.acwing.com/problem/content/description/445/)

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。

但是这种导弹拦截系统有一个缺陷：虽然它的**第一发炮弹能够到达任意的高度**，但是以后每一发炮弹都**不能高于前一发的高度**。

某天，雷达捕捉到敌国的导弹来袭。

由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于 $30000$ 的正整数，导弹数不超过 $1000$ ），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

**输入格式**

共一行，输入导弹依次飞来的高度。

**输出格式**

第一行包含一个整数，表示最多能拦截的导弹数。

第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。

**数据范围**

雷达给出的高度数据是不大于 $30000$ 的正整数，导弹数不超过 $1000$。

**输入样例：**

```
389 207 155 300 299 170 158 65
```

**输出样例：**

```
6
2
```



#### 题解

题目共有两问，第一问实际上就是求最长下降子序列（非严格下降）

第二问求最长下降子序列的最少划分数，根据 $Dilworth$ 定理，等价于求其最长上升子序列长度，证明过程 [Dilworth定理，链还是反链？](https://www.cnblogs.com/nanke/archive/2011/08/11/2134355.html)

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        String str = read.nextLine();
        String[] strings = str.split(" ");
        int n = strings.length;
        int[] nums = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            nums[i] = Integer.parseInt(strings[i - 1]);
        }

        int[] f = new int[n + 1];
        int[] g = new int[n + 1];
        Arrays.fill(f, 1);
        Arrays.fill(g, 1);
        int res1 = 1, res2 = 1;

        // 第一问 最长下降子序列（非严格下降）
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (nums[j] >= nums[i]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
            res1 = Math.max(res1, f[i]);
        }

        // 第二问 最长下降子序列的划分 等价于最长反链长度即最长上升子序列长度
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                if (nums[j] < nums[i]) {
                    g[i] = Math.max(g[i], g[j] + 1);
                }
            }
            res2 = Math.max(res2, g[i]);
        }

        System.out.println(res1);
        System.out.println(res2);
    }
}
```



### 导弹拦截系统

#### 题目描述

[AcWing187. 导弹拦截系统](https://www.acwing.com/problem/content/description/189/)

为了对抗附近恶意国家的威胁，$R$ 国更新了他们的导弹防御系统。

一套防御系统的导弹拦截高度要么一直 **严格单调** 上升要么一直 **严格单调** 下降。

例如，一套系统先后拦截了高度为 $3$ 和高度为 $4$ 的两发导弹，那么接下来该系统就只能拦截高度大于 $4$ 的导弹。

给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

**输入格式**

输入包含多组测试用例。

对于每个测试用例，第一行包含整数 $n$，表示来袭导弹数量。

第二行包含 $n$ 个**不同的**整数，表示每个导弹的高度。

当输入测试用例 $n=0$ 时，表示输入终止，且该用例无需处理。

**输出格式**

对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

**数据范围**

$1≤n≤50$

**输入样例：**

```
5
3 5 2 4 1
0 
```

**输出样例：**

```
2
```

**样例解释**

对于给出样例，最少需要两套防御系统。

一套击落高度为 3,43,4 的导弹，另一套击落高度为 5,2,15,2,1 的导弹。



#### 题解

这题虽然相对于拦截导弹来说只增加了一个条件，那就是导弹的起始方向是可以有两个方向的。

所以对于每个数来说，一共有三大类选择：

情况一：该数接到上升序列后

情况二：该数接到下降序列后

情况三：该数自己作为新的一个序列

看了题目给的数据范围，大概率就是暴搜了

如果该数是接到已有的上升/下降序列中，那么是接到哪一个上升/下降序列后呢，

这里我们根据贪心原则，如果是接到上升序列后，那么该数就要接到结尾元素小于该数且最接近该数的上升序列后；如果是接到下降序列后，那么该数接要接到结尾元素大于该数且最接近该数的下降序列后。

DFS求最优解，通常有两种做法：**维护一个全局变量**或**迭代加深**

这里采用维护一个全局变量

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        while (read.hasNext()) {
            int n = read.nextInt();
            if (n == 0) break;
            int[] nums = new int[n];
            res = Integer.MAX_VALUE; // 多组数据记得重置res
            for (int i = 0; i < n; i++) {
                nums[i] = read.nextInt();
            }
            dfs(nums, 0, 0, 0, n);
            System.out.println(res);
        }
    }


    private static int[] up = new int[10000]; // up数组存储每个上升序列的结尾元素
    private static int[] down = new int[10000]; // down数组存储每个下降序列的结尾元素
    private static int res = Integer.MAX_VALUE; // 维护全局最优值

    // 先枚举将该数放到上升序列还是下降序列中
    private static void dfs(int[] nums, int index, int upLen, int downLen, int len) {
        // 剪枝 如果当前分支子序列的个数已经大于等于res，则没必要继续下去
        if (upLen + downLen >= res) {
            return;
        }
        if (index == len) {
            res = Math.min(res, upLen + downLen);
            return;
        }

        // 情况一：当前数nums[index]接到已有上升序列后
        boolean flag = false;
        for (int i = 0; i < upLen; i++) {
            // 接到结尾元素小于该数且最接近该数的上升序列后
            if (up[i] < nums[index]) {
                int temp = up[i];
                up[i] = nums[index];
                dfs(nums, index + 1, upLen, downLen, len);
                // 状态重置
                up[i] = temp;
                flag = true;
                break;
            }
        }
        // 情况二：当前数nums[index]作为新的一个上升序列
        if (!flag) {
            up[upLen] = nums[index];
            dfs(nums, index + 1, upLen + 1, downLen, len);
        }

        // 情况三：当前数nums[index]接到已有下降序列后
        flag = false;
        for (int i = 0; i < downLen; i++) {
            // 接到结尾元素大于该数且最接近该数的下降序列后
            if (down[i] > nums[index]) {
                int temp = down[i];
                down[i] = nums[index];
                dfs(nums, index + 1, upLen, downLen, len);
                // 状态重置
                down[i] = temp;
                flag = true;
                break;
            }
        }
        // 情况四：当前数nums[index]作为新的一个下降序列
        if (!flag) {
            down[downLen] = nums[index];
            dfs(nums, index + 1, upLen, downLen + 1, len);
        }
    }
}

```



### 最长公共上升子序列

#### 题目描述

[AcWing272. 最长公共上升子序列](https://www.acwing.com/problem/content/description/274/)

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 $A$ 和 $B$ 的长度均不超过 $3000$。

**输入格式**

第一行包含一个整数 $N$，表示数列 $A，B$ 的长度。

第二行包含 $N$ 个整数，表示数列 $A$。

第三行包含 $N$ 个整数，表示数列 $B$。

**输出格式**

输出一个整数，表示最长公共上升子序列的长度。

**数据范围**

$1≤N≤3000$,序列中的数字均不超过 $2 ^{31 - 1}$。

**输入样例：**

```
4
2 2 1 3
2 1 2 3
```

**输出样例：**

```
2
```

#### 题解

LCIS问题，也就是LIS和LCS的组合

我们先用最容易理解的方式来思考，定义状态

因为要求是上升子序列，所以状态定义我们是需要考虑结尾元素的

`f(i, j)`：表示 A 考虑到`i`位置，B 考虑到`j`位置，并且选择`A[i]`和`B[j]`的最长公共上升子序列长度最大值。

状态转移：

当 $A[i] \neq B[j]$时：$f(i, j) = 0$

当$A[i] = B[j]$时：$f(i, j) = Max(f(k, l)) + 1, k < i~and~A[k] < A[i]~and~l < j~and~B[l]<B[j]$

这个转移方程可以很容易的写出来，但是问题在于当$A[i] = B[j]$时，我们去算前一个状态是$O(n^2)$的复杂度，而我们的状态维数又是$O(n^2)$，所以总时间复杂度达到了$O(n^4)$，这是一个很不理想的情况。

其实我们还发现需要寻找的前一个状态$f(k, l)$, k 和 l也是匹配的即$A[k] = B[l]$，所以 $ A[k] < A[i],B[l]<B[j]$ 这两个条件只需要成立其中一个，另一个必然成立

![image-20220529231607967](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220529231607967.png)

所以其实可以将其中的一个信息转化为**前缀信息**，我们选择将$A[k] < A[i]$ 优化掉

重新定义状态：

`f(i, j)`：表示 A 考虑到`i`位置，B 考虑到`j`位置，并且选`B[j]`的最长公共上升子序列长度最大值。

状态转移：

当 $A[i] \neq B[j]$时：$f(i, j) = f(i - 1, j)$，因为只选了B[j]，所以虽然$A[i] \neq B[j]$，但是A[i]前面的元素是有可能与B[j]匹配的（前缀信息）。

当$A[i] = B[j]$时：$f(i, j) = Max(f(i - 1, l)) + 1, l < j~and~B[l]<B[j]$，这里i被拿掉的原因是 当前$A[i] = B[j]$已经匹配了，所以要拿掉i

这样就将问题优化成了$O(n^3)$

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] a = new int[n + 1];
        int[] b = new int[n + 1];
        for (int i = 1; i <= n; i++) a[i] = read.nextInt();
        for (int i = 1; i <= n; i++) b[i] = read.nextInt();
        
        int[][] dp = new int[n + 1][n + 1];
        int res = 0;
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (a[i] != b[j]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // 注意更新空集 此前如果没有出现过公共子序列的话不会进入k循环
                    dp[i][j] = 1;
                    for (int k = 1; k < j; k++) {
                        if (b[k] < b[j]) {
                            dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + 1);
                        }
                    }
                }
            }
        }
        for (int i = 1; i <= n; i++) res = Math.max(res, dp[n][i]);
        System.out.println(res);
    }
}
```



**二维优化**

我们发现在 $j$ 每次移动时，我们都要从头开始计算 $dp[i - 1] [k]$的最大值

我们发现只有当 $a[i]==b[j]$ 的时候，$f[i][j]$才会被更新,而( $b[k]<b[j]$ )可以替换为（ $b[k]<a[i]$ )
观察k循环这一层，其实就是处理了一个$f[i][j]$前缀的问题，真正被用到的也只有那个最大的$f[i][j]$而已，所以我们可以用一个变量来存储这个前缀并在符合条件（$b[k]<a[i]$)的时候更新即可，这样就优化掉一层循环。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] a = new int[n + 1];
        int[] b = new int[n + 1];
        for (int i = 1; i <= n; i++) a[i] = read.nextInt();
        for (int i = 1; i <= n; i++) b[i] = read.nextInt();
        
        int[][] dp = new int[n + 1][n + 1];
        int res = 0;
        
        for (int i = 1; i <= n; i++) {
            int max = 0;
            for (int j = 1; j <= n; j++) {
                if (a[i] != b[j]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i][j], max + 1);
                }
                if (b[j] < a[i]) {
                    max = Math.max(max, dp[i - 1][j]);
                }
            }
        }
        for (int i = 1; i <= n; i++) res = Math.max(res, dp[n][i]);
        System.out.println(res);
    }
}
```



## 二维平面

### 滑雪

#### 题目描述

[AcWing901. 滑雪](https://www.acwing.com/problem/content/description/903/)

给定一个 $R$ 行 $C$ 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 $i$ 行第 $j$ 列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。

在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

**输入格式**

第一行包含两个整数 $R$ 和 $C$。

接下来 $R$ 行，每行包含 $C$ 个整数，表示完整的二维矩阵。

**输出格式**

输出一个整数，表示可完成的最长滑雪长度。

**数据范围**

$1≤R,C≤300$
$0≤矩阵中整数≤10000$

**输入样例：**

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**输出样例：**

```
25
```

#### 题解

**记忆化搜索**

四个方向深搜

![image-20220408224905007](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220408224905007.png)

```java
import java.util.Scanner;

/**
 * @author novo
 * @date 2022/4/8-21:38
 */
public class Main {
    static int[][] memory;
    static int[][] nums;
    static int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    static int m;
    static int n;

    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        m = read.nextInt();
        n = read.nextInt();
        nums = new int[m][n];
        memory = new int[m][n];
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                nums[i][j] = read.nextInt();
                memory[i][j] = -1;
            }
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                res = Math.max(res, dfs(i, j));
            }
        }

        System.out.println(res);
    }

    private static int dfs(int x, int y) {
        if (memory[x][y] == -1) {
            // 注意赋初始值
            memory[x][y] = 1;
            for (int[] direct : directs) {
                int newX = x + direct[0];
                int newY = y + direct[1];
                if (inArea(newX, newY) && nums[x][y] > nums[newX][newY]) {
                    memory[x][y] = Math.max(memory[x][y], dfs(newX, newY) + 1);
                }
            }
        }
        return memory[x][y];
    }

    private static boolean inArea(int x, int y) {
        return x >= 0 && x < m && y >= 0 && y < n;
    }
}
```

