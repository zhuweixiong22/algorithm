

# 对数器



# 二分查找

- 在一个有序数组中，找到某个数是否存在
- 在一个有序(升序)数组中，找 >= 某个数最左侧的位置
- 在一个有序(升序)数组中，找 <= 某个数最右侧的位置
- 局部最小值问题



### 局部最小值问题

二分不一定要有序：数据状况特殊，问题特殊，只要能找出数据的排他性，有一半数据肯定有，另一半数据不确定，那就可以砍一半用二分。

给出一个无序且相邻两个数不相等的数组，找出一个局部最小数（找谷底）

给出局部最小定义：

[0]位置时，只要[0] < [1]，那么[0]就是局部最小

[N - 1]位置时，只要[N - 2] > [N - 1]，那么[N - 1]就是局部最小

[i]位置(不在0和N - 1)，需要[i - 1] > [i] < [i + 1]



先特判两个边界，若找到了其中一个就返回

若找不到，则说明左边界单调递减，右边界单调递增，所以1 ~ N - 2 间一定会有最小值

![image-20220123214403131](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123214403131.png)

二分找中间，如果此时找到了直接返回

![image-20220123214955679](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123214955679.png)

若找不到，则有三种情况单调递增、单调递减和i为局部最大，无论哪种情况都至少存在一个区域可以继续二分找出局部最小值。

![image-20220123215200995](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215200995.png)

![image-20220123215328950](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215328950.png)

![image-20220123215406873](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215406873.png)



# 位运算



异或定义：无进位相加

性质

- 0 ^ N == N
- N ^ N == 0
- 满足结合律和交换律，所以同一批数异或，无论是什么顺序，结果唯一



### 1、如何不用额外空间交换两个数

```java
a = a ^ b;
b = a ^ b; //证明：b = a ^ b ==> (a ^ b) ^ b ==> a ^ (b ^ b) ==> a ^ 0 ==> a
a = a ^ b; //证明：a = a ^ b ==> (a ^ b) ^ a ==> (a ^ a) ^ b ==> 0 ^ b ==> b
```

**注意前提是：a和b在内存中的位置不相等(即a和b有各自独立的内存区域,a和b的值可以一眼)，如果a和b指向同一块内存，执行三行代码后会变成0**



### 2、一个数组中有一个数出现了奇数次，其余数均出现偶数次，打印出出现奇数次的数

例：[4,3,4,2,4,3,1,2,1,1,1,3] 打印出4

普通方法：哈希表

异或运算：

只需要定义一个XOR初始值为0，XOR遍历数组异或每一个数，即`XOR = XOR ^ arr[i];或 XOR ^= arr[i] `或最终得到的结果就是所求值。

证明：同一批数异或，无论是什么顺序，结果唯一，

所以最终结果可以写成=XOR ^ (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (4 ^ 4 ^ 4)

因为偶数个本身异或为0，所以只剩下 4 ^ 4 ^ 4 ==> 0 ^ 4 ==> 4



### 3、怎么把一个int类型的数，提取出最右侧的1(二进制)

例：    1100100

得到：0000100

求补运算：找到最近的1，后面的全部取反

那我们将 **a**与**求补后的a** 做**与运算**，就能得到结果，因为a[原]和a[补]在最近1后面的数都相反，在最近1前面的数都为0。

注意：因为在计算机中的运算都是以补码进行运算，所以上面的参与运算的a实际上是a[补]，对a[补]求补就是[-a]补，所以在编程上求补运算就是求相反数也等于 ~a + 1

```java
//正数
12
原码：0000 1100
补码：0000 1100
补码再求补：
     1111 0100 
原码：1000 1100  (十进制：-12)
即 ~12=-12
//负数
-12
原码：1000 1100
补码：1111 0100
补码再求补：
     0000 1100 
原码：0000 1100  (十进制：12)
即 ~12=12
```



### 4、一个数组中有两种数出现了奇数次，其它数均出现偶数次，找到并打印出这两种数

假设两种数分别为a，b

1、定义XOR1 == 0，对这批数连续异或赋值给XOR1，最后结果为XOR1 == a ^ b

又因为a != b (两种数) ，所以XOR1 != 0，==> XOR1的二进制数中肯定有1

2、我们随便取出XOR其中一个位置的1(比如取最右侧的1)定义为onlyOne

用该位置(onlyOne)是否为1**划分出两组数**，**目的是将a、b分离**，a、b必然不在同一组(因为在该位置异或为1)

```java
//用与运算判断，因为onlyOne只有一个1，所以与运算结果要么为0，要么不为0(具体值不确定)
if ((arr[i] & onlyOne) != 0)// 说明该位置有1
if ((arr[i] & onlyOne) == 0)// 说明该位置无1
```

3、再定义一个XOR2  == 0，对其中一组数连续异或赋值给XOR2，最终结果就为a或b

因为无论在哪一组数中除了a或b其余数都为偶数个

4、知道a或b其中一个了，XOR1 ^ XOR2 就是另一个数，如XOR2 == a,XOR1 ^ XOR2 == a ^ b ^ a == b  



### 5、一个数组中有一种数出现K次，其余数均出现M次且M > 1,K < M,找出出现K次的数

要求，空间复制度O(1)，时间复杂度O(N)

假设是int型的数(二进制32位)

1、开辟一个大小为32的count数组去存储该数组所有数二进制每一位的状态

即将所有数的二进制进行算术运算相加（例1+1=2），最终count每一位都记录着数组二进制和中对应位为1的次数

```java
arr：[18,10,10,11,11] K == 1,M == 2
10		00...001100
10		00...001100
11		00...001101
11		00...001101
18		00...010010
count  [00...014412]
```

就会发现count[i]%M == 0的位置18的二进制数必为0,因为是M的倍数，又K<M

所以只要count[i]%M != 0的位置18二进制数为1,我们把这些位置全找出来，所求数就确定了

2、如何存储

```java
//二重循环，将arr中每一个num的每一位依次累加到count数组
//虽然是两个for，但是内循环次数确定(32)，所以是O(N)
for (int num : arr) {
    for (int i = 0; i < 32; i++) {
	  /*if (((num >> i) & 1) != 0) { // 与1(00...001)进行与运算不等于0说明比较的第i位为1,就累加
              count[i]++;
		}*/
        // 优化版本 (count[i] >> i)为0的时候再与1 相当于+0 等于不累加
        count[i] += ((num >> i) & 1);
    }
}
```

3、把count数组还原为对应的值

就是将符合条件的位置上填1的过程

```java
int res = 0;
for (int i = 0; i < 32; i++) {
	if ((count[i] % m) != 0) { // 说明i位上 出现k次那个数的二进制数不为0(即为1)
		res |= (1 << i); // 0依次或上第i位上的1 从右至左在符合条件的位置上填1
	}
}
```



# 数据结构

## 链表

### 1、单双链表反转

```java
ListNode<T> pre = null;
ListNode<T> cur = head;
ListNode<T> next = null;
while (cur != null) {
    next = cur.next; //记录next
    cur.next = pre; // 当前next指向pre
    pre = cur; // 将当前节点设置为pre
    cur = next;// cur后移
}
return pre;
```

```java
DoubleListNode<T> pre = null;
DoubleListNode<T> cur = head;
DoubleListNode<T> next = null;
while (cur != null) {
    next = cur.next; // 记录next
    cur.next = pre; // 修改cur的pre和next 顺序无所谓
    cur.pre = next; // 因为将cur.next保存给next了 所以先反转pre还是next的顺序无所谓
    pre = cur; // 将当前节点设置为pre
    cur = next; // cur后移 等价于cur = cur.pre 反转前的next值
}
return pre;
```



### 2、删除单链表中给定值并返回新的head



### 3、双链表实现双端队列、队列、栈



## 队列和栈

### 4、数组实现队列和栈

### 5、最小栈设计

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

1、创建两个栈，一个数据栈，一个最小栈，最小栈的栈顶为最小值

2、怎么维护最小栈的栈顶为元素最小值

- 第一种方法：

  入栈情况：

  - 当最小栈为空，第一个进入的元素就进最小栈（数据栈正常入栈）
  - 当最小栈不为空，且入栈的元素**小于等于**最小栈栈顶，才进入最小栈（数据栈正常入栈）

  出栈情况：

  - 当数据栈出栈的元素等于最小栈栈顶时，最小栈同时出栈，否则只有数据栈出栈

- 第二种方法：

  入栈情况：

  - 数据栈和最小栈同步入栈，但是只有入栈元素小于最小栈栈顶时，才将该元素入最小栈，否则将最小栈栈顶入最小栈

  出栈情况：

  - 同步出栈

> 注意第一种方法，等于的时候也要入最小栈的，因为数据栈肯定是要正常入栈的，当这个元素出栈时最小栈也要出栈，而此时数据栈有重复的元素，最小栈只有一个，会出错。



### 6、用队列实现栈

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

两个队列实现：

1、将原队列的元素导入另一个辅助队列直到只剩下一个元素，输出

2、将两队列地址互换，改变输入的队列

3、重复上述过程

![image-20220125183527993](https://gitee.com/iamnovo/pic/raw/master/images/image-20220125183527993.png)



一个队列实现：

只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

![image-20220125184034130](https://gitee.com/iamnovo/pic/raw/master/images/image-20220125184034130.png)





### 7、用栈实现队列

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 必须是popStack为空才能倒数据
- 如果导数据，必须从pushStack一次性倒完

只要满足上面两个要求，导数据的时机什么时候都可以，可以在每次push操作后，也可以在每次pop或peek的时候导，或者push和pop操作都导。



## 哈希表

增删改查复杂度都认为是O(1)，但是这个常数级别有点大

哈希表存入非基础数据类型占用内存非常小，只会记录引用值，不会复制值

```java
Integer a = 1111111111;
Integer b = 1111111111;
Student student1 = new Student(2);
Student student2 = new Student(2);
HashMap<Student,String> map1 = new HashMap<>();
HashMap<Integer,String> map = new HashMap<>();

// 基础数据类型的包装类且范围不在常量池，存放在哈希表中时，根据值匹配，属同一对象。
map.put(a,"我是a");
System.out.println(map.containsKey(b));

// 非包装类的引用类型，存放在哈希表中时，根据引用值匹配，不属同一对象。
map1.put(student2,"student2");
System.out.println(map1.containsKey(student1));
```



## 有序表

TreeMap 有序表 只是一个接口

能实现有序表的：红黑树、AVL树、SBT(Size Balanced Tree)、跳表

增删改查时间复杂度都是O(logN),功能比有序表强大

Java中TreeMap是用红黑树实现的



非数值类型和String类型传入TreeMap需要自己定义比较器，否则会报错

当排序规则比较简单时，可以使用lambda表达式实现比较器

```java
//
TreeMap<Student, String> treeMap = new TreeMap<>(
                (stu1, stu2) -> !stu1.getId().equals(stu2.getId()) ? 
                        stu1.getId() - stu2.getId() : stu2.getAge() - stu1.getAge());
//
TreeMap<Student, String> treeMap = new TreeMap<>((stu1, stu2) -> stu1.getId() - stu2.getId());
// IDEA推荐写成这样
TreeMap<Student, String> treeMap = new TreeMap<>(Comparator.comparingInt(Student::getAge));
```

> 注意TreeMap一般情况下是不允许存放重复元素的，所以当传进来的比较器只比较id的话，treemap会认为相同age的student是同一个元素（即使两个student对象不一样），只会存进去一个student

解决方法，如果age相等的话，再比较内存地址（hashCode也可能重复），就能保证age相等的不同样本都留下来



# 递归

逻辑图：树状

实际结构：压栈

时间复制度分析

master定理：

(只针对递归问题子规模一致的时候使用)

![image-20220126141702793](https://gitee.com/iamnovo/pic/raw/master/images/image-20220126141702793.png)

n/b 是递归子问题的规模，a是一次方法中调用递归的次数，f(n)是非递归的操作，用O(N^d)来表示非递归的时间复杂度
$$
当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(N^{\log_{b} {a}})\\
1) \log_{b} {a} < d ---> 复杂度为O(N^d)\\

2) \log_{b} {a} > d --> 复杂度为O(N^{\log_{b} {a}})\\

3) \log_{b} {a} = d ----> 复杂度为O(N^d*{\log_{}{N}})\\
$$



# 排序

## 比较器

实现Comparator< T>接口，调用系统一些容器的sort的函数时，把比较器传进去

```java
public static class IdAscendingComparator implements Comparator<Student> {
    // 返回负数的时候，第一个参数排在前面
    // 返回正数的时候，第二个参数排在前面
    // 返回0的时候，两个参数等级相等
    @Override
    public int compare(Student o1, Student o2) {
        //return o1.getId() - o2.getId();
        //return o2.getAge() -o1.getAge();
        // id升 如果id相等 比较age 降序
        return !o1.getId().equals(o2.getId()) ? o1.getId() - o2.getId() : o2.getAge() - o1.getAge();
    }
}
//
list.sort(new IdAscendingComparator());
Arrays.sort(students, new IdAscendingComparator());
```



## 归并排序

**平均时间复杂度： O(NLogN) **

**最好情况时间复杂度： O(NLogN)**

**最差情况时间复杂度： O(NLogN)**

**所需要额外空间： 递归：O(N + LogN)， 非递归：O（N）**

**稳定性： 稳定**

归并排序基于**分治**（快排也是）

归并排序其实要做两件事：

（1）“分解”——将序列每次折半划分。

（2）“合并”——将划分后的序列段两两合并后排序。



### 1、数组小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子
[1,3,4,2,5]
1左边比1小的数：0
3左边比3小的数：1
4左边比4小的数：1,3
2左边比2小的数：1
5左边比5小的数：1,3,4,2
所以小和为1+1+3+1+1+3+4+2=16

**转换思想：每一个数左边比当前数小的数累加-->如果a右边的数有多少个数比a大，就产生多少个a**

![image-20220126214210314](https://gitee.com/iamnovo/pic/raw/master/images/image-20220126214210314.png)

例 原数组[3,2,4,1,5,6,3,0]的归并过程：

我们从2这一个数的视角，来感受求该数小和的过程

- 步长为1：

  3,2是作为准备merge后的大组，而2作为里面的右组，是不会产生小和的，但2作为左组例[2,3]和[1,4]merge的时候才会去跟右组[1,4]比较产生小和

- 步长为2：

  [2,3]和[1,4]merge，此时2作为左组，与右组的数比较，有一个4比2大，产生一个2

- 步长为4：

  [1,2,3,4]和[0,3,5,6]merge，2作为左组，与右组的数比较，3、5、6都比2大，产生三个2

- 步长为8：归并结束，上述过程一共产生四个2，所以2右边一共是有四个数比2大的，需要累加四次2

**merge过程中p2移动的方向，如果是升序，p2就从左往右移动，比较一次的前提下才能知道有多少个数比a大**




### 2、数组中逆序对个数

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

同上面一道题，转换为**-->如果a右边的数有多少个数比a小，就产生多少个a**

不同的是p2移动的方向，如果是升序，p2就从右往左移动，比较一次的前提下才能知道有多少个数比a小

315（和本题一样）,327,493,



### 3、数组中x右边有多少个数*2后小于该元素的个数

求总个数

> 注意:这题看似和第二题没有什么区别，但是有个坑，第二题是直接比x小的个数，所以p1、p2指针是从右往左移动的，但是这题不可以，比如

![image-20220127160712721](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127160712721.png)



此时arr[p2] * 2  > arr[p1],我们希望p2继续像左检索寻找符合条件的数，但是又因为arr[p2]已经大于arr[p1]了，arr[p2]是要合并到mergeArr中的并且p1--，这种情况显然从右往左是不行的。

![image-20220127161006163](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127161006163.png)

解决方法一：从右往左

把记录题解的代码和merge的代码分离开，复制p1、p2指针，不要写在同一块里

```java
public static int merge(int[] arr, int L, int M, int R) {
    int[] mergeArr = new int[R - L + 1];
    int i = mergeArr.length - 1;
    int p1 = M;
    int p2 = R;
    int res = 0;
    int p3 = p1;
    int p4 = p2;
    // 记录题解
    while (p3 >= L && p4 > M) {
        if (arr[p3] > arr[p4] * 2) {
            res += p4 - M;
            p3--;
        } else {
            p4--;
        }
    }
    // 正常merge
    while (p1 >= L && p2 > M) {
        mergeArr[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
    }
    while (p1 >= L) {
        mergeArr[i--] = arr[p1--];
    }
    while (p2 > M) {
        mergeArr[i--] = arr[p2--];
    }
    for (i = 0; i < mergeArr.length; i++) {
        arr[L + i] = mergeArr[i];
    }
    return res;
}
```

解决方法二：从左往右

![image-20220127163807301](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127163807301.png)



从左往右，此时右边没有数 * 2 < arr[p1], 数量为0，p1右移至4，p2右移至arr[p2] * 2 不小于arr[p1]的地方，则满足条件的元素有p2 - M个

> p2是不用后退的，因为是升序，既然arr[p1] > arr[p2] * 2，所以有arr[p1 + n] > arr[p2] * 2 (n > 0)

![image-20220127164125900](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127164125900.png)



### 总结

**指针不回退的本质就是单调性**

本质就是mergeSort过程把比较信息变成了有序的，从而加快我们求解

归并升序的情况：

数组中求x右边的情况：相等的时候merge过程就先拷贝右边的，因为我们是想知道x右边数的状况，所以我们需要先移动右组的指针

求右边多少个数比x小，就从右往左merge

求右边多少个数比x大，就从左往右merge



### 4、区间和的个数

[区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

前缀和+归并排序



> 注意：
>
> 前缀和头部插入值为 0 的元素，可简化边界处理
>
> 前缀和数组不是递增的，因为可能有负数

设区间和表示为Aij, 前缀和表示为Si

假设Sj已知

求以j位置结尾的子数组区间和有多少个落在[lower,uppper]上

==> lower <= Aij <= upper

==> lower <= Sj - Si-1 <= upper

==> Sj - upper <= Si-1 <= Sj - lower

因为i <= j （区间长度可以为1）

也就是说我们只需要求在j之前有多少个前缀和落在这个区间上

所以现在我们只需要用到前缀和数组，原数组已经没有用了



## 快速排序

注意边界问题

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    process(arr, 0, arr.length - 1);
}
public static void process(int[] arr, int L, int R) {
    // 注意边界i 有可能跨过去右边
    if (L >= R) {
        return;
    }
    int i = L - 1;
    int j = R + 1;
    int pivot = arr[L + ((R - L) >> 1)];
    while (i < j) {
        do i++; while (arr[i] < pivot);
        do j--; while (arr[j] > pivot);
        if (i < j) {
            swap(arr, i, j);
        }
    }
    // 因为i可能先跨过去,因为do是i操作先 所以跨过去的i位置是没有验证的
    // 而j++是后do的 退出while时j的位置一定是被验证过的
    // 左递归只能穿[L i-1] 或者[L   j]
    // 右递归只能传[i   R] 或者[j+1 R]
    process(arr, L, j);
    process(arr, j+1, R);
}
```



## 堆排序

**堆（优先队列）：**

大根堆：满足根结点>子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

小根堆：满足根结点<子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

完全二叉树：

> **i 结点的左孩子：2 * i + 1，i 结点的右孩子2 * i+2 ，i 结点的父结点 (i - 1)/2 下取整**



**建堆**

如果数据是一次传进来的，可以从下往上建堆，建堆的时间复杂度是可以达到O(N)的

> 分析一下复杂度，因为堆的叶子结点有N / 2个，叶子结点的下沉成本距离为1,只会进行一次while判断,
>
> 叶子结点的上一层有N / 4 个，下沉成本为2，以此类推，下沉成本和深度有关,设有4层
>
> 总下沉成本T(N) = N/2 * 1 + N/4 * 2 + N/8 * 3 + N/16 * 4
>
> ​          2T(N) = N + N/2 * 2 + N/4 * 3 + N/8 * 4
>
> 相减=>T(N) = N + N/2  + N/4  ...  - N/16 显然时间复杂度为O(N)

```java
for (int i = arr.length - 1; i >= 0; i--) {
    // 从下往上建堆 不断调用heapify调整下沉
	heapify(arr, i, arr.length);
}
```



如果数据是一个一个传进来的，只能从上往下建堆，时间复制度O(N*logN)

```java
for (int i = 0; i < arr.length; i++) {
    // 从上往下建堆 不断调用heapInsert调整上浮
	heapInsert(arr, i);
}
```



**维护堆**

堆排序

堆排序额外空间复杂度O(1)

排序过程O(N*logN)

```java
public static void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 建堆的过程
    /*// 从上往下建堆 逐个读入O(logN)
    for (int i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }*/
    // 从下往上建堆 一次读入 O(N)
    for (int i = arr.length - 1; i >= 0; i--) {
        heapify(arr, i, arr.length);
    }
    int heapSize = arr.length;
    
    // 堆排序的过程 靠首尾交换取得最大值从而手动打乱堆 再调用heapify来不断维护 不断获得最值
    swap(arr, 0, --heapSize);
    while (heapSize > 0) {
        heapify(arr, 0, heapSize);
        // 交换后堆大小减一 是逻辑删除该值
        swap(arr, 0, --heapSize);
    }
}
```



### 1、对一个几乎有序的数组进行排序

几乎有序是指，如果把数组排好序，每个元素师移动的距离一定不超过k，并且k大小相对数组长度是较小的，设置合适的排序策略。

使用长度为k + 1的堆来维护存放每个位置上可能出现的元素

例如设k = 5，排序后索引为0的位置的元素只可能是原数组中索引为[0-5]的位置

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
        if (k == 0) {
            return;
        }
        // 默认小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        int index = 0;
        // k如果大于数组长度，则都放进堆里
        // 先放k + 1个数进入堆
        for (; index < Math.min(arr.length, k); index++) {
            heap.add(arr[index]);
        }
        int i = 0;
        // 弹出堆顶 放入一个 直到数组中所以元素都进入到堆中
        for (; index < arr.length; i++, index++) {
            heap.add(arr[index]);
            arr[i] = heap.poll();
        }
        // 弹出堆中所有元素
        while (!heap.isEmpty()) {
            arr[i++] = heap.poll();
        }
    }
```



### 2、最大线段重合问题

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

类似[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)



定义：一条线段尾坐标 == 另一条线段头坐标不算有交集(只有一个点重合)

两条不同线段，如果一条线段尾坐标  > 另一条线段头坐标，说明这两条线段有交集

1、将所有线段按头坐标从小到大排序

**借助小根堆存储线段的尾坐标**

2、从小到大遍历每条线段，比较**遍历到的线段**和**小根堆内的尾坐标**，**将小根堆中 <= 该线段的头坐标移除**(说明当前线段与移除的掉的线段没有交集)，**小根堆剩下的尾坐标个数就为与该线段有交集的个数（除去本身）**，**切换到下一线段前，将自身尾坐标加入小根堆**

> 如果求的是有多少条线段重合，则先把自身加入，小根堆的当前的个数就是有多少条线段重合





# 链表

### 1、回文链表

[剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

一般解法借助容器类如栈

最优解：

**快慢指针+反转链表**



注意的点：

1、是不用判断奇偶的，因为右链表总是小于等于左链表，while以数量小的那个判空停下就行，因为如果是奇数，中间那个数是不用比较的。

2、判断快慢指针越界的时候，不仅仅要判faster.next.next,  faster.next也要判空 否则会空指针

3、如果要还原链表，需要复制一个指针，不能直接用reverse 会被改变

```java
// 快慢指针
public static boolean isPal2(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    // 1 快慢指针找中点
    ListNode faster = head.next; //简化边界问题
    ListNode slower = head;
    // 快慢指针 快2倍 如果奇数个 while停下 慢指针指向中点
    // 如果偶数个 慢指针指向第一个中点
    // 这里注意faster.next也要判空 否则会空指针 只需要判快指针
    while (faster != null && faster.next!= null ) {
        faster = faster.next.next;
        slower = slower.next;
    }
    boolean res = true;
    // 2 反转右链表对比
    ListNode reverse = reverse(slower.next);
    // 如果要还原链表的话不能直接用reverse 会被改变
    ListNode temp = reverse;
    while (temp != null) {
        if (temp.data != head.data) {
            res = false;
            break;
        }
        temp = temp.next;
        head = head.next;
    }
    // 3 还原链表
    slower.next = reverse(reverse);
    return res;
}

public static ListNode reverse(ListNode head) {
    ListNode next = null;
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 2、复杂链表的复制

[剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

一般解：哈希表

最优解：

使用哈希表能解决的原因是，我们可以得到原结点和副本的一一对应结构，只要我们人为去构造这种对应的结构就不需要哈希表。

1、在每个原结点后复制出一个新的

2、一对一对（origin + copy）的遍历 添加副本结点的random指针

3、分离原结点和副本

```java
public Node copyRandomList(Node head) {
    // 这个是有必要的 否则下面的Node copyHead = head.next可能会空指针
    if (head == null) {
        return null;
    }
    Node cur = head;
    Node next = null;
    // 1 在每个原结点后复制出一个新的
    while (cur != null) {
        next = cur.next;
        // copy = cur.next; copy.next = next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }
    // 一对一对（origin + copy）的遍历 添加副本结点的random指针
    cur = head;
    Node curCopy = null;
    // 这里为什么不用判cur.next != null 是因为cur.next是cur的副本 只用判cur就可以了
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        // cur.random是原结点的random 我们通过它获取cur.random的副本 而副本是接在原结点后面的
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node copyHead = head.next;
    // 分离原结点和副本
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = curCopy.next;
        // 要特殊处理一下最后一个结点next为空 next.next会报错
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return copyHead;
}
```

对最后一个结点进行操作的时候需要特判一下next为不为空

![image-20220129231741596](https://gitee.com/iamnovo/pic/raw/master/images/image-20220129231741596.png)

### 3、相交链表(有环无环)

#### 题目描述

给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 

【要求】 如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。



#### 题解

这应该是链表里最难的题目之一了，一道题里组合了环形链表和普通相交链表

分析一下题目的可能性：

一共有五种可能性：

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220202221828729.png)

```java
// 主方法
public static ListNode isIntersection(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode loopA = findLoopNode(headA);
    ListNode loopB = findLoopNode(headB);
    // 两个无环链表相交问题
    if (loopA == null && loopB == null) {
        return getIntersectionNoLoop(headA, headB);
    }
    // 两个有环链表相交问题
    if (loopA != null && loopB != null) {
        return getIntersectionAllLoop(headA, loopA, headB, loopB);
    }
    // 一个有环 一个无环 必不相交
    return null;
}

// 判断链表是否有环，有则返回入环点，无则返回null
public static ListNode findLoopNode(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null && faster != slower) {
        faster = faster.next.next;
        slower = slower.next;
    }
    if (faster == null || faster.next == null) {
        return null;
    }
    slower = slower.next;
    faster = head;
    while (faster != slower) {
        faster = faster.next;
        slower = slower.next;
    }
    return faster;
}

// 求两个有环链表相交问题 如果相交求出交点
public static ListNode getIntersectionAllLoop(ListNode headA, ListNode loopA, ListNode headB, ListNode loopB) {
    ListNode curA = headA;
    ListNode curB = headB;
    // 入环点一样 那么入环点之前的情况跟无环链表一样
    if (loopA == loopB) {
        while (curA != curB) {
            // 不让指针走入环内
            curA = (curA != loopA) ? curA.next : headB;
            curB = (curB != loopA) ? curB.next : headA;
        }
        return curA;
    }
    // 入环点不一样 即相交点就等于入环点 随便返回一个
    return loopA;

}

// 求两个无环链表相交问题 如果相交求出交点
public static ListNode getIntersectionNoLoop(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode curA = headA;
    ListNode curB = headB;
    while (curA != curB) {
        curA = (curA != null) ? curA.next : headB;
        curB = (curB != null) ? curB.next : headA;
    }
    return curA;
}

// 测试样例 for test
public static void main(String[] args) {
    // 1->2->3->4->5->6->7->null
    ListNode head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);

    // 0->9->8->6->7->null
    ListNode head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

    // 1->2->3->4->5->6->7->4...
    head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);
    head1.next.next.next.next.next.next = head1.next.next.next; // 7->4

    // 0->9->8->2...
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next; // 8->2
    System.out.println(isIntersection(head1, head2).val);

    // 0->9->8->6->4->5->6..
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

}
```





### 4、链表排序



# 二叉树

### 1、遍历

### 2、序列化与反序列化

### 3、二叉树的最大宽度

### 4、二叉树层序遍历进阶

#### 问题描述

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```



#### 题解

层序遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> levelList;
    if (root == null) {
        return res; 
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    int levelCount = 0;
    while (!queue.isEmpty()) {
        levelList = new ArrayList<>();
        levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 记录每一层的信息
        res.add(levelList);
    }
    return res;
}
```



总结：最大宽度和该题都是**层次划分**的套路，每次while循环记录一下levelCount，按levelCount在里面for循环遍历即可

### 5、树与二叉树的转化

### 6、折痕问题

#### 题目描述

```java
* 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。
* 此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。
* 如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，
* 从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，
* 请从上到下打印所有折痕的方向。 例如：
* N=1时，
* 打印： down
* N=2时，
* 打印： down down up
```



#### 题解

```java
/**
 * 实际上就是一颗二叉树 折痕当做结点
 * 该树的特点 树的根节点是凹 左孩子结点为凹 右孩子结点为凸
 * 用 i 表示层数 如果是纸条从上往下打印 就是中序遍历
 * @param N
 */
public static void printAllFolding(int N) {
    inOrder(1, N, true);
}

public static void inOrder(int i, int N, boolean isDown) {
    if (i > N) {
        return;
    }
    inOrder(i + 1, N, true);
    System.out.print(isDown ? "第" + i + "次凹 " : "第" + i + "次凸 ");
    inOrder(i + 1, N, false);
}
```



### 7、二叉树完全性检验

#### 题目描述

[958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

给定一个二叉树的 `root` ，确定它是否是一个 *完全二叉树* 。

在一个 **[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)** 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 `1` 到 `2h` 节点之间的最后一级 `h` 。

 

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/complete-binary-tree-1.png)

```
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
```

**示例 2：**

**![](https://gitee.com/iamnovo/pic/raw/master/images/complete-binary-tree-2.png)**

```
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
```

 

#### 题解

层序遍历框架改写加两个原则：

- 有右孩子但是没有左孩子，必不为完全二叉树
- 某一层中若出现某结点的子树不全(只有一个孩子或者没有孩子)，则剩下结点若不都是叶子结点，必不为完全二叉树

层序遍历完全，若不违反上面两个原则，则为完全二叉树

```java
public static boolean isCompleteBTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    // 是否有孩子不全的结点
    boolean isNotFullChild = false;
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    while (!queue.isEmpty()) {
        cur = queue.poll();

        // 第一种情况：有孩子不全的结点出现且后面结点不都为叶子结点
        // 第二种情况：右子树为空且左子树不为空
        if ((isNotFullChild && (cur.left != null || cur.right != null))
                || (cur.right != null && cur.left == null)) {
            return false;
        }

        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }

        // 第一次出现孩子不全的结点，进行标记
        // 标记一定要在最后进行，因为我们判断的是之后的结点是否都为叶子结点，
        // 如果if放在前面会出现把自己标记，又拿自己参与判断的情况
        if (cur.left == null || cur.right == null) {
            isNotFullChild = true;
        }

    }
    return true;
}
```



### 8、二叉树平衡性校验

#### 题目描述

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![](https://gitee.com/iamnovo/pic/raw/master/images/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```



#### 题解

虽然不是最优解，但是是比较容易理解的自顶向下递归方式

1. **找整个递归的终止条件：递归应该在什么时候结束？**
2. **找返回值：应该给上一级返回什么信息？**
3. **本级递归应该做什么：在这一级递归中，应该完成什么任务？**

我们只需要关心最顶层的递归需要做什么才能得到答案

判断一颗二叉树是否为平衡二叉树的条件：

- 左子树为平衡二叉树
- 右子树为平衡二叉树
- 左右子树的高度差不大于1

上面三个条件只要满足了，整颗二叉树就是平衡二叉树

那我们只需要每次递归中返回子树的两个信息：是否为平衡二叉树和最深深度

将这两个信息进行处理就能得到答案

```java
public static class Info{
    public boolean isBalanced;
    public int depth;
    public Info(boolean isBalanced,int depth) {
        this.isBalanced = isBalanced;
        // 深度
        this.depth = depth;
    }
}
public static boolean isBalanced(TreeNode root) {
    return process(root).isBalanced;
}
public static Info process(TreeNode root) {
    // 为空 递归结束 返回信息
    if (root == null) {
        return new Info(true,0);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean isBalanced = true;
    // 子树中最深的一条路径 + 1 就是root的最深路径
    int depth = Math.max(leftInfo.depth,rightInfo.depth) + 1;
    // 不同时满足三个条件的root就不是平衡二叉树
    if (!leftInfo.isBalanced || !rightInfo.isBalanced
            || Math.abs(leftInfo.depth - rightInfo.depth) > 1) {
        isBalanced = false;
    }
    return new Info(isBalanced,depth);
}
```



### 9、二叉树直径

#### 题目描述

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。



#### 题解

DFS求左右子树的最深路径，左右子树最深路径之和的最大值就是直径

```java
private int res = 0;
public int diameterOfBinaryTree(TreeNode root) {
    process(root);
    // 注意是返回res 不是process的返回值
    return res;
}
public int process(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = process(root.left);
    int rightDepth = process(root.right);
    res = Math.max(res, leftDepth + rightDepth);
    // 返回左右子树的最深一条路径 加上来自己的一个距离
    return Math.max(leftDepth, rightDepth) + 1;
}
```

比如对于4来说，它的左右子树最深路径都为0，返回的时候要加上来4的一个距离

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220201214320795.png)

整棵树的其中一个直径就是1的左子树2的最深路径加上1的右子树3的最深路径

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220201214638741.png)



### 10、满二叉树检验

#### 问题描述

```
对于满二叉树的定义，国内外不一样
* 国内：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
* 国外：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。
* 这里算法按照国内的来
```

所以满二叉树满足    结点数= 2 ^ 二叉树的深度 - 1，

我们只需要返回每棵子树的结点数和深度就可以进行递归判断

#### 题解

```java
public static class Info {
    public int depth;
    public int nodes;

    public Info(int depth, int nodes) {
        this.depth = depth;
        this.nodes = nodes;
    }
}

public static boolean isFullBTree(TreeNode root) {
    Info rootInfo = process(root);
    //return Math.pow(2, rootInfo.depth) - 1 == rootInfo.nodes;
    // 次方可以用位运算
    return (1 << rootInfo.depth) - 1 == rootInfo.nodes;
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(0, 0);
    }

    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);
    int curDepth = Math.max(leftInfo.depth, rightInfo.depth) + 1;
    int curNodes = leftInfo.nodes + rightInfo.nodes + 1;
    return new Info(curDepth, curNodes);
}
```



### 11、二叉搜索树检验

#### 问题描述

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/BSTree.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://gitee.com/iamnovo/pic/raw/master/images/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`



#### 题解

思路一，可以用中序遍历验证是否升序

思路二，递归

**容易理解的递归**

- root的左子树满足二叉搜索树
- root的右子树满足二叉搜索树
- 左子树的最大值严格小于root.val且右子树的最小值严格大于root.val

**因为判断root == null 在递归中info比较难处理，那就换个思路，子树不为null才进入递归**

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return process(root).isBST;
}

public class Info {
    public int max;
    public int min;
    public boolean isBST;
    public Info(boolean isBST, int max, int min) {
        this.isBST = isBST;
        this.max = max;
        this.min = min;
    }
}

public Info process(TreeNode root) {
    Info curInfo = new Info(true, root.val, root.val);
    if (root.left != null) {
        Info leftInfo = process(root.left);
        if (!leftInfo.isBST || leftInfo.max >= root.val) {
            curInfo.isBST = false;
        }
        // 只需要在左子树更新最小值和在右子树更新最大值，就算出现了不是搜索子树导致更新最值不正确也没什么所谓，因为已经记录的false值了
        //curInfo.max = Math.max(leftInfo.max,root.val);
        curInfo.min = Math.min(leftInfo.min, root.val);
    }
    if (root.right != null) {
        Info rightInfo = process(root.right);
        if (!rightInfo.isBST || rightInfo.min <= root.val) {
            curInfo.isBST = false;
        }
        curInfo.max = Math.max(rightInfo.max, root.val);
        //curInfo.min = Math.min(rightInfo.min,root.val);
    }
    return curInfo;
}
```

个人比较习惯写法：

还是在递归里处理null

```java
public static Info process2(TreeNode root) {
    if (root == null) {
        return new Info(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process2(root.left);
    Info rightInfo = process2(root.right);
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    boolean curIsBST = false;
    if (leftInfo.isBST && rightInfo.isBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curIsBST = true;
    }
    return new Info(curIsBST, curMax, curMin);
}
```



### 12、最大二叉搜索树

#### 题目描述

leetcode333

给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。注意：子树必须包含其所有后代。

#### 题解

递归套路，自顶向下跟子树要信息

返回最大结点数量

```java
public static int findMaxSubBSTreeSize(TreeNode root) {
    /*if (root == null) {
        return 0;
    }*/
    return process(root).maxBSTSubTreeSize;
}

public static class Info {
    public boolean isAllBST;
    public int maxBSTSubTreeSize;
    public int max;
    public int min;

    public Info(boolean isAllBST, int maxBSTSubTreeSize, int max, int min) {
        this.isAllBST = isAllBST;
        this.maxBSTSubTreeSize = maxBSTSubTreeSize;
        this.max = max;
        this.min = min;
    }
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean curIsAllBST = false;
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    // 若左右子树都不存在搜索树 curMaxBSTSubTreeSize默认值就是1 自身一个节点（假定只有一个结点时也是二叉搜索树）
    int curMaxBSTSubTreeSize = 1;
    // 子树存在最大二叉搜索树，取其最大值
    if (leftInfo.maxBSTSubTreeSize != 0 || rightInfo.maxBSTSubTreeSize != 0) {
        curMaxBSTSubTreeSize = Math.max(leftInfo.maxBSTSubTreeSize, rightInfo.maxBSTSubTreeSize);
    }
    // 左右子树整颗都为二叉搜索树且满足左子树最大值 < root.val 右子树最小值> root.val
    // 更新curMaxBSTSubTreeSize 等于左+右+自身的一个节点
    if (leftInfo.isAllBST && rightInfo.isAllBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curMaxBSTSubTreeSize = leftInfo.maxBSTSubTreeSize + rightInfo.maxBSTSubTreeSize + 1;
        curIsAllBST = true;
    }
    return new Info(curIsAllBST, curMaxBSTSubTreeSize, curMax, curMin);
}
```

返回最大二叉搜索子树





### 13、公共祖先



# 并查集

### 1、省份数量

#### 题目描述



# 贪心

### 1、字典序排列最小的等效字符串

正确的贪心策略：字典序 ab < ba,而不是a < b

```java
public static String smallestString(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    Arrays.sort(strs, (String str1, String str2) -> (str1 + str2).compareTo(str2 + str1));
    StringBuilder res = new StringBuilder();
    for (String str : strs) {
        res.append(str);
    }
    return res.toString();
}
```



### 2、最多可以参加的会议数目

```java
public int maxEvents(int[][] events) {
    //首先排序：开始时间小的在前。这样是方便我们顺序遍历，把开始时间一样的都放进堆
    Arrays.sort(events, (o1, o2) -> o1[0] - o2[0]);
    //小顶堆
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    //结果、开始时间、events下标、有多少组数据
    int res = 0, last = 1, i = 0, n = events.length;
    while (i < n || !pq.isEmpty()) {
        //将start相同的会议都放进堆里
        while (i < n && events[i][0] == last) {
            pq.offer(events[i++][1]);
        }
        //pop掉当前天数之前的
        while (!pq.isEmpty() && pq.peek() < last) {
            pq.poll();
        }
        //顶上的就是俺们要参加的
        if (!pq.isEmpty()) {
            pq.poll();
            res++;
        }
        last++;
    }
    return res;
}
```



### 3、金条分割问题

最优二叉树(哈夫曼树)基于贪心算法

（1）准备一个小根堆。将数组放到这个小根堆里。

（2）每次弹出堆顶的两个数求和为A，将A再放回小根堆里。

（3）一直执行第2步，直到堆只剩一个数。最后，每一次第二步A的累加和即是最后的结果。

例如给定的金条长度为150，要分成10、20、30、40、50的块，最后花费的铜板数量即是上图中蓝色圆圈的和，即150+60+90+30=330。

也就是我们代码求解的时候是从叶子往根求的，求完后再从根往叶子即是金条的切割顺序，最后所有的叶子即是需要切成的块的大小。

```java
public static int splitGold(int[] arr) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int i : arr) {
        heap.add(i);
    }
    int payMoney = 0;
    int sum = 0;
    while (heap.size() > 1){
        sum = heap.poll() + heap.poll();
        payMoney += sum;
        heap.add(sum);
    }
    return payMoney;
}
```



### 4、IPO

#### 题目描述

[502. IPO](https://leetcode-cn.com/problems/ipo/)

假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。

最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。

答案保证在 32 位有符号整数范围内。

**示例 1：**

```
输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
```

**示例 2：**

```
输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
输出：6
```



#### 题解

优先队列+贪心



注意一点，启动资金是可以收回来的，所以在本题中项目不会亏本，那么只要**依次选启动资金低于本金里收益最大的项目**，就可以将收益最大化

**这种贪心符合人的思维，就是在能够做的项目里选择利润最大的去做，并不需要证明**

所以准备一个小根堆存入所有项目，从小根堆里取出当前启动资金可以做的所有项目放入另一个大根堆，这个堆按收益排序，这个大根堆堆顶就是一个局部最优，**做完一个项目后，需要更新最大利益堆**，因为此时本金已改变，可以做更多的项目

```java
public static class Project {
    int cost;
    int profit;

    public Project(int cost, int profit) {
        this.cost = cost;
        this.profit = profit;
    }
}

public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    PriorityQueue<Project> minCostHeap = new PriorityQueue<>((o1, o2) -> o1.cost - o2.cost);
    PriorityQueue<Project> maxProfitHeap = new PriorityQueue<>((o1, o2) -> o2.profit - o1.profit);
    // 将项目都加入最小成本堆
    for (int i = 0; i < profits.length; i++) {
        minCostHeap.add(new Project(capital[i], profits[i]));
    }
    for (int i = 0; i < k; i++) {
        // 项目不为空且最小成本堆顶的启动资金小于本金时，加入最大收益堆
        while (!minCostHeap.isEmpty() && minCostHeap.peek().cost <= w) {
            maxProfitHeap.add(minCostHeap.poll());
        }
        // 最大收益堆为空 说明本金w可能小于成本或者项目已经都做完，直接返回w
        if (maxProfitHeap.isEmpty()) {
            return w;
        }
        w += maxProfitHeap.poll().profit;
    }
    return w;
}
```



### 5、点灯问题

#### 题目描述

给定一个字符串str，只由‘X’和‘.’两种字符构成。‘X’表示墙，不能放灯，也不需要点亮。‘.’表示居民点，可以放灯，需要点亮。如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮。返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。



#### 题解

分情况讨论位置情况

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220203214705835.png)

如果i位置为墙，不放灯，i跳到下一位置

如果i位置为居民点，则往下判断i+1位置的情况，如果i+1为墙，那么灯只能放在i位置，i跳到i+2，如果i+1为居民点，那么继续往下判断i+2位置的情况，如果i+2为墙，灯放在i和i+1位置都可以，i跳到i+3，如果i+2位居民点，那么灯放在i+1位置，i跳到i+3

```java
public static int light(String road) {
    char[] str = road.toCharArray();
    int i = 0;
    int light = 0;
    while (i < str.length) {
        if (str[i] == 'X') {
            i++;
        } else {
            // 无论是那种情况此时必须放灯
            light++;
            if (i + 1 == str.length) {
                break;
            }
            // 有i+1位置的情况
            if (str[i + 1] == 'X') {
                i = i + 2;
            } else {
                i = i + 3;
            }
        }
    }
    return light;
}
```

