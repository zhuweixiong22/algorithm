

# 对数器



# 二分查找

- 在一个有序数组中，找到某个数是否存在
- 在一个有序(升序)数组中，找 >= 某个数最左侧的位置
- 在一个有序(升序)数组中，找 <= 某个数最右侧的位置
- 局部最小值问题



### 局部最小值问题

二分不一定要有序：数据状况特殊，问题特殊，只要能找出数据的排他性，有一半数据肯定有，另一半数据不确定，那就可以砍一半用二分。

给出一个无序且相邻两个数不相等的数组，找出一个局部最小数（找谷底）

给出局部最小定义：

[0]位置时，只要[0] < [1]，那么[0]就是局部最小

[N - 1]位置时，只要[N - 2] > [N - 1]，那么[N - 1]就是局部最小

[i]位置(不在0和N - 1)，需要[i - 1] > [i] < [i + 1]



先特判两个边界，若找到了其中一个就返回

若找不到，则说明左边界单调递减，右边界单调递增，所以1 ~ N - 2 间一定会有最小值

![image-20220123214403131](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123214403131.png)

二分找中间，如果此时找到了直接返回

![image-20220123214955679](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123214955679.png)

若找不到，则有三种情况单调递增、单调递减和i为局部最大，无论哪种情况都至少存在一个区域可以继续二分找出局部最小值。

![image-20220123215200995](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215200995.png)

![image-20220123215328950](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215328950.png)

![image-20220123215406873](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215406873.png)



# 位运算



异或定义：无进位相加

性质

- 0 ^ N == N
- N ^ N == 0
- 满足结合律和交换律，所以同一批数异或，无论是什么顺序，结果唯一



### 1、如何不用额外空间交换两个数

```java
a = a ^ b;
b = a ^ b; //证明：b = a ^ b ==> (a ^ b) ^ b ==> a ^ (b ^ b) ==> a ^ 0 ==> a
a = a ^ b; //证明：a = a ^ b ==> (a ^ b) ^ a ==> (a ^ a) ^ b ==> 0 ^ b ==> b
```

**注意前提是：a和b在内存中的位置不相等(即a和b有各自独立的内存区域,a和b的值可以一眼)，如果a和b指向同一块内存，执行三行代码后会变成0**



### 2、一个数组中有一个数出现了奇数次，其余数均出现偶数次，打印出出现奇数次的数

例：[4,3,4,2,4,3,1,2,1,1,1,3] 打印出4

普通方法：哈希表

异或运算：

只需要定义一个XOR初始值为0，XOR遍历数组异或每一个数，即`XOR = XOR ^ arr[i];或 XOR ^= arr[i] `或最终得到的结果就是所求值。

证明：同一批数异或，无论是什么顺序，结果唯一，

所以最终结果可以写成=XOR ^ (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (4 ^ 4 ^ 4)

因为偶数个本身异或为0，所以只剩下 4 ^ 4 ^ 4 ==> 0 ^ 4 ==> 4



### 3、怎么把一个int类型的数，提取出最右侧的1(二进制)

例：    1100100

得到：0000100

求补运算：找到最近的1，后面的全部取反

那我们将 **a**与**求补后的a** 做**与运算**，就能得到结果，因为a[原]和a[补]在最近1后面的数都相反，在最近1前面的数都为0。

注意：因为在计算机中的运算都是以补码进行运算，所以上面的参与运算的a实际上是a[补]，对a[补]求补就是[-a]补，所以在编程上求补运算就是求相反数也等于 ~a + 1

```java
//正数
12
原码：0000 1100
补码：0000 1100
补码再求补：
     1111 0100 
原码：1000 1100  (十进制：-12)
即 ~12=-12
//负数
-12
原码：1000 1100
补码：1111 0100
补码再求补：
     0000 1100 
原码：0000 1100  (十进制：12)
即 ~12=12
```



### 4、一个数组中有两种数出现了奇数次，其它数均出现偶数次，找到并打印出这两种数

假设两种数分别为a，b

1、定义XOR1 == 0，对这批数连续异或赋值给XOR1，最后结果为XOR1 == a ^ b

又因为a != b (两种数) ，所以XOR1 != 0，==> XOR1的二进制数中肯定有1

2、我们随便取出XOR其中一个位置的1(比如取最右侧的1)定义为onlyOne

用该位置(onlyOne)是否为1**划分出两组数**，**目的是将a、b分离**，a、b必然不在同一组(因为在该位置异或为1)

```java
//用与运算判断，因为onlyOne只有一个1，所以与运算结果要么为0，要么不为0(具体值不确定)
if ((arr[i] & onlyOne) != 0)// 说明该位置有1
if ((arr[i] & onlyOne) == 0)// 说明该位置无1
```

3、再定义一个XOR2  == 0，对其中一组数连续异或赋值给XOR2，最终结果就为a或b

因为无论在哪一组数中除了a或b其余数都为偶数个

4、知道a或b其中一个了，XOR1 ^ XOR2 就是另一个数，如XOR2 == a,XOR1 ^ XOR2 == a ^ b ^ a == b  



### 5、一个数组中有一种数出现K次，其余数均出现M次且M > 1,K < M,找出出现K次的数

要求，空间复制度O(1)，时间复杂度O(N)

假设是int型的数(二进制32位)

1、开辟一个大小为32的count数组去存储该数组所有数二进制每一位的状态

即将所有数的二进制进行算术运算相加（例1+1=2），最终count每一位都记录着数组二进制和中对应位为1的次数

```java
arr：[18,10,10,11,11] K == 1,M == 2
10		00...001100
10		00...001100
11		00...001101
11		00...001101
18		00...010010
count  [00...014412]
```

就会发现count[i]%M == 0的位置18的二进制数必为0,因为是M的倍数，又K<M

所以只要count[i]%M != 0的位置18二进制数为1,我们把这些位置全找出来，所求数就确定了

2、如何存储

```java
//二重循环，将arr中每一个num的每一位依次累加到count数组
//虽然是两个for，但是内循环次数确定(32)，所以是O(N)
for (int num : arr) {
    for (int i = 0; i < 32; i++) {
	  /*if (((num >> i) & 1) != 0) { // 与1(00...001)进行与运算不等于0说明比较的第i位为1,就累加
              count[i]++;
		}*/
        // 优化版本 (count[i] >> i)为0的时候再与1 相当于+0 等于不累加
        count[i] += ((num >> i) & 1);
    }
}
```

3、把count数组还原为对应的值

就是将符合条件的位置上填1的过程

```java
int res = 0;
for (int i = 0; i < 32; i++) {
	if ((count[i] % m) != 0) { // 说明i位上 出现k次那个数的二进制数不为0(即为1)
		res |= (1 << i); // 0依次或上第i位上的1 从右至左在符合条件的位置上填1
	}
}
```



# 数据结构

## 链表

### 1、单双链表反转

```java
ListNode<T> pre = null;
ListNode<T> cur = head;
ListNode<T> next = null;
while (cur != null) {
    next = cur.next; //记录next
    cur.next = pre; // 当前next指向pre
    pre = cur; // 将当前节点设置为pre
    cur = next;// cur后移
}
return pre;
```

```java
DoubleListNode<T> pre = null;
DoubleListNode<T> cur = head;
DoubleListNode<T> next = null;
while (cur != null) {
    next = cur.next; // 记录next
    cur.next = pre; // 修改cur的pre和next 顺序无所谓
    cur.pre = next; // 因为将cur.next保存给next了 所以先反转pre还是next的顺序无所谓
    pre = cur; // 将当前节点设置为pre
    cur = next; // cur后移 等价于cur = cur.pre 反转前的next值
}
return pre;
```



### 2、删除单链表中给定值并返回新的head



### 3、双链表实现双端队列、队列、栈



## 队列和栈

### 4、数组实现队列和栈

### 5、最小栈设计

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

1、创建两个栈，一个数据栈，一个最小栈，最小栈的栈顶为最小值

2、怎么维护最小栈的栈顶为元素最小值

- 第一种方法：

  入栈情况：

  - 当最小栈为空，第一个进入的元素就进最小栈（数据栈正常入栈）
  - 当最小栈不为空，且入栈的元素**小于等于**最小栈栈顶，才进入最小栈（数据栈正常入栈）

  出栈情况：

  - 当数据栈出栈的元素等于最小栈栈顶时，最小栈同时出栈，否则只有数据栈出栈

- 第二种方法：

  入栈情况：

  - 数据栈和最小栈同步入栈，但是只有入栈元素小于最小栈栈顶时，才将该元素入最小栈，否则将最小栈栈顶入最小栈

  出栈情况：

  - 同步出栈

> 注意第一种方法，等于的时候也要入最小栈的，因为数据栈肯定是要正常入栈的，当这个元素出栈时最小栈也要出栈，而此时数据栈有重复的元素，最小栈只有一个，会出错。



### 6、用队列实现栈

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

两个队列实现：

1、将原队列的元素导入另一个辅助队列直到只剩下一个元素，输出

2、将两队列地址互换，改变输入的队列

3、重复上述过程

![image-20220125183527993](https://gitee.com/iamnovo/pic/raw/master/images/image-20220125183527993.png)



一个队列实现：

只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

![image-20220125184034130](https://gitee.com/iamnovo/pic/raw/master/images/image-20220125184034130.png)





### 7、用栈实现队列

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 必须是popStack为空才能倒数据
- 如果导数据，必须从pushStack一次性倒完

只要满足上面两个要求，导数据的时机什么时候都可以，可以在每次push操作后，也可以在每次pop或peek的时候导，或者push和pop操作都导。



### 8、递归实现栈的逆序



## 哈希表

增删改查复杂度都认为是O(1)，但是这个常数级别有点大

哈希表存入非基础数据类型占用内存非常小，只会记录引用值，不会复制值

```java
Integer a = 1111111111;
Integer b = 1111111111;
Student student1 = new Student(2);
Student student2 = new Student(2);
HashMap<Student,String> map1 = new HashMap<>();
HashMap<Integer,String> map = new HashMap<>();

// 基础数据类型的包装类且范围不在常量池，存放在哈希表中时，根据值匹配，属同一对象。
map.put(a,"我是a");
System.out.println(map.containsKey(b));

// 非包装类的引用类型，存放在哈希表中时，根据引用值匹配，不属同一对象。
map1.put(student2,"student2");
System.out.println(map1.containsKey(student1));
```



## 有序表

TreeMap 有序表 只是一个接口

能实现有序表的：红黑树、AVL树、SBT(Size Balanced Tree)、跳表

增删改查时间复杂度都是O(logN),功能比有序表强大

Java中TreeMap是用红黑树实现的



非数值类型和String类型传入TreeMap需要自己定义比较器，否则会报错

当排序规则比较简单时，可以使用lambda表达式实现比较器

```java
//
TreeMap<Student, String> treeMap = new TreeMap<>(
                (stu1, stu2) -> !stu1.getId().equals(stu2.getId()) ? 
                        stu1.getId() - stu2.getId() : stu2.getAge() - stu1.getAge());
//
TreeMap<Student, String> treeMap = new TreeMap<>((stu1, stu2) -> stu1.getId() - stu2.getId());
// IDEA推荐写成这样
TreeMap<Student, String> treeMap = new TreeMap<>(Comparator.comparingInt(Student::getAge));
```

> 注意TreeMap一般情况下是不允许存放重复元素的，所以当传进来的比较器只比较id的话，treemap会认为相同age的student是同一个元素（即使两个student对象不一样），只会存进去一个student

解决方法，如果age相等的话，再比较内存地址（hashCode也可能重复），就能保证age相等的不同样本都留下来



# 排序

## 比较器

实现Comparator< T>接口，调用系统一些容器的sort的函数时，把比较器传进去

```java
public static class IdAscendingComparator implements Comparator<Student> {
    // 返回负数的时候，第一个参数排在前面
    // 返回正数的时候，第二个参数排在前面
    // 返回0的时候，两个参数等级相等
    @Override
    public int compare(Student o1, Student o2) {
        //return o1.getId() - o2.getId();
        //return o2.getAge() -o1.getAge();
        // id升 如果id相等 比较age 降序
        return !o1.getId().equals(o2.getId()) ? o1.getId() - o2.getId() : o2.getAge() - o1.getAge();
    }
}
//
list.sort(new IdAscendingComparator());
Arrays.sort(students, new IdAscendingComparator());
```



## 归并排序

**平均时间复杂度： O(NLogN) **

**最好情况时间复杂度： O(NLogN)**

**最差情况时间复杂度： O(NLogN)**

**所需要额外空间： 递归：O(N + LogN)， 非递归：O（N）**

**稳定性： 稳定**

归并排序基于**分治**（快排也是）

归并排序其实要做两件事：

（1）“分解”——将序列每次折半划分。

（2）“合并”——将划分后的序列段两两合并后排序。



### 1、数组小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子
[1,3,4,2,5]
1左边比1小的数：0
3左边比3小的数：1
4左边比4小的数：1,3
2左边比2小的数：1
5左边比5小的数：1,3,4,2
所以小和为1+1+3+1+1+3+4+2=16

**转换思想：每一个数左边比当前数小的数累加-->如果a右边的数有多少个数比a大，就产生多少个a**

![image-20220126214210314](https://gitee.com/iamnovo/pic/raw/master/images/image-20220126214210314.png)

例 原数组[3,2,4,1,5,6,3,0]的归并过程：

我们从2这一个数的视角，来感受求该数小和的过程

- 步长为1：

  3,2是作为准备merge后的大组，而2作为里面的右组，是不会产生小和的，但2作为左组例[2,3]和[1,4]merge的时候才会去跟右组[1,4]比较产生小和

- 步长为2：

  [2,3]和[1,4]merge，此时2作为左组，与右组的数比较，有一个4比2大，产生一个2

- 步长为4：

  [1,2,3,4]和[0,3,5,6]merge，2作为左组，与右组的数比较，3、5、6都比2大，产生三个2

- 步长为8：归并结束，上述过程一共产生四个2，所以2右边一共是有四个数比2大的，需要累加四次2

**merge过程中p2移动的方向，如果是升序，p2就从左往右移动，比较一次的前提下才能知道有多少个数比a大**




### 2、数组中逆序对个数

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

同上面一道题，转换为**-->如果a右边的数有多少个数比a小，就产生多少个a**

不同的是p2移动的方向，如果是升序，p2就从右往左移动，比较一次的前提下才能知道有多少个数比a小

315（和本题一样）,327,493,



### 3、数组中x右边有多少个数*2后小于该元素的个数

求总个数

> 注意:这题看似和第二题没有什么区别，但是有个坑，第二题是直接比x小的个数，所以p1、p2指针是从右往左移动的，但是这题不可以，比如

![image-20220127160712721](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127160712721.png)



此时arr[p2] * 2  > arr[p1],我们希望p2继续像左检索寻找符合条件的数，但是又因为arr[p2]已经大于arr[p1]了，arr[p2]是要合并到mergeArr中的并且p1--，这种情况显然从右往左是不行的。

![image-20220127161006163](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127161006163.png)

解决方法一：从右往左

把记录题解的代码和merge的代码分离开，复制p1、p2指针，不要写在同一块里

```java
public static int merge(int[] arr, int L, int M, int R) {
    int[] mergeArr = new int[R - L + 1];
    int i = mergeArr.length - 1;
    int p1 = M;
    int p2 = R;
    int res = 0;
    int p3 = p1;
    int p4 = p2;
    // 记录题解
    while (p3 >= L && p4 > M) {
        if (arr[p3] > arr[p4] * 2) {
            res += p4 - M;
            p3--;
        } else {
            p4--;
        }
    }
    // 正常merge
    while (p1 >= L && p2 > M) {
        mergeArr[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
    }
    while (p1 >= L) {
        mergeArr[i--] = arr[p1--];
    }
    while (p2 > M) {
        mergeArr[i--] = arr[p2--];
    }
    for (i = 0; i < mergeArr.length; i++) {
        arr[L + i] = mergeArr[i];
    }
    return res;
}
```

解决方法二：从左往右

![image-20220127163807301](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127163807301.png)



从左往右，此时右边没有数 * 2 < arr[p1], 数量为0，p1右移至4，p2右移至arr[p2] * 2 不小于arr[p1]的地方，则满足条件的元素有p2 - M个

> p2是不用后退的，因为是升序，既然arr[p1] > arr[p2] * 2，所以有arr[p1 + n] > arr[p2] * 2 (n > 0)

![image-20220127164125900](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127164125900.png)



### 总结

**指针不回退的本质就是单调性**

本质就是mergeSort过程把比较信息变成了有序的，从而加快我们求解

归并升序的情况：

数组中求x右边的情况：相等的时候merge过程就先拷贝右边的，因为我们是想知道x右边数的状况，所以我们需要先移动右组的指针

求右边多少个数比x小，就从右往左merge

求右边多少个数比x大，就从左往右merge



### 4、区间和的个数

[区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

前缀和+归并排序



> 注意：
>
> 前缀和头部插入值为 0 的元素，可简化边界处理
>
> 前缀和数组不是递增的，因为可能有负数

设区间和表示为Aij, 前缀和表示为Si

假设Sj已知

求以j位置结尾的子数组区间和有多少个落在[lower,uppper]上

==> lower <= Aij <= upper

==> lower <= Sj - Si-1 <= upper

==> Sj - upper <= Si-1 <= Sj - lower

因为i <= j （区间长度可以为1）

也就是说我们只需要求在j之前有多少个前缀和落在这个区间上

所以现在我们只需要用到前缀和数组，原数组已经没有用了



## 快速排序

注意边界问题

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    process(arr, 0, arr.length - 1);
}
public static void process(int[] arr, int L, int R) {
    // 注意边界i 有可能跨过去右边
    if (L >= R) {
        return;
    }
    int i = L - 1;
    int j = R + 1;
    int pivot = arr[L + ((R - L) >> 1)];
    while (i < j) {
        do i++; while (arr[i] < pivot);
        do j--; while (arr[j] > pivot);
        if (i < j) {
            swap(arr, i, j);
        }
    }
    // 因为i可能先跨过去,因为do是i操作先 所以跨过去的i位置是没有验证的
    // 而j++是后do的 退出while时j的位置一定是被验证过的
    // 左递归只能穿[L i-1] 或者[L   j]
    // 右递归只能传[i   R] 或者[j+1 R]
    process(arr, L, j);
    process(arr, j+1, R);
}
```



## 堆排序

**堆（优先队列）：**

大根堆：满足根结点>子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

小根堆：满足根结点<子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

完全二叉树：

> **i 结点的左孩子：2 * i + 1，i 结点的右孩子2 * i+2 ，i 结点的父结点 (i - 1)/2 下取整**



**建堆**

如果数据是一次传进来的，可以从下往上建堆，建堆的时间复杂度是可以达到O(N)的

> 分析一下复杂度，因为堆的叶子结点有N / 2个，叶子结点的下沉成本距离为1,只会进行一次while判断,
>
> 叶子结点的上一层有N / 4 个，下沉成本为2，以此类推，下沉成本和深度有关,设有4层
>
> 总下沉成本T(N) = N/2 * 1 + N/4 * 2 + N/8 * 3 + N/16 * 4
>
> ​          2T(N) = N + N/2 * 2 + N/4 * 3 + N/8 * 4
>
> 相减=>T(N) = N + N/2  + N/4  ...  - N/16 显然时间复杂度为O(N)

```java
for (int i = arr.length - 1; i >= 0; i--) {
    // 从下往上建堆 不断调用heapify调整下沉
	heapify(arr, i, arr.length);
}
```



如果数据是一个一个传进来的，只能从上往下建堆，时间复制度O(N*logN)

```java
for (int i = 0; i < arr.length; i++) {
    // 从上往下建堆 不断调用heapInsert调整上浮
	heapInsert(arr, i);
}
```



**维护堆**

堆排序

堆排序额外空间复杂度O(1)

排序过程O(N*logN)

```java
public static void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 建堆的过程
    /*// 从上往下建堆 逐个读入O(logN)
    for (int i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }*/
    // 从下往上建堆 一次读入 O(N)
    for (int i = arr.length - 1; i >= 0; i--) {
        heapify(arr, i, arr.length);
    }
    int heapSize = arr.length;
    
    // 堆排序的过程 靠首尾交换取得最大值从而手动打乱堆 再调用heapify来不断维护 不断获得最值
    swap(arr, 0, --heapSize);
    while (heapSize > 0) {
        heapify(arr, 0, heapSize);
        // 交换后堆大小减一 是逻辑删除该值
        swap(arr, 0, --heapSize);
    }
}
```



### 1、对一个几乎有序的数组进行排序

几乎有序是指，如果把数组排好序，每个元素师移动的距离一定不超过k，并且k大小相对数组长度是较小的，设置合适的排序策略。

使用长度为k + 1的堆来维护存放每个位置上可能出现的元素

例如设k = 5，排序后索引为0的位置的元素只可能是原数组中索引为[0-5]的位置

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
        if (k == 0) {
            return;
        }
        // 默认小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        int index = 0;
        // k如果大于数组长度，则都放进堆里
        // 先放k + 1个数进入堆
        for (; index < Math.min(arr.length, k); index++) {
            heap.add(arr[index]);
        }
        int i = 0;
        // 弹出堆顶 放入一个 直到数组中所以元素都进入到堆中
        for (; index < arr.length; i++, index++) {
            heap.add(arr[index]);
            arr[i] = heap.poll();
        }
        // 弹出堆中所有元素
        while (!heap.isEmpty()) {
            arr[i++] = heap.poll();
        }
    }
```



### 2、最大线段重合问题

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

类似[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)



定义：一条线段尾坐标 == 另一条线段头坐标不算有交集(只有一个点重合)

两条不同线段，如果一条线段尾坐标  > 另一条线段头坐标，说明这两条线段有交集

1、将所有线段按头坐标从小到大排序

**借助小根堆存储线段的尾坐标**

2、从小到大遍历每条线段，比较**遍历到的线段**和**小根堆内的尾坐标**，**将小根堆中 <= 该线段的头坐标移除**(说明当前线段与移除的掉的线段没有交集)，**小根堆剩下的尾坐标个数就为与该线段有交集的个数（除去本身）**，**切换到下一线段前，将自身尾坐标加入小根堆**

> 如果求的是有多少条线段重合，则先把自身加入，小根堆的当前的个数就是有多少条线段重合





# 链表

### 1、回文链表

[剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

一般解法借助容器类如栈

最优解：

**快慢指针+反转链表**



注意的点：

1、是不用判断奇偶的，因为右链表总是小于等于左链表，while以数量小的那个判空停下就行，因为如果是奇数，中间那个数是不用比较的。

2、判断快慢指针越界的时候，不仅仅要判faster.next.next,  faster.next也要判空 否则会空指针

3、如果要还原链表，需要复制一个指针，不能直接用reverse 会被改变

```java
// 快慢指针
public static boolean isPal2(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    // 1 快慢指针找中点
    ListNode faster = head.next; //简化边界问题
    ListNode slower = head;
    // 快慢指针 快2倍 如果奇数个 while停下 慢指针指向中点
    // 如果偶数个 慢指针指向第一个中点
    // 这里注意faster.next也要判空 否则会空指针 只需要判快指针
    while (faster != null && faster.next!= null ) {
        faster = faster.next.next;
        slower = slower.next;
    }
    boolean res = true;
    // 2 反转右链表对比
    ListNode reverse = reverse(slower.next);
    // 如果要还原链表的话不能直接用reverse 会被改变
    ListNode temp = reverse;
    while (temp != null) {
        if (temp.data != head.data) {
            res = false;
            break;
        }
        temp = temp.next;
        head = head.next;
    }
    // 3 还原链表
    slower.next = reverse(reverse);
    return res;
}

public static ListNode reverse(ListNode head) {
    ListNode next = null;
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 2、复杂链表的复制

[剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

一般解：哈希表

最优解：

使用哈希表能解决的原因是，我们可以得到原结点和副本的一一对应结构，只要我们人为去构造这种对应的结构就不需要哈希表。

1、在每个原结点后复制出一个新的

2、一对一对（origin + copy）的遍历 添加副本结点的random指针

3、分离原结点和副本

```java
public Node copyRandomList(Node head) {
    // 这个是有必要的 否则下面的Node copyHead = head.next可能会空指针
    if (head == null) {
        return null;
    }
    Node cur = head;
    Node next = null;
    // 1 在每个原结点后复制出一个新的
    while (cur != null) {
        next = cur.next;
        // copy = cur.next; copy.next = next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }
    // 一对一对（origin + copy）的遍历 添加副本结点的random指针
    cur = head;
    Node curCopy = null;
    // 这里为什么不用判cur.next != null 是因为cur.next是cur的副本 只用判cur就可以了
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        // cur.random是原结点的random 我们通过它获取cur.random的副本 而副本是接在原结点后面的
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node copyHead = head.next;
    // 分离原结点和副本
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = curCopy.next;
        // 要特殊处理一下最后一个结点next为空 next.next会报错
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return copyHead;
}
```

对最后一个结点进行操作的时候需要特判一下next为不为空

![image-20220129231741596](https://gitee.com/iamnovo/pic/raw/master/images/image-20220129231741596.png)

### 3、相交链表(有环无环)

#### 题目描述

给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 

【要求】 如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。



#### 题解

这应该是链表里最难的题目之一了，一道题里组合了环形链表和普通相交链表

分析一下题目的可能性：

一共有五种可能性：

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220202221828729.png)

```java
// 主方法
public static ListNode isIntersection(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode loopA = findLoopNode(headA);
    ListNode loopB = findLoopNode(headB);
    // 两个无环链表相交问题
    if (loopA == null && loopB == null) {
        return getIntersectionNoLoop(headA, headB);
    }
    // 两个有环链表相交问题
    if (loopA != null && loopB != null) {
        return getIntersectionAllLoop(headA, loopA, headB, loopB);
    }
    // 一个有环 一个无环 必不相交
    return null;
}

// 判断链表是否有环，有则返回入环点，无则返回null
public static ListNode findLoopNode(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null && faster != slower) {
        faster = faster.next.next;
        slower = slower.next;
    }
    if (faster == null || faster.next == null) {
        return null;
    }
    slower = slower.next;
    faster = head;
    while (faster != slower) {
        faster = faster.next;
        slower = slower.next;
    }
    return faster;
}

// 求两个有环链表相交问题 如果相交求出交点
public static ListNode getIntersectionAllLoop(ListNode headA, ListNode loopA, ListNode headB, ListNode loopB) {
    ListNode curA = headA;
    ListNode curB = headB;
    // 入环点一样 那么入环点之前的情况跟无环链表一样
    if (loopA == loopB) {
        while (curA != curB) {
            // 不让指针走入环内
            curA = (curA != loopA) ? curA.next : headB;
            curB = (curB != loopA) ? curB.next : headA;
        }
        return curA;
    }
    // 入环点不一样 即相交点就等于入环点 随便返回一个
    return loopA;

}

// 求两个无环链表相交问题 如果相交求出交点
public static ListNode getIntersectionNoLoop(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode curA = headA;
    ListNode curB = headB;
    while (curA != curB) {
        curA = (curA != null) ? curA.next : headB;
        curB = (curB != null) ? curB.next : headA;
    }
    return curA;
}

// 测试样例 for test
public static void main(String[] args) {
    // 1->2->3->4->5->6->7->null
    ListNode head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);

    // 0->9->8->6->7->null
    ListNode head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

    // 1->2->3->4->5->6->7->4...
    head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);
    head1.next.next.next.next.next.next = head1.next.next.next; // 7->4

    // 0->9->8->2...
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next; // 8->2
    System.out.println(isIntersection(head1, head2).val);

    // 0->9->8->6->4->5->6..
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

}
```





### 4、链表排序



# 二叉树

### 1、遍历

### 2、序列化与反序列化

### 3、二叉树的最大宽度

### 4、二叉树层序遍历进阶

#### 问题描述

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```



#### 题解

层序遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> levelList;
    if (root == null) {
        return res; 
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    int levelCount = 0;
    while (!queue.isEmpty()) {
        levelList = new ArrayList<>();
        levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 记录每一层的信息
        res.add(levelList);
    }
    return res;
}
```



总结：最大宽度和该题都是**层次划分**的套路，每次while循环记录一下levelCount，按levelCount在里面for循环遍历即可

### 5、树与二叉树的转化

### 6、折痕问题

#### 题目描述

```java
* 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。
* 此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。
* 如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，
* 从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，
* 请从上到下打印所有折痕的方向。 例如：
* N=1时，
* 打印： down
* N=2时，
* 打印： down down up
```



#### 题解

```java
/**
 * 实际上就是一颗二叉树 折痕当做结点
 * 该树的特点 树的根节点是凹 左孩子结点为凹 右孩子结点为凸
 * 用 i 表示层数 如果是纸条从上往下打印 就是中序遍历
 * @param N
 */
public static void printAllFolding(int N) {
    inOrder(1, N, true);
}

public static void inOrder(int i, int N, boolean isDown) {
    if (i > N) {
        return;
    }
    inOrder(i + 1, N, true);
    System.out.print(isDown ? "第" + i + "次凹 " : "第" + i + "次凸 ");
    inOrder(i + 1, N, false);
}
```



### 7、二叉树完全性检验

#### 题目描述

[958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

给定一个二叉树的 `root` ，确定它是否是一个 *完全二叉树* 。

在一个 **[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)** 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 `1` 到 `2h` 节点之间的最后一级 `h` 。

 

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/complete-binary-tree-1.png)

```
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
```

**示例 2：**

**![](https://gitee.com/iamnovo/pic/raw/master/images/complete-binary-tree-2.png)**

```
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
```

 

#### 题解

层序遍历框架改写加两个原则：

- 有右孩子但是没有左孩子，必不为完全二叉树
- 某一层中若出现某结点的子树不全(只有一个孩子或者没有孩子)，则剩下结点若不都是叶子结点，必不为完全二叉树

层序遍历完全，若不违反上面两个原则，则为完全二叉树

```java
public static boolean isCompleteBTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    // 是否有孩子不全的结点
    boolean isNotFullChild = false;
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    while (!queue.isEmpty()) {
        cur = queue.poll();

        // 第一种情况：有孩子不全的结点出现且后面结点不都为叶子结点
        // 第二种情况：右子树为空且左子树不为空
        if ((isNotFullChild && (cur.left != null || cur.right != null))
                || (cur.right != null && cur.left == null)) {
            return false;
        }

        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }

        // 第一次出现孩子不全的结点，进行标记
        // 标记一定要在最后进行，因为我们判断的是之后的结点是否都为叶子结点，
        // 如果if放在前面会出现把自己标记，又拿自己参与判断的情况
        if (cur.left == null || cur.right == null) {
            isNotFullChild = true;
        }

    }
    return true;
}
```



### 8、二叉树平衡性校验

#### 题目描述

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![](https://gitee.com/iamnovo/pic/raw/master/images/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```



#### 题解

虽然不是最优解，但是是比较容易理解的自顶向下递归方式

1. **找整个递归的终止条件：递归应该在什么时候结束？**
2. **找返回值：应该给上一级返回什么信息？**
3. **本级递归应该做什么：在这一级递归中，应该完成什么任务？**

我们只需要关心最顶层的递归需要做什么才能得到答案

判断一颗二叉树是否为平衡二叉树的条件：

- 左子树为平衡二叉树
- 右子树为平衡二叉树
- 左右子树的高度差不大于1

上面三个条件只要满足了，整颗二叉树就是平衡二叉树

那我们只需要每次递归中返回子树的两个信息：是否为平衡二叉树和最深深度

将这两个信息进行处理就能得到答案

```java
public static class Info{
    public boolean isBalanced;
    public int depth;
    public Info(boolean isBalanced,int depth) {
        this.isBalanced = isBalanced;
        // 深度
        this.depth = depth;
    }
}
public static boolean isBalanced(TreeNode root) {
    return process(root).isBalanced;
}
public static Info process(TreeNode root) {
    // 为空 递归结束 返回信息
    if (root == null) {
        return new Info(true,0);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean isBalanced = true;
    // 子树中最深的一条路径 + 1 就是root的最深路径
    int depth = Math.max(leftInfo.depth,rightInfo.depth) + 1;
    // 不同时满足三个条件的root就不是平衡二叉树
    if (!leftInfo.isBalanced || !rightInfo.isBalanced
            || Math.abs(leftInfo.depth - rightInfo.depth) > 1) {
        isBalanced = false;
    }
    return new Info(isBalanced,depth);
}
```



### 9、二叉树直径

#### 题目描述

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。



#### 题解

DFS求左右子树的最深路径，左右子树最深路径之和的最大值就是直径

```java
private int res = 0;
public int diameterOfBinaryTree(TreeNode root) {
    process(root);
    // 注意是返回res 不是process的返回值
    return res;
}
public int process(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = process(root.left);
    int rightDepth = process(root.right);
    res = Math.max(res, leftDepth + rightDepth);
    // 返回左右子树的最深一条路径 加上来自己的一个距离
    return Math.max(leftDepth, rightDepth) + 1;
}
```

比如对于4来说，它的左右子树最深路径都为0，返回的时候要加上来4的一个距离

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220201214320795.png)

整棵树的其中一个直径就是1的左子树2的最深路径加上1的右子树3的最深路径

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220201214638741.png)



### 10、满二叉树检验

#### 问题描述

```
对于满二叉树的定义，国内外不一样
* 国内：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
* 国外：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。
* 这里算法按照国内的来
```

所以满二叉树满足    结点数= 2 ^ 二叉树的深度 - 1，

我们只需要返回每棵子树的结点数和深度就可以进行递归判断

#### 题解

```java
public static class Info {
    public int depth;
    public int nodes;

    public Info(int depth, int nodes) {
        this.depth = depth;
        this.nodes = nodes;
    }
}

public static boolean isFullBTree(TreeNode root) {
    Info rootInfo = process(root);
    //return Math.pow(2, rootInfo.depth) - 1 == rootInfo.nodes;
    // 次方可以用位运算
    return (1 << rootInfo.depth) - 1 == rootInfo.nodes;
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(0, 0);
    }

    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);
    int curDepth = Math.max(leftInfo.depth, rightInfo.depth) + 1;
    int curNodes = leftInfo.nodes + rightInfo.nodes + 1;
    return new Info(curDepth, curNodes);
}
```



### 11、二叉搜索树检验

#### 问题描述

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/BSTree.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://gitee.com/iamnovo/pic/raw/master/images/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`



#### 题解

思路一，可以用中序遍历验证是否升序

思路二，递归

**容易理解的递归**

- root的左子树满足二叉搜索树
- root的右子树满足二叉搜索树
- 左子树的最大值严格小于root.val且右子树的最小值严格大于root.val

**因为判断root == null 在递归中info比较难处理，那就换个思路，子树不为null才进入递归**

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return process(root).isBST;
}

public class Info {
    public int max;
    public int min;
    public boolean isBST;
    public Info(boolean isBST, int max, int min) {
        this.isBST = isBST;
        this.max = max;
        this.min = min;
    }
}

public Info process(TreeNode root) {
    Info curInfo = new Info(true, root.val, root.val);
    if (root.left != null) {
        Info leftInfo = process(root.left);
        if (!leftInfo.isBST || leftInfo.max >= root.val) {
            curInfo.isBST = false;
        }
        // 只需要在左子树更新最小值和在右子树更新最大值，就算出现了不是搜索子树导致更新最值不正确也没什么所谓，因为已经记录的false值了
        //curInfo.max = Math.max(leftInfo.max,root.val);
        curInfo.min = Math.min(leftInfo.min, root.val);
    }
    if (root.right != null) {
        Info rightInfo = process(root.right);
        if (!rightInfo.isBST || rightInfo.min <= root.val) {
            curInfo.isBST = false;
        }
        curInfo.max = Math.max(rightInfo.max, root.val);
        //curInfo.min = Math.min(rightInfo.min,root.val);
    }
    return curInfo;
}
```

个人比较习惯写法：

还是在递归里处理null

```java
public static Info process2(TreeNode root) {
    if (root == null) {
        return new Info(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process2(root.left);
    Info rightInfo = process2(root.right);
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    boolean curIsBST = false;
    if (leftInfo.isBST && rightInfo.isBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curIsBST = true;
    }
    return new Info(curIsBST, curMax, curMin);
}
```



### 12、最大二叉搜索树

#### 题目描述

leetcode333

给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。注意：子树必须包含其所有后代。

#### 题解

递归套路，自顶向下跟子树要信息

返回最大结点数量

```java
public static int findMaxSubBSTreeSize(TreeNode root) {
    /*if (root == null) {
        return 0;
    }*/
    return process(root).maxBSTSubTreeSize;
}

public static class Info {
    public boolean isAllBST;
    public int maxBSTSubTreeSize;
    public int max;
    public int min;

    public Info(boolean isAllBST, int maxBSTSubTreeSize, int max, int min) {
        this.isAllBST = isAllBST;
        this.maxBSTSubTreeSize = maxBSTSubTreeSize;
        this.max = max;
        this.min = min;
    }
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean curIsAllBST = false;
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    // 若左右子树都不存在搜索树 curMaxBSTSubTreeSize默认值就是1 自身一个节点（假定只有一个结点时也是二叉搜索树）
    int curMaxBSTSubTreeSize = 1;
    // 子树存在最大二叉搜索树，取其最大值
    if (leftInfo.maxBSTSubTreeSize != 0 || rightInfo.maxBSTSubTreeSize != 0) {
        curMaxBSTSubTreeSize = Math.max(leftInfo.maxBSTSubTreeSize, rightInfo.maxBSTSubTreeSize);
    }
    // 左右子树整颗都为二叉搜索树且满足左子树最大值 < root.val 右子树最小值> root.val
    // 更新curMaxBSTSubTreeSize 等于左+右+自身的一个节点
    if (leftInfo.isAllBST && rightInfo.isAllBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curMaxBSTSubTreeSize = leftInfo.maxBSTSubTreeSize + rightInfo.maxBSTSubTreeSize + 1;
        curIsAllBST = true;
    }
    return new Info(curIsAllBST, curMaxBSTSubTreeSize, curMax, curMin);
}
```

返回最大二叉搜索子树





### 13、公共祖先



# 并查集

### 模板

并查集的两个优化

- 路径压缩
- 按秩合并

同时使用两个的话，并查集的查询和合并的效率是可以达到O(1)的

```java
/**
 * 经典并查集
 *
 * @author novo
 * @date 2022/2/3-22:39
 */
public class UnionFindSet {
    private int[] parent;
    private int[] rank;

    public UnionFindSet(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
    }

    public void build(int n) {
        for (int i = 0; i < n; i++) {
           	rank[i] = 1;
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            //return find(parent[x]);
            // 在返回的路上进行路径压缩 在每次查找时 把查找路径上(注意只压缩路径上的)的每个结点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int x, int y) {
        if (x == y) {
            return;
        }
        // 将x接到y
        parent[find(x)] = find(y);
    }

    // 按秩合并
    public void union2(int x, int y) {
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
    }

    // 返回集合个数
    public int getUnionSize(int n) {
        int size = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i) {
                size++;
            }
        }
        return size;
    }
}
```



### 1、省份数量

#### 题目描述

[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

**示例 1：**

![](https://gitee.com/iamnovo/pic/raw/master/images/graph1.jpg)

```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

**示例 2：**

![](https://gitee.com/iamnovo/pic/raw/master/images/graph2.jpg)

```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```



#### 题解

经典并查集模型

如果相连，就加入同一集合，最后返回集合的个数

```java
private int[] parent;
public int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}
public void union(int x, int y) {
    if (x == y) {
        return;
    }
    parent[find(x)] = find(y);
}
public int getUnionSize(int n) {
    int size = 0;
    for (int i = 0; i < n; i++) {
        if (find(i) == i) {
            size++;
        }
    }
    return size;
}
public int findCircleNum(int[][] isConnected) {
    int n = isConnected.length;
    parent = new int[n];
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
    // j = i + 1 只遍历右上角且不遍历对角线 因为对称
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                union(i, j);
            }
        }
    }
    // 返回并查集集合的个数
    return getUnionSize(n);
}
```



### 2、岛屿数量

#### 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等1527收藏分享切换为英文接收动态反馈

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示**：

- ```
  m == grid.length
  ```

- ```
  n == grid[i].length
  ```

- ```
  1 <= m, n <= 300
  ```

- ```
  grid[i][j] 的值为 '0' 或 '1'
  ```

  

#### 题解

看题目给的数据范围，时间复杂度O(m * n)是可以的

##### **深搜**

把数组都遍历一遍，将所有为1的都合并在一起，为1的进去递归，对上下左右都递归，形象的比喻成感染，对上下左右感染，递归退出则合并完毕

```java
public int numIslands(char[][] grid) {
    int islands = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == '1') {
                islands++;
                merge(grid, i, j);
            }
        }
    }
    return islands;
}

public void merge(char[][] grid, int i, int j) {
    if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] != '1') {
        return;
    }
    grid[i][j] = 'X';
    merge(grid, i - 1, j);
    merge(grid, i + 1, j);
    merge(grid, i, j - 1);
    merge(grid, i, j + 1);
}
```

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220204234121850.png)

##### **并查集**

把都为1的合并

二维数组使用并查集需要将每个二维坐标转换成一维坐标，就能使每个索引唯一

```
(i, j) ==> i * 列数 + j
就是将二维数组转换成一维数组该怎么表示
```



```java
public class UnionFindSet {
    // 并查集模板...
}
public int numIslands(char[][] grid) {
    // 方向数组
    int[][] directs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int m = grid.length;
    int n = grid[0].length;
    // 需要记录0的地方
    int zero = 0;
    UnionFindSet set = new UnionFindSet(m * n);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                // 检索四个方向
                for (int[] direct : directs) {
                    int x = i + direct[0];
                    int y = j + direct[1];
                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == '1') {
                        // 合并
                        set.union(x * n + y, i * n + j);
                    }
                }
            } else {
                zero++;
            }
        }
    }
    // 注意要记录0的数量 减去0的数量
    return set.getUnionSize(m * n) - zero;
}
```

虽然代码量比较多，而且跑出来执行用时不太好看，但是跟深搜都是一样的时间复杂度O(m * n)，都是最优解

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220204233443138.png)





### 3、岛屿数量2

#### 题目描述

[305. 岛屿数量 II](https://leetcode-cn.com/problems/number-of-islands-ii/)

给你一个大小为 `m x n` 的二进制网格 `grid` 。网格表示一个地图，其中，`0` 表示水，`1` 表示陆地。最初，`grid` 中的所有单元格都是水单元格（即，所有单元格都是 `0`）。

可以通过执行 `addLand` 操作，将某个位置的水转换成陆地。给你一个数组 `positions` ，其中 `positions[i] = [ri, ci]` 是要执行第 `i` 次操作的位置 `(ri, ci)` 。

返回一个整数数组 `answer` ，其中 `answer[i]` 是将单元格 `(ri, ci)` 转换为陆地后，地图中岛屿的数量。

**岛屿** 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/10/tmp-grid.jpg)

```
输入：m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
输出：[1,1,2,3]
解释：
起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
- 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。此时存在 2 个岛屿。
- 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。此时存在 3 个岛屿。
```

**示例 2：**

```
输入：m = 1, n = 1, positions = [[0,0]]
输出：[1]
```

注意：addland可能出现同一个位置

**提示：**

- `1 <= m, n, positions.length <= 104`
- `1 <= m * n <= 104`
- `positions[i].length == 2`
- `0 <= ri < m`
- `0 <= ci < n`

**进阶：**你可以设计一个时间复杂度 `O(k log(mn))` 的算法解决此问题吗？（其中 `k == positions.length`）



#### 题解

这题只能用并查集求连通分量，相比于岛屿数量问题1，它是动态的生成岛屿，而不是全部给出来

对于每个 addLand 操作。需要注意的逻辑是：

如果 addLand 操作的顶点已经访问过，跳过；
如果 addLand 操作的顶点没有访问过，此时需要增加连通分量个数，然后再将它与「上」「下」「左」「右」合并。



```java
public List<Integer> numIslands2(int m, int n, int[][] positions) {
    UnionFindSet set = new UnionFindSet(m * n);
    List<Integer> res = new ArrayList<>();
    int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] position : positions) {
        int i = position[0];
        int j = position[1];
        set.visited[i * n + j] = true;
        for (int[] direct : directs) {
            int x = i + direct[0];
            int y = j + direct[1];
            // x、y没有越界且已经变成岛屿
            if (x >= 0 && y >= 0 && x < m && y < n && set.visited[x * n + y]) {
                set.union2(i * n + j, x * n + y);
            }
        }
        res.add(set.getUnionSize(m * n));
    }
    return res;
}

public class UnionFindSet {
    private int[] parent;
    private int[] rank;
    public boolean[] visited;
	// ...省略常用方法
    // 返回集合个数
    public int getUnionSize(int n) {
        int size = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i && visited[i]) {
                size++;
            }
        }
        return size;
    }
}
```

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220205151254844.png)



差点超时了，如果降落的次数为k的话，总的时间复杂度是O(k + m * n)，速度太慢应该是，每次降落后都要调用set.getUnionSize(m * n)查询连通分量，于是对并查集进行了优化，再定义一个size变量来记录连通分量。

```java
public List<Integer> numIslands2(int m, int n, int[][] positions) {
    UnionFindSet set = new UnionFindSet(m * n);
    List<Integer> res = new ArrayList<>();
    int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] position : positions) {
        int i = position[0];
        int j = position[1];
        // 注意没被降落过的才size++
        if (!set.visited[i * n + j]) set.size++;
        set.visited[i * n + j] = true;
        for (int[] direct : directs) {
            int x = i + direct[0];
            int y = j + direct[1];
            // x、y没有越界且已经变成岛屿
            if (x >= 0 && y >= 0 && x < m && y < n && set.visited[x * n + y]) {
                // 注意合并的方法这里需要判断是否已经合并过 否则size不准
                set.union2(i * n + j, x * n + y);
            }
        }
        // 直接返回set.size
        res.add(set.size);
    }
    return res;
}

public class UnionFindSet {
    private int[] parent;
    private int[] rank;
    private int size;
    public boolean[] visited;
    public UnionFindSet(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
        this.visited = new boolean[size];
        build(size);
    }

    public void build(int n) {
        for (int i = 0; i < n; i++) {
            visited[i] = false;
            rank[i] = 1;
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            //return find(parent[x]);
            // 在返回的路上进行路径压缩 在每次查找时 把查找路径上(注意只压缩路径上的)的每个结点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 注意合并的时候需要判断 是否已经合并过了，因为测试用例可能会重复，否则size会多减
    public void union(int x, int y) {
        if (x == y) {
            return;
        }
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        // 将x接到y
        parent[x] = y;
        size--;
    }

    // 按秩合并
    public void union2(int x, int y) {
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
        size--;
    }
}
```

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220205152410321.png)







# 递归与回溯

这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， **为什么有的时候用 `used` 数组，有的时候设置搜索起点 `begin` 变量**，理解状态变量设计的想法。 ----- Copyright by liweiwei1419. Link: https://suanfa8.com/algorithm-idea/backtracking/07-practice/

回溯其实就是横向遍历，纵向递归的组合。

说白了就是一种尝试的过程，试过了返回再次尝试下一种可能



## 排列

### 1、全排列1

#### 题目描述

[46. 全排列](https://leetcode-cn.com/problems/permutations/)



#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used ;
public List<List<Integer>> permute(int[] nums) {
    if (nums == null || nums.length == 0) {
        return res;
    }
    used = new boolean[nums.length];
    backTracking(nums, 0);
    return res;
}

// path和index都可以作为可变参数 需要知道为什么传这个参数，这个参数的目的，而不是固定传参
public void backTracking(int[] nums, int index) {
    if (index == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++){
        if(!used[i]) {
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums, index + 1);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



### 2、全排列2

#### 题目描述

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)



#### 题解

去重

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> permuteUnique(int[] nums) {
    used = new boolean[nums.length];
    Arrays.sort(nums);
    backTracking(nums);
    return res;
}

public void backTracking(int[] nums) {
    if (path.size() == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (!used[i]) {
            // used[i - 1] == false 说明被回溯过 回到同一层，若此时nums[i] == nums[i - 1]说明在树层出现重复，即深搜起点一样需要剪枝
            // 当used[i - 1] == true 说明在深搜树枝，可以重复
            if (i > 0 && !used[i - 1] && nums[i] == nums[i - 1]) {
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums);
            // 回溯
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



#### 题解



## 组合

```
// 按序搜索是避免 出现组合重复 [2, 2, 1], [2, 1, 2]
// 而used数组是为了避免在同一层级上选到值一样的元素 第三位的2虽然来源不相等 但是他们的值是一样的 [2, 1, 2], [2, 1, 2]
```



### 1、电话号码的字母组合

#### 题目描述

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://gitee.com/iamnovo/pic/raw/master/images/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。



#### 题解

时间复杂度: `O(2^len(digits.length))`

时间复杂度: `O(log(len(digits.length))`

以digits == "23"为例：

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220207133312605.png)

```java
private String[] letterMap = {
            " ",   // 0
            "",    // 1
            "abc", // 2
            "def", // 3
            "ghi", // 4
            "jkl", // 5
            "mno", // 6
            "pqrs",// 7
            "tuv", // 8
            "wxyz" // 9
    };
    private List<String> res = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        // 测试用例为空时 输出：[] 而不是[""]
        if ("".equals(digits)){
            return res;
        }
        String path = "";
        backTracking(digits.toCharArray(), 0, path);
        return res;
    }

    public void backTracking(char[] digits, int index, String path) {
        System.out.println(index + ":" + path);
        if (index == digits.length) {
            res.add(path);
            return;
        }
        // 减去'0' 对应的就是哪个letter
        String letters = letterMap[digits[index] - '0'];
        int n = letters.length();
        for (int i = 0; i < n; i++) {
            System.out.println("digits[" + index + "] = " + path + " , use " + letters.charAt(i));
            backTracking(digits, index + 1, path + letters.charAt(i));
        }
        System.out.println("digits[" + index + "] = " + path + " complete, return");
    }
```



### 2、组合

#### 题目描述

[77. 组合](https://leetcode-cn.com/problems/combinations/)

#### 题解

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220208153744231.png)



```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combine(int n, int k) {
    if (n <= 0 || k <= 0 || k > n) {
        return res;
    }
    backTracking(n, k, 1);
    return res;
}

public void backTracking(int n, int k, int index) {
    if (path.size() == k) {
        res.add(new ArrayList<>(path));
        return;
    }
    // [1, n]的组合 所以index从1开始 <= n
    // 还剩 k - path.size() 个空位，所以[i...n]中至少要有k-path.size()个元素
    // 例如至少要有2个元素 i要<= n-1 至少要有1个元素 i <= n
    for (int i = index; i <= n - (k - path.size()) + 1; i++) {
        /*if (path.size() >= k) {
            break;
        }*/
        path.add(i);
        /*System.out.println("index:" + index);
        System.out.println("path: " + path);*/
        backTracking(n, k, i + 1);
        path.remove(path.size() - 1);
    }
}
```



### 3、组合总和

#### 题目描述

[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

#### 题解

核心点就是用i来控制在一次深搜中可以回头，出现分支(另一次深搜)不可以回头

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    if (candidates == null || candidates.length == 0) {
        return res;
    }
    backTracking(candidates, 0, target);
    return res;
}

// 使用index
public void backTracking(int[] candidates, int index, int target) {
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        if (candidates[i] > target) {
            // 没用排序 只能continue  如果用排序的话可以直接break
            continue;
        }
        path.add(candidates[i]);
        // 可以用i来控制每次的深搜都可以选所有值，而不是i+1 一次完整的深搜到尽头后才会++，又保证的下一次深搜不会选到重复的值
        backTracking(candidates, i, target - candidates[i]);
        path.remove(path.size() - 1);
    }
}
```



### 4、组合总和2

#### 题目描述

[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)



#### 题解

总结：

给定数组中可能出现重复元素，每次不能选相同位置的元素，用used数组，不能回头

给定数组中不会出现重复元素，而每次可以选相同的位置元素的情况下，不需要used数组，可以回头

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    if (candidates == null || candidates.length == 0) {
        return res;
    }
    used = new boolean[candidates.length];
    Arrays.sort(candidates);
    backTracking(candidates, 0, target);
    return res;
}

public void backTracking(int[] candidates, int index, int target) {
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        // 去重 used[i - 1] == false 说明现在处在同一层 被回溯过不可以选
        if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
            continue;
        }
        // 剪枝
        if (candidates[i] > target) {
            // 已经有序 可以break
            break;
            //continue;
        }
        used[i] = true;
        path.add(candidates[i]);
        backTracking(candidates, i + 1, target - candidates[i]);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}
```



### 5、组合总和3

#### 题目描述

[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)



#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combinationSum3(int k, int n) {
    if (k == 0) {
        return res;
    }
    backTracking(k, 1, n);
    return res;
}

public void backTracking(int k, int index, int n) {
    // 如果path大小等于k都要return，不需要继续深搜
    if (path.size() == k) {
        if(n == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }
    // 只能选1~9且不能重复 数据太小剪枝意义不大
    for (int i = index; i <= 9; i++) {
        path.add(i);
        backTracking(k, i + 1, n - i);
        path.remove(path.size() - 1);
    }
}
```



### 6、二进制手表

#### 题目描述

google面试题

[401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)



#### 题解

```java
// 比较巧妙的是这两个hours和minutes数组，相当于将所有灯的选择都合并在一起，
// for横向遍历的时候都选择两个数组的元素，实际上只选择了一个，因为另一个是0
int[] hours = new int[]{1, 2, 4, 8, 0, 0, 0, 0, 0, 0};
int[] minutes = new int[]{0, 0, 0, 0, 1, 2, 4, 8, 16, 32};
List<String> res = new ArrayList<>();

public List<String> readBinaryWatch(int turnedOn) {
    backTracking(turnedOn, 0, 0, 0);
    return res;
}

public void backTracking(int turnedOn, int index, int hour, int minute) {
    //4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。
    if (hour > 11 || minute > 59) {
        return;
    }
    if (turnedOn == 0) {
        StringBuilder path = new StringBuilder();
        path.append(hour).append(":");
        if (minute < 10) {
            path.append("0");
        }
        path.append(minute);
        res.add(path.toString());
        return;
    }
    for (int i = index; i < 9; i++) {
        backTracking(turnedOn - 1, i + 1, hour + hours[i], minute + minutes[i]);
        // 回溯体现在hour + hours[i]、minute + minutes[i]这个操作只是做了参数传递，退出来后hour已经还原了
    }
}
```



## 子集

### 1、子集

#### 题目描述

[78. 子集](https://leetcode-cn.com/problems/subsets/)



#### 题解

求子集问题，本质就是要遍历整颗树，不需要剪枝



**第一种思路**

对于每个位置，只有选与选两种抉择，本质上就是一颗二叉树

![](https://gitee.com/iamnovo/pic/raw/master/images/1643212121-zZXdpR-image.png)

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    backTracking(nums, 0, path);
    return res;
}

public void backTracking(int[] nums, int index, List<Integer> path) {
    if (index == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    // 为什么不需要for循环 因为本质上就是一颗二叉树 每个结点只有选和不选两种选择，而不是选什么元素的问题
    // 不选
    backTracking(nums, index + 1, path);

    // 选
    path.add(nums[index]);
    backTracking(nums, index + 1, path);
    path.remove(path.size() - 1);
```



**第二种思路**

关心选什么元素，也就是最常见的回溯，需要for遍历

![](https://gitee.com/iamnovo/pic/raw/master/images/1631607104-NFVwFo-file_1631607104526)

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    backTracking(nums, 0, path);
    return res;
}

public void backTracking(int[] nums, int index, List<Integer> path) {
    res.add(new ArrayList<>(path));
    // 这里判断可以省略 
    if (path.size() == nums.length) {
        return;
    }
    for (int i = index; i < nums.length; i++) {
        path.add(nums[i]);
        backTracking(nums, i + 1, path);
        path.remove(path.size() - 1);
    }
}
```





### 2、子集2

#### 题目描述

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

在子集1的问题上加了used去重以及按序搜索排除组合重复

#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;
public List<List<Integer>> subsetsWithDup(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    Arrays.sort(nums);
    used = new boolean[nums.length];
    backTracking(nums, 0);
    return res;
}

public void backTracking(int[] nums, int index) {
    res.add(new ArrayList<>(path));
    // 终止条件可以不写
    if (index == nums.length) {
        return;
    }

    for (int i = index; i < nums.length; i++) {
        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false){
            continue;
        }
        used[i] = true;
        path.add(nums[i]);
        backTracking(nums, i + 1);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}
```





## 分割

### 1、复原IP地址

#### 题目描述

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

#### 题解

![93.复原IP地址](https://gitee.com/iamnovo/pic/raw/master/images/1631606390-ioqLGF-file_1631606390061)



这题的可以剪枝的情况很多，但是如果都要对所有情况进行剪枝判断的话，反而效率会下降，我们只考虑对每一小段IP区间进行剪枝判断

```java
private List<String> res = new ArrayList<>();
// 需要频繁修改字符串
StringBuilder IP = new StringBuilder();

public List<String> restoreIpAddresses(String s) {
    IP.append(s);
    backTracking(IP, 0, 0);
    return res;
}

public void backTracking(StringBuilder IP, int index, int pointNum) {
    // 最后一个"."添加完 判断最后一段是否合法
    if (pointNum == 3) {
        if (isValid(IP.substring(index, IP.length()))) {
            res.add(IP.toString());
        }
        return;
    }
    // 属于切割问题 给定字符串上的数字我们是不能修改的，我们只能添加"."，我们并没有用path 所以这个i是不会回退的
    for (int i = index; i < IP.length(); i++) {
        System.out.println("index:" + index + "  i+1:" + (i + 1));
        // 判断选定区间是否合法   substring 左闭右开 [ )
        if (!isValid(IP.substring(index, i + 1))) {
            break;
        }
        // 合法
        IP.insert(i + 1, ".");
        System.out.println(IP);
        backTracking(IP, i + 2, pointNum + 1);
        // 消除痕迹 回溯
        IP.deleteCharAt(i + 1);
    }
}

// 校验每一小段的IP是否合法
public boolean isValid(String str) {
    System.out.println("小段区间：" + str);
    if (str == null || str.length() == 0) {
        return false;
    }
    // 校验是否含前导0
    if (str.charAt(0) == '0' && str.length() > 1) {
        return false;
    }
    // 校验每一位字符是否为0~9
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) < '0' || str.charAt(i) > '9') {
            return false;
        }
    }
    // 校验是否属于0~255
    if (Long.parseLong(str) > 255 || Long.parseLong(str) < 0) {
        return false;
    }
    return true;
}
```



### 2、分割回文串

#### 题目描述

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)



#### 题解

![](https://gitee.com/iamnovo/pic/raw/master/images/1631606009-OMGnoi-image.png)



```java
private List<List<String>> res = new ArrayList<>();
private List<String> path = new ArrayList<>();
private StringBuilder str = new StringBuilder();

public List<List<String>> partition(String s) {
    str.append(s);
    backTracking(str, 0);
    return res;
}

public void backTracking(StringBuilder str, int index) {
    // 切割完毕
    if (index == str.length()) {
        System.out.println("path：" + path + "切割完成");
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < str.length(); i++) {
        System.out.print("path:" + path + "   ");
        System.out.println("index: " + index + " i: " + i);
        // 不是回文串
        if (!isPalindrome(str, index, i)) {
            continue;
        }
        String s = str.substring(index, i + 1);
        path.add(s);
        backTracking(str, i + 1);
        path.remove(path.size() - 1);
    }
}

// 判断是否回文
private boolean isPalindrome(StringBuilder s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
    }
    return true;
}
```



## 二维平面

遇到这个问题，一个非常重要的事情是：**问清楚面试官，是否可以修改传来的 nums 数组**

如果可以修改的话，代码可以写得比较简洁，就不需要用额外的visited数组来标记了

### 1、单词搜索

#### 题目描述

[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

#### 题解

二维平面上使用回溯

只要是涉及下标越界的地方，先判断是否越界是更好的做法。

```java
// 也可以用二维数组
private boolean[] visited;
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private int m;
private int n;

public boolean exist(char[][] board, String word) {
    if (board == null || board.length == 0 || word == null || word.length() == 0) {
        return false;
    }
    m = board.length;
    n = board[0].length;
    visited = new boolean[m * n];
    char[] wordChar = word.toCharArray();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 只要找到一个就提前return true
            if (dfs(board, wordChar, 0, i, j)) {
                return true;
            }
        }
    }
    return false;
}

public boolean dfs(char[][] board, char[] wordChar, int index, int x, int y) {
    // 搜索到单词字母最后一个 需要返回结果 不需要再深搜 提前return
    if (index == wordChar.length - 1) {
        return board[x][y] == wordChar[index];
    }

    if (board[x][y] == wordChar[index]) {
        visited[x * n + y] = true;
        for (int[] direct : directs) {
            int newX = x + direct[0];
            int newY = y + direct[1];
            // 先判断是否越界
            if (inArea(newX, newY) && !visited[newX * n + newY]) {
                if (dfs(board, wordChar, index + 1, newX, newY)) {
                    return true;
                }
            }
        }
        // 回溯 状态重置 保证在深搜的过程不会去搜重复的，但是退出深搜进行横向遍历的时候可以搜重复的
        visited[x * n + y] = false;
    }
    return false;
}

// 搜索区域是否合法
private boolean inArea(int x, int y) {
    return x >= 0 && y >= 0 && x < m && y < n;
}
```

### 2、N 皇后

#### 题目描述

[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

#### 题解

N 皇后问题是有很多种优化方案的，这是比较经典的解法



**diagSub对角线**

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220212113406422.png)

**diagMain对角线**

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220212113248496.png)





```java
/**
 * 以 4 皇后为例的棋盘
 * [00, 01, 02, 03]
 * [10, 11, 12, 13]
 * [20, 21, 22, 23]
 * [30, 31, 32, 33]
 * <p>
 * 因为数组索引从0开始 我们用索引i - j + n - 1代表处于哪一条左对角线上
 * diagMain[-3, -2, -1, 0, 1, 2, 3] ==> [0, 1, 2, ..., i - j + n - 1]
 * <p>
 * diagSub[0, 1, 2, 3, 4, 5, 6] 用i + j代表代表处于哪一条右对角线上
 */
// 列状态 记录哪一列有皇后
private boolean[] col;
// 记录左上->右下的对角线状态 特点：对角线上每个元素i - j 相等
private boolean[] diagMain;
// 记录右上->左下的对角线状态 特点：对角线上每个元素i + j 相等
private boolean[] diagSub;
private List<List<String>> res = new ArrayList<>();
// 每个完整结果皇后的列坐标
private List<Integer> path = new ArrayList<>();

public List<List<String>> solveNQueens(int n) {
    col = new boolean[n];
    diagMain = new boolean[2 * n - 1];
    diagSub = new boolean[2 * n - 1];
    backTracking(n, 0);
    return res;
}

// index为行坐标
private void backTracking(int n, int index) {
    if (index == n) {
        // 将列坐标结果集转化为棋盘
        List<String> board = convert2board(path,n);
        res.add(board);
        return;
    }

    // 对列遍历 每一列选出一个皇后
    for (int j = 0; j < n; j++) {
        // 不在同一列、不在同一对角线
        if (!col[j] && !diagMain[index - j + n - 1] && !diagSub[index + j]) {
            path.add(j);
            col[j] = true;
            diagMain[index - j + n - 1] = true;
            diagSub[index + j] = true;

            backTracking(n, index + 1);
            // 回溯 状态重置
            path.remove(path.size() - 1);
            col[j] = false;
            diagMain[index - j + n - 1] = false;
            diagSub[index + j] = false;
        }
    }
}

// 将结果的列坐标转换成棋盘 path存储的是所有皇后的列坐标
private List<String> convert2board (List<Integer> path, int n) {
    List<String> board = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        char[] arr = new char[n];
        // 棋盘每一行先填充'.' 在将有皇后的位置修改为'Q'
        Arrays.fill(arr,'.');
        arr[path.get(i)] = 'Q';
        board.add(new String(arr));
    }
    return board;
}
```



### 3、N 皇后2

#### 题目描述

[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

N 皇后是求具体的解（棋盘的布局），而这题是求解的个数

#### 题解

可以直接用上一题的解，返回解的个数

```java
/**
    * 以 4 皇后为例的棋盘
    * [00, 01, 02, 03]
    * [10, 11, 12, 13]
    * [20, 21, 22, 23]
    * [30, 31, 32, 33]
    * <p>
    * 因为数组索引从0开始 我们用索引i - j + n - 1代表处于哪一条左对角线上
    * diagMain[-3, -2, -1, 0, 1, 2, 3] ==> [0, 1, 2, ..., i - j + n - 1]
    * <p>
    * diagSub[0, 1, 2, 3, 4, 5, 6] 用i + j代表代表处于哪一条右对角线上
    */
// 列状态 记录哪一列有皇后
private boolean[] col;
// 记录左上->右下的对角线状态 特点：对角线上每个元素i - j 相等
private boolean[] diagMain;
// 记录右上->左下的对角线状态 特点：对角线上每个元素i + j 相等
private boolean[] diagSub;
private List<List<Integer>> res = new ArrayList<>();
// 每个完整结果皇后的列坐标
private List<Integer> path = new ArrayList<>();

public int totalNQueens(int n) {
    col = new boolean[n];
    diagMain = new boolean[2 * n - 1];
    diagSub = new boolean[2 * n - 1];
    backTracking(n, 0);
    return res.size();
}

// index为行坐标
private void backTracking(int n, int index) {
    if (index == n) {
        res.add(new ArrayList<>(path));
        return;
    }

    // 对列遍历 每一列选出一个皇后
    for (int j = 0; j < n; j++) {
        // 不在同一列、不在同一对角线
        if (!col[j] && !diagMain[index - j + n - 1] && !diagSub[index + j]) {
            path.add(j);
            col[j] = true;
            diagMain[index - j + n - 1] = true;
            diagSub[index + j] = true;

            backTracking(n, index + 1);
            // 回溯 状态重置
            path.remove(path.size() - 1);
            col[j] = false;
            diagMain[index - j + n - 1] = false;
            diagSub[index + j] = false;
        }
    }
}
```



### 4、解数独

#### 题目描述

[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

#### 题解

这题难点是求解状态的表示

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

怎么设置上面的状态是关键

还有怎么加快搜索

```java
// 第二维的大小都设置成 10 是为了让 '1' 落在下标 1 的位置，'9' 落在下标 9 的位置
// row第一维表示哪一行，第二维表示含有哪个数字
private boolean[][] row = new boolean[9][10];
// col第一维表示哪一列，第二维表示含有哪个数字
private boolean[][] col = new boolean[9][10];
// cell 的第一维表示在哪个3*3的宫内
private boolean[][] cell = new boolean[9][10];

public void solveSudoku(char[][] board) {
    // 1 遍历一遍棋盘 将已有的数字设置状态
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                // 减去 '0' 是有 1 个位置的偏移
                int num = board[i][j] - '0';
                row[i][num] = true;
                col[j][num] = true;
                // [i][j] ==> [i / 3][j / 3]将9 * 9的小格缩小成3 * 3的大格
                // [i / 3][j / 3] ==> [i / 3 * 3 + j / 3] 二维转一维
                cell[i / 3 * 3 + j / 3][num] = true;
            }
        }
    }
    // 2 找到第一个为'.'的位置进行dfs搜索 这里至多只会执行n次，因为只是找出一个位置
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                backTracking(board, i * 9 + j);
            }
        }
    }
}

private boolean backTracking(char[][] board, int index) {
    // dfs到最后一个位置说明求解成功
    if (index == 9 * 9) {
        return true;
    }
    // 剪枝 找到下一个为'.'的一维值 否则会超时
    int next = index + 1;
    for (; next < 9 * 9; next++) {
        // 一维==>二维  i * n + j 所以二维坐标的i就等于一维值整除列数，j等于一维值模列数
        if (board[next / 9][next % 9] == '.') {
            break;
        }
    }

    int x = index / 9;
    int y = index % 9;
    for (int i = 1; i <= 9; i++) {
        if (!row[x][i] && !col[y][i] && !cell[x / 3 * 3 + y / 3][i]) {
            row[x][i] = true;
            col[y][i] = true;
            cell[x / 3 * 3 + y / 3][i] = true;
            // 将整型强制类型转换为字符型，JVM 会把数字当成字符的 ASCII 编码来处理
            // 所以要转传成正确的字符，要先加上48再强转，也是加上字符'0'
            board[x][y] = (char) ('0' + i);

            if (backTracking(board, next)) {
                return true;
            }
            // 回溯，状态重置
            row[x][i] = false;
            col[y][i] = false;
            cell[x / 3 * 3 + y / 3][i] = false;
            board[x][y] = '.';
        }
    }

    // 当前解尝试错误
    return false;
}
```



### 5、有效的数独

这题分类不是回溯，只是顺便放到这

#### 题目描述

[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，**验证已经填入的数字是否有效即可**。
- 空白格用 `'.'` 表示。

#### 题解

这题是比解数独简单很多的，因为只需要校验已经填入的部分数字是否有效即可

设置状态的思路是一样的

```java
private boolean[][] row = new boolean[9][10];
private boolean[][] col = new boolean[9][10];
private boolean[][] cell = new boolean[9][10];

public boolean isValidSudoku(char[][] board) {
    // 遍历棋盘
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            // 对已经填入的数字做校验
            if (board[i][j] != '.') {
                int num = board[i][j] - '0';
                // 在三个区域内第一次遇到num 设置为true
                if (!row[i][num] && !col[j][num] && !cell[i / 3 * 3 + j / 3][num]) {
                    row[i][num] = true;
                    col[j][num] = true;
                    cell[i / 3 * 3 + j / 3][num] = true;
                } else {
                    // 否则说明在同一区域内有重复数字出现
                    return false;
                }
            }
        }
    }
    // 遍历完没有非法数字
    return true;
}
```



### FloodFill算法

### 2、岛屿数量

#### 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)



#### 题解

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private boolean[] visited;
private int m;
private int n;

public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    int islands = 0;
    m = grid.length;
    n = grid[0].length;
    visited = new boolean[m * n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1' && !visited[i * n + j]) {
                islands++;
                dfs(grid, i, j);
            }
        }
    }
    return islands;
}

// floodfill算法实质就是深度优先遍历

/**
 * 注意点：
 * 1、这里表面并没有设置递归终止的条件
 * 但是搜索的位置的有限的，并且没有对visited进行状态重置
 * 所以递归的终止条件隐藏在if的判断语句中
 * 2、这个dfs没有回溯的过程，没有对visited进行状态重置，
 * 因为我们的目的只是将最初[i,j]这个位置相连的地方都标记为同一个岛屿而已，
 * 而不是在其中找到某一个具体的序列或值
 **/
private void dfs(char[][] grid, int x, int y) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 位置合法的陆地且没有被访问过
        if (inArea(newX, newY) && grid[newX][newY] == '1' && !visited[newX * n + newY]) {
            dfs(grid, newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && y >= 0 && x < m && y < n;
}
```



### 3、被围绕的区域

#### 题目描述

[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

> 注意：任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。



#### 题解

**DFS**

因为我们要区分出于在边界的'O'及与它相连的'O'，所以我们要从边界，**从外到内dfs**，对这些不需要被填充的成'X'的'O'进行一个标记

这里我用了visited数组，也可以不用，直接将不需要被填充的成'X'的'O'改成其它字符，最后再改回来

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private int m;
private int n;
private boolean[] visited;

public void solve(char[][] board) {
    if (board == null || board.length == 0) {
        return;
    }
    m = board.length;
    n = board[0].length;
    visited = new boolean[m * n];
    //1 对最外面一圈进行dfs，标记与外界相连的'0'
    // 对第一列和最后一列dfs
    for (int i = 0; i < m; i++) {
        if (board[i][0] == 'O') {
            dfs(board, i, 0);
        }
        if (board[i][n - 1] == 'O') {
            dfs(board, i, n - 1);
        }
    }
    // 对第一行和最后一行dfs
    for (int j = 0; j < n; j++) {
        if (board[0][j] == 'O') {
            dfs(board, 0, j);
        }
        if (board[m - 1][j] == 'O') {
            dfs(board, m - 1, j);
        }
    }
    // 2 遍历整个矩阵 将没有被标记到的'0'都填充成'X'
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'O' && !visited[i * n + j]) {
                board[i][j] = 'X';
            }
        }
    }
}

private void dfs(char[][] board, int x, int y) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY) && board[newX][newY] == 'O' && !visited[newX * n + newY]) {
            dfs(board, newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**BFS**

这里标记的过程也可以改成广度优先

**并查集**

另一种思路就是使用并查集

设置一个dummy虚拟节点，所有不需要覆盖的都和它相连，最后在遍历一遍，没有和dummy相连的就置为'X'。



### 4、太平洋大西洋水流问题

#### 问题描述

[417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)



#### 题解

这题跟**被围绕的区域**思路一样，都是**从外层开始dfs**，区别就是需要用两个不同的visited来标记太平洋和大西洋的访问状态



1、找出所有从**太平洋**出发升序的最高顶点

![](https://gitee.com/iamnovo/pic/raw/master/images/1619850901-ToWmLO-8e9c842a24968824d18c4de2c520a6e.png)



2、找出所有从**大西洋**出发升序的最高顶点

![](https://gitee.com/iamnovo/pic/raw/master/images/1619850909-byyyNx-521bfa8063d14254466a5d7f6600ae9.png)

3、这些重合的点最高顶点就是**可以使雨水同时流向太平洋和大西洋的地方**

![](https://gitee.com/iamnovo/pic/raw/master/images/1619850883-mLzTrV-06ce3f99a8742231c3f7d42dcac0c69.png)

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private List<List<Integer>> res = new ArrayList<>();
private boolean[] visitedP; // dfs太平洋状态
private boolean[] visitedA; // dfs大西洋状态
private int m;
private int n;

public List<List<Integer>> pacificAtlantic(int[][] heights) {
    if (heights == null || heights.length == 0) {
        return res;
    }
    m = heights.length;
    n = heights[0].length;
    visitedA = new boolean[m * n];
    visitedP = new boolean[m * n];

    // 对最外面一层dfs
    for (int i = 0; i < m; i++) {
        // 第一列太平洋
        dfs(heights, i, 0, visitedP);
        // 最后一列大西洋
        dfs(heights, i, n - 1, visitedA);
    }
    for (int j = 0; j < n; j++) {
        // 第一行太平洋
        dfs(heights, 0, j, visitedP);
        // 最后一行大西洋
        dfs(heights, m - 1, j, visitedA);
    }
	
    // 遍历整个岛屿 找出重合点
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (visitedA[i * n + j] && visitedP[i * n + j]) {
                List<Integer> position = new ArrayList<>();
                position.add(i);
                position.add(j);
                res.add(new ArrayList<>(position));
            }
        }
    }
    return res;
}

// 找出所有逆向的的终点即山顶位置，visitedP和visitedA的交集就是结果
private void dfs(int[][] heights, int x, int y, boolean[] visited) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 未被访问过的合法区域且heights[x][y] <= heights[newX][newY]即逆向
        if (inArea(newX, newY) && !visited[newX * n + newY] && heights[x][y] <= heights[newX][newY]) {
            dfs(heights, newX, newY, visited);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



# 递归



逻辑图：树状

实际结构：压栈

时间复制度分析

master定理：

(只针对递归问题子规模一致的时候使用)

![image-20220126141702793](https://gitee.com/iamnovo/pic/raw/master/images/image-20220126141702793.png)

n/b 是递归子问题的规模，a是一次方法中调用递归的次数，f(n)是非递归的操作，用O(N^d)来表示非递归的时间复杂度
$$
当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(N^{\log_{b} {a}})\\
1) \log_{b} {a} < d ---> 复杂度为O(N^d)\\

2) \log_{b} {a} > d --> 复杂度为O(N^{\log_{b} {a}})\\

3) \log_{b} {a} = d ----> 复杂度为O(N^d*{\log_{}{N}})\\
$$



### 1、汉诺塔问题

```java
/**
 * 从最左到最右只需要三步：
 * 1.上面 N - 1 的挪去辅助柱
 * 2.剩余的一个挪去最右
 * 3.辅助柱的挪去最右
 */
public static void process(int N, String source, String target, String help) {
    if (N == 1) {
        System.out.println("move 1 from " + source + " to " + target);
    } else {
        // 1.上面 N - 1 的挪去辅助柱
        process(N - 1, source, help, target);
        // 2.剩余的一个挪去最右 打印的是 剩余的一个挪去最右
        System.out.println("move " + N + " from " + source + " to " + target);
        // 3.辅助柱的挪去最右
        process(N - 1, help, target, source);
    }

}

public static void hanoi(int N, String source, String target, String help) {
    process(N, source, target, help);
}
```









































![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220206001808032.png)





# 贪心

### 1、字典序排列最小的等效字符串

正确的贪心策略：字典序 ab < ba,而不是a < b

```java
public static String smallestString(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    Arrays.sort(strs, (String str1, String str2) -> (str1 + str2).compareTo(str2 + str1));
    StringBuilder res = new StringBuilder();
    for (String str : strs) {
        res.append(str);
    }
    return res.toString();
}
```



### 2、最多可以参加的会议数目

```java
public int maxEvents(int[][] events) {
    //首先排序：开始时间小的在前。这样是方便我们顺序遍历，把开始时间一样的都放进堆
    Arrays.sort(events, (o1, o2) -> o1[0] - o2[0]);
    //小顶堆
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    //结果、开始时间、events下标、有多少组数据
    int res = 0, last = 1, i = 0, n = events.length;
    while (i < n || !pq.isEmpty()) {
        //将start相同的会议都放进堆里
        while (i < n && events[i][0] == last) {
            pq.offer(events[i++][1]);
        }
        //pop掉当前天数之前的
        while (!pq.isEmpty() && pq.peek() < last) {
            pq.poll();
        }
        //顶上的就是俺们要参加的
        if (!pq.isEmpty()) {
            pq.poll();
            res++;
        }
        last++;
    }
    return res;
}
```



### 3、金条分割问题

最优二叉树(哈夫曼树)基于贪心算法

（1）准备一个小根堆。将数组放到这个小根堆里。

（2）每次弹出堆顶的两个数求和为A，将A再放回小根堆里。

（3）一直执行第2步，直到堆只剩一个数。最后，每一次第二步A的累加和即是最后的结果。

例如给定的金条长度为150，要分成10、20、30、40、50的块，最后花费的铜板数量即是上图中蓝色圆圈的和，即150+60+90+30=330。

也就是我们代码求解的时候是从叶子往根求的，求完后再从根往叶子即是金条的切割顺序，最后所有的叶子即是需要切成的块的大小。

```java
public static int splitGold(int[] arr) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int i : arr) {
        heap.add(i);
    }
    int payMoney = 0;
    int sum = 0;
    while (heap.size() > 1){
        sum = heap.poll() + heap.poll();
        payMoney += sum;
        heap.add(sum);
    }
    return payMoney;
}
```



### 4、IPO

#### 题目描述

[502. IPO](https://leetcode-cn.com/problems/ipo/)

假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。

最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。

答案保证在 32 位有符号整数范围内。

**示例 1：**

```
输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
```

**示例 2：**

```
输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
输出：6
```



#### 题解

优先队列+贪心



注意一点，启动资金是可以收回来的，所以在本题中项目不会亏本，那么只要**依次选启动资金低于本金里收益最大的项目**，就可以将收益最大化

**这种贪心符合人的思维，就是在能够做的项目里选择利润最大的去做，并不需要证明**

所以准备一个小根堆存入所有项目，从小根堆里取出当前启动资金可以做的所有项目放入另一个大根堆，这个堆按收益排序，这个大根堆堆顶就是一个局部最优，**做完一个项目后，需要更新最大利益堆**，因为此时本金已改变，可以做更多的项目

```java
public static class Project {
    int cost;
    int profit;

    public Project(int cost, int profit) {
        this.cost = cost;
        this.profit = profit;
    }
}

public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    PriorityQueue<Project> minCostHeap = new PriorityQueue<>((o1, o2) -> o1.cost - o2.cost);
    PriorityQueue<Project> maxProfitHeap = new PriorityQueue<>((o1, o2) -> o2.profit - o1.profit);
    // 将项目都加入最小成本堆
    for (int i = 0; i < profits.length; i++) {
        minCostHeap.add(new Project(capital[i], profits[i]));
    }
    for (int i = 0; i < k; i++) {
        // 项目不为空且最小成本堆顶的启动资金小于本金时，加入最大收益堆
        while (!minCostHeap.isEmpty() && minCostHeap.peek().cost <= w) {
            maxProfitHeap.add(minCostHeap.poll());
        }
        // 最大收益堆为空 说明本金w可能小于成本或者项目已经都做完，直接返回w
        if (maxProfitHeap.isEmpty()) {
            return w;
        }
        w += maxProfitHeap.poll().profit;
    }
    return w;
}
```



### 5、点灯问题

#### 题目描述

给定一个字符串str，只由‘X’和‘.’两种字符构成。‘X’表示墙，不能放灯，也不需要点亮。‘.’表示居民点，可以放灯，需要点亮。如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮。返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。



#### 题解

分情况讨论位置情况

![](https://gitee.com/iamnovo/pic/raw/master/images/image-20220203214705835.png)

如果i位置为墙，不放灯，i跳到下一位置

如果i位置为居民点，则往下判断i+1位置的情况，如果i+1为墙，那么灯只能放在i位置，i跳到i+2，如果i+1为居民点，那么继续往下判断i+2位置的情况，如果i+2为墙，灯放在i和i+1位置都可以，i跳到i+3，如果i+2位居民点，那么灯放在i+1位置，i跳到i+3

```java
public static int light(String road) {
    char[] str = road.toCharArray();
    int i = 0;
    int light = 0;
    while (i < str.length) {
        if (str[i] == 'X') {
            i++;
        } else {
            // 无论是那种情况此时必须放灯
            light++;
            if (i + 1 == str.length) {
                break;
            }
            // 有i+1位置的情况
            if (str[i + 1] == 'X') {
                i = i + 2;
            } else {
                i = i + 3;
            }
        }
    }
    return light;
}
```

