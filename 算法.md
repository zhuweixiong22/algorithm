# 对数器



# 二分查找

- 在一个有序数组中，找到某个数是否存在
- 在一个有序(升序)数组中，找 >= 某个数最左侧的位置
- 在一个有序(升序)数组中，找 <= 某个数最右侧的位置
- 局部最小值问题



### 局部最小值问题

二分不一定要有序：数据状况特殊，问题特殊，只要能找出数据的排他性，有一半数据肯定有，另一半数据不确定，那就可以砍一半用二分。

给出一个无序且相邻两个数不相等的数组，找出一个局部最小数（找谷底）

给出局部最小定义：

[0]位置时，只要[0] < [1]，那么[0]就是局部最小

[N - 1]位置时，只要[N - 2] > [N - 1]，那么[N - 1]就是局部最小

[i]位置(不在0和N - 1)，需要[i - 1] > [i] < [i + 1]



先特判两个边界，若找到了其中一个就返回

若找不到，则说明左边界单调递减，右边界单调递增，所以1 ~ N - 2 间一定会有最小值

![image-20220123214403131](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123214403131.png)

二分找中间，如果此时找到了直接返回

![image-20220123214955679](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123214955679.png)

若找不到，则有三种情况单调递增、单调递减和i为局部最大，无论哪种情况都至少存在一个区域可以继续二分找出局部最小值。

![image-20220123215200995](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215200995.png)

![image-20220123215328950](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215328950.png)

![image-20220123215406873](https://gitee.com/iamnovo/pic/raw/master/images/image-20220123215406873.png)



# 位运算



异或定义：无进位相加

性质

- 0 ^ N == N
- N ^ N == 0
- 满足结合律和交换律，所以同一批数异或，无论是什么顺序，结果唯一



### 1、如何不用额外空间交换两个数

```java
a = a ^ b;
b = a ^ b; //证明：b = a ^ b ==> (a ^ b) ^ b ==> a ^ (b ^ b) ==> a ^ 0 ==> a
a = a ^ b; //证明：a = a ^ b ==> (a ^ b) ^ a ==> (a ^ a) ^ b ==> 0 ^ b ==> b
```

**注意前提是：a和b在内存中的位置不相等(即a和b有各自独立的内存区域,a和b的值可以一眼)，如果a和b指向同一块内存，执行三行代码后会变成0**



### 2、一个数组中有一个数出现了奇数次，其余数均出现偶数次，打印出出现奇数次的数

例：[4,3,4,2,4,3,1,2,1,1,1,3] 打印出4

普通方法：哈希表

异或运算：

只需要定义一个XOR初始值为0，XOR遍历数组异或每一个数，即`XOR = XOR ^ arr[i];或 XOR ^= arr[i] `或最终得到的结果就是所求值。

证明：同一批数异或，无论是什么顺序，结果唯一，

所以最终结果可以写成=XOR ^ (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (4 ^ 4 ^ 4)

因为偶数个本身异或为0，所以只剩下 4 ^ 4 ^ 4 ==> 0 ^ 4 ==> 4



### 3、怎么把一个int类型的数，提取出最右侧的1(二进制)

例：    1100100

得到：0000100

求补运算：找到最近的1，后面的全部取反

那我们将 **a**与**求补后的a** 做**与运算**，就能得到结果，因为a[原]和a[补]在最近1后面的数都相反，在最近1前面的数都为0。

注意：因为在计算机中的运算都是以补码进行运算，所以上面的参与运算的a实际上是a[补]，对a[补]求补就是[-a]补，所以在编程上求补运算就是求相反数也等于 ~a + 1

```java
//正数
12
原码：0000 1100
补码：0000 1100
补码再求补：
     1111 0100 
原码：1000 1100  (十进制：-12)
即 ~12=-12
//负数
-12
原码：1000 1100
补码：1111 0100
补码再求补：
     0000 1100 
原码：0000 1100  (十进制：12)
即 ~12=12
```



### 4、一个数组中有两种数出现了奇数次，其它数均出现偶数次，找到并打印出这两种数

假设两种数分别为a，b

1、定义XOR1 == 0，对这批数连续异或赋值给XOR1，最后结果为XOR1 == a ^ b

又因为a != b (两种数) ，所以XOR1 != 0，==> XOR1的二进制数中肯定有1

2、我们随便取出XOR其中一个位置的1(比如取最右侧的1)定义为onlyOne

用该位置(onlyOne)是否为1**划分出两组数**，**目的是将a、b分离**，a、b必然不在同一组(因为在该位置异或为1)

```java
//用与运算判断，因为onlyOne只有一个1，所以与运算结果要么为0，要么不为0(具体值不确定)
if ((arr[i] & onlyOne) != 0)// 说明该位置有1
if ((arr[i] & onlyOne) == 0)// 说明该位置无1
```

3、再定义一个XOR2  == 0，对其中一组数连续异或赋值给XOR2，最终结果就为a或b

因为无论在哪一组数中除了a或b其余数都为偶数个

4、知道a或b其中一个了，XOR1 ^ XOR2 就是另一个数，如XOR2 == a,XOR1 ^ XOR2 == a ^ b ^ a == b  



### 5、一个数组中有一种数出现K次，其余数均出现M次且M > 1,K < M,找出出现K次的数

要求，空间复制度O(1)，时间复杂度O(N)

假设是int型的数(二进制32位)

1、开辟一个大小为32的count数组去存储该数组所有数二进制每一位的状态

即将所有数的二进制进行算术运算相加（例1+1=2），最终count每一位都记录着数组二进制和中对应位为1的次数

```java
arr：[18,10,10,11,11] K == 1,M == 2
10		00...001100
10		00...001100
11		00...001101
11		00...001101
18		00...010010
count  [00...014412]
```

就会发现count[i]%M == 0的位置18的二进制数必为0,因为是M的倍数，又K<M

所以只要count[i]%M != 0的位置18二进制数为1,我们把这些位置全找出来，所求数就确定了

2、如何存储

```java
//二重循环，将arr中每一个num的每一位依次累加到count数组
//虽然是两个for，但是内循环次数确定(32)，所以是O(N)
for (int num : arr) {
    for (int i = 0; i < 32; i++) {
	  /*if (((num >> i) & 1) != 0) { // 与1(00...001)进行与运算不等于0说明比较的第i位为1,就累加
              count[i]++;
		}*/
        // 优化版本 (count[i] >> i)为0的时候再与1 相当于+0 等于不累加
        count[i] += ((num >> i) & 1);
    }
}
```

3、把count数组还原为对应的值

就是将符合条件的位置上填1的过程

```java
int res = 0;
for (int i = 0; i < 32; i++) {
	if ((count[i] % m) != 0) { // 说明i位上 出现k次那个数的二进制数不为0(即为1)
		res |= (1 << i); // 0依次或上第i位上的1 从右至左在符合条件的位置上填1
	}
}
```



# 数据结构

## 链表

### 1、单双链表反转

```java
ListNode<T> pre = null;
ListNode<T> cur = head;
ListNode<T> next = null;
while (cur != null) {
    next = cur.next; //记录next
    cur.next = pre; // 当前next指向pre
    pre = cur; // 将当前节点设置为pre
    cur = next;// cur后移
}
return pre;
```

```java
DoubleListNode<T> pre = null;
DoubleListNode<T> cur = head;
DoubleListNode<T> next = null;
while (cur != null) {
    next = cur.next; // 记录next
    cur.next = pre; // 修改cur的pre和next 顺序无所谓
    cur.pre = next; // 因为将cur.next保存给next了 所以先反转pre还是next的顺序无所谓
    pre = cur; // 将当前节点设置为pre
    cur = next; // cur后移 等价于cur = cur.pre 反转前的next值
}
return pre;
```



### 2、删除单链表中给定值并返回新的head



### 3、双链表实现双端队列、队列、栈



## 队列和栈

### 4、数组实现队列和栈

### 5、最小栈设计

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

1、创建两个栈，一个数据栈，一个最小栈，最小栈的栈顶为最小值

2、怎么维护最小栈的栈顶为元素最小值

- 第一种方法：

  入栈情况：

  - 当最小栈为空，第一个进入的元素就进最小栈（数据栈正常入栈）
  - 当最小栈不为空，且入栈的元素**小于等于**最小栈栈顶，才进入最小栈（数据栈正常入栈）

  出栈情况：

  - 当数据栈出栈的元素等于最小栈栈顶时，最小栈同时出栈，否则只有数据栈出栈

- 第二种方法：

  入栈情况：

  - 数据栈和最小栈同步入栈，但是只有入栈元素小于最小栈栈顶时，才将该元素入最小栈，否则将最小栈栈顶入最小栈

  出栈情况：

  - 同步出栈

> 注意第一种方法，等于的时候也要入最小栈的，因为数据栈肯定是要正常入栈的，当这个元素出栈时最小栈也要出栈，而此时数据栈有重复的元素，最小栈只有一个，会出错。



### 6、用队列实现栈

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

两个队列实现：

1、将原队列的元素导入另一个辅助队列直到只剩下一个元素，输出

2、将两队列地址互换，改变输入的队列

3、重复上述过程

![image-20220125183527993](https://gitee.com/iamnovo/pic/raw/master/images/image-20220125183527993.png)



一个队列实现：

只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

![image-20220125184034130](https://gitee.com/iamnovo/pic/raw/master/images/image-20220125184034130.png)





### 7、用栈实现队列

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 必须是popStack为空才能倒数据
- 如果导数据，必须从pushStack一次性倒完

只要满足上面两个要求，导数据的时机什么时候都可以，可以在每次push操作后，也可以在每次pop或peek的时候导，或者push和pop操作都导。



## 哈希表

增删改查复杂度都认为是O(1)，但是这个常数级别有点大

哈希表存入非基础数据类型占用内存非常小，只会记录引用值，不会复制值

```java
Integer a = 1111111111;
Integer b = 1111111111;
Student student1 = new Student(2);
Student student2 = new Student(2);
HashMap<Student,String> map1 = new HashMap<>();
HashMap<Integer,String> map = new HashMap<>();

// 基础数据类型的包装类且范围不在常量池，存放在哈希表中时，根据值匹配，属同一对象。
map.put(a,"我是a");
System.out.println(map.containsKey(b));

// 非包装类的引用类型，存放在哈希表中时，根据引用值匹配，不属同一对象。
map1.put(student2,"student2");
System.out.println(map1.containsKey(student1));
```



## 有序表

TreeMap 有序表 只是一个接口

能实现有序表的：红黑树、AVL树、SBT(Size Balanced Tree)、跳表

增删改查时间复杂度都是O(logN),功能比有序表强大

Java中TreeMap是用红黑树实现的



非数值类型和String类型传入TreeMap需要自己定义比较器，否则会报错

# 递归

逻辑图：树状

实际结构：压栈

时间复制度分析

master定理：

(只针对递归问题子规模一致的时候使用)

![image-20220126141702793](https://gitee.com/iamnovo/pic/raw/master/images/image-20220126141702793.png)

n/b 是递归子问题的规模，a是一次方法中调用递归的次数，f(n)是非递归的操作，用O(N^d)来表示非递归的时间复杂度
$$
当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(N^{\log_{b} {a}})\\
1) \log_{b} {a} < d ---> 复杂度为O(N^d)\\

2) \log_{b} {a} > d --> 复杂度为O(N^{\log_{b} {a}})\\

3) \log_{b} {a} = d ----> 复杂度为O(N^d*{\log_{}{N}})\\
$$




# 排序

## 归并排序

**平均时间复杂度： O(NLogN) **

**最好情况时间复杂度： O(NLogN)**

**最差情况时间复杂度： O(NLogN)**

**所需要额外空间： 递归：O(N + LogN)， 非递归：O（N）**

**稳定性： 稳定**

归并排序基于**分治**（快排也是）

归并排序其实要做两件事：

（1）“分解”——将序列每次折半划分。

（2）“合并”——将划分后的序列段两两合并后排序。



### 1、数组小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子
[1,3,4,2,5]
1左边比1小的数：0
3左边比3小的数：1
4左边比4小的数：1,3
2左边比2小的数：1
5左边比5小的数：1,3,4,2
所以小和为1+1+3+1+1+3+4+2=16

**转换思想：每一个数左边比当前数小的数累加-->如果a右边的数有多少个数比a大，就产生多少个a**

![image-20220126214210314](https://gitee.com/iamnovo/pic/raw/master/images/image-20220126214210314.png)

例 原数组[3,2,4,1,5,6,3,0]的归并过程：

我们从2这一个数的视角，来感受求该数小和的过程

- 步长为1：

  3,2是作为准备merge后的大组，而2作为里面的右组，是不会产生小和的，但2作为左组例[2,3]和[1,4]merge的时候才会去跟右组[1,4]比较产生小和

- 步长为2：

  [2,3]和[1,4]merge，此时2作为左组，与右组的数比较，有一个4比2大，产生一个2

- 步长为4：

  [1,2,3,4]和[0,3,5,6]merge，2作为左组，与右组的数比较，3、5、6都比2大，产生三个2

- 步长为8：归并结束，上述过程一共产生四个2，所以2右边一共是有四个数比2大的，需要累加四次2

**merge过程中p2移动的方向，如果是升序，p2就从左往右移动，比较一次的前提下才能知道有多少个数比a大**




### 2、数组中逆序对个数

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

同上面一道题，转换为**-->如果a右边的数有多少个数比a小，就产生多少个a**

不同的是p2移动的方向，如果是升序，p2就从右往左移动，比较一次的前提下才能知道有多少个数比a小

315（和本题一样）,327,493,



### 3、数组中x右边有多少个数*2后小于该元素的个数

求总个数

> 注意:这题看似和第二题没有什么区别，但是有个坑，第二题是直接比x小的个数，所以p1、p2指针是从右往左移动的，但是这题不可以，比如

![image-20220127160712721](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127160712721.png)



此时arr[p2] * 2  > arr[p1],我们希望p2继续像左检索寻找符合条件的数，但是又因为arr[p2]已经大于arr[p1]了，arr[p2]是要合并到mergeArr中的并且p1--，这种情况显然从右往左是不行的。

![image-20220127161006163](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127161006163.png)

解决方法一：从右往左

把记录题解的代码和merge的代码分离开，复制p1、p2指针，不要写在同一块里

```java
public static int merge(int[] arr, int L, int M, int R) {
    int[] mergeArr = new int[R - L + 1];
    int i = mergeArr.length - 1;
    int p1 = M;
    int p2 = R;
    int res = 0;
    int p3 = p1;
    int p4 = p2;
    // 记录题解
    while (p3 >= L && p4 > M) {
        if (arr[p3] > arr[p4] * 2) {
            res += p4 - M;
            p3--;
        } else {
            p4--;
        }
    }
    // 正常merge
    while (p1 >= L && p2 > M) {
        mergeArr[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
    }
    while (p1 >= L) {
        mergeArr[i--] = arr[p1--];
    }
    while (p2 > M) {
        mergeArr[i--] = arr[p2--];
    }
    for (i = 0; i < mergeArr.length; i++) {
        arr[L + i] = mergeArr[i];
    }
    return res;
}
```

解决方法二：从左往右

![image-20220127163807301](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127163807301.png)



从左往右，此时右边没有数 * 2 < arr[p1], 数量为0，p1右移至4，p2右移至arr[p2] * 2 不小于arr[p1]的地方，则满足条件的元素有p2 - M个

> p2是不用后退的，因为是升序，既然arr[p1] > arr[p2] * 2，所以有arr[p1 + n] > arr[p2] * 2 (n > 0)

![image-20220127164125900](https://gitee.com/iamnovo/pic/raw/master/images/image-20220127164125900.png)



### 总结

**指针不回退的本质就是单调性**

本质就是mergeSort过程把比较信息变成了有序的，从而加快我们求解

归并升序的情况：

数组中求x右边的情况：相等的时候merge过程就先拷贝右边的，因为我们是想知道x右边数的状况，所以我们需要先移动右组的指针

求右边多少个数比x小，就从右往左merge

求右边多少个数比x大，就从左往右merge



设区间和表示为Aij, 前缀和表示为Si

假设Sj已知

求以j位置结尾的子数组区间和有多少个落在[lower,uppper]上

==> lower <= Aij <= upper

==> lower <= Sj - Si-1 <= upper

==> Sj - upper <= Si-1 <= Sj - lower

因为i <= j （区间长度可以为1）

也就是说我们只需要求在j之前有多少个前缀和落在这个区间上

所以现在我们只需要用到前缀和数组，原数组已经没有用了





> 前缀和头部插入值为 0 的元素，可简化边界处理









