对数器





# 二分查找

- 在一个有序数组中，找到某个数是否存在
- 在一个有序(升序)数组中，找 >= 某个数最左侧的位置
- 在一个有序(升序)数组中，找 <= 某个数最右侧的位置
- 局部最小值问题



### 局部最小值问题

二分不一定要有序：数据状况特殊，问题特殊，只要能找出数据的排他性，有一半数据肯定有，另一半数据不确定，那就可以砍一半用二分。

给出一个无序且相邻两个数不相等的数组，找出一个局部最小数（找谷底）

给出局部最小定义：

[0]位置时，只要[0] < [1]，那么[0]就是局部最小

[N - 1]位置时，只要[N - 2] > [N - 1]，那么[N - 1]就是局部最小

[i]位置(不在0和N - 1)，需要[i - 1] > [i] < [i + 1]



先特判两个边界，若找到了其中一个就返回

若找不到，则说明左边界单调递减，右边界单调递增，所以1 ~ N - 2 间一定会有最小值

![image-20220123214403131](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123214403131.png)

二分找中间，如果此时找到了直接返回

![image-20220123214955679](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123214955679.png)

若找不到，则有三种情况单调递增、单调递减和i为局部最大，无论哪种情况都至少存在一个区域可以继续二分找出局部最小值。

![image-20220123215200995](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123215200995.png)

![image-20220123215328950](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123215328950.png)

![image-20220123215406873](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123215406873.png)



# 位运算



异或定义：无进位相加

性质

- 0 ^ N == N
- N ^ N == 0
- 满足结合律和交换律，所以同一批数异或，无论是什么顺序，结果唯一



### 1、如何不用额外空间交换两个数

```java
a = a ^ b;
b = a ^ b; //证明：b = a ^ b ==> (a ^ b) ^ b ==> a ^ (b ^ b) ==> a ^ 0 ==> a
a = a ^ b; //证明：a = a ^ b ==> (a ^ b) ^ a ==> (a ^ a) ^ b ==> 0 ^ b ==> b
```

**注意前提是：a和b在内存中的位置不相等(即a和b有各自独立的内存区域,a和b的值可以一眼)，如果a和b指向同一块内存，执行三行代码后会变成0**



### 2、一个数组中有一个数出现了奇数次，其余数均出现偶数次，打印出出现奇数次的数

例：[4,3,4,2,4,3,1,2,1,1,1,3] 打印出4

普通方法：哈希表

异或运算：

只需要定义一个XOR初始值为0，XOR遍历数组异或每一个数，即`XOR = XOR ^ arr[i];或 XOR ^= arr[i] `或最终得到的结果就是所求值。

证明：同一批数异或，无论是什么顺序，结果唯一，

所以最终结果可以写成=XOR ^ (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (4 ^ 4 ^ 4)

因为偶数个本身异或为0，所以只剩下 4 ^ 4 ^ 4 ==> 0 ^ 4 ==> 4



### 3、怎么把一个int类型的数，提取出最右侧的1(二进制)

例：    1100100

得到：0000100

求补运算：找到最近的1，后面的全部取反

那我们将 **a**与**求补后的a** 做**与运算**，就能得到结果，因为a[原]和a[补]在最近1后面的数都相反，在最近1前面的数都为0。

注意：因为在计算机中的运算都是以补码进行运算，所以上面的参与运算的a实际上是a[补]，对a[补]求补就是[-a]补，所以在编程上求补运算就是求相反数也等于 ~a + 1

```java
//正数
12
原码：0000 1100
补码：0000 1100
补码再求补：
     1111 0100 
原码：1000 1100  (十进制：-12)
即 ~12=-12
//负数
-12
原码：1000 1100
补码：1111 0100
补码再求补：
     0000 1100 
原码：0000 1100  (十进制：12)
即 ~12=12
```



### 4、一个数组中有两种数出现了奇数次，其它数均出现偶数次，找到并打印出这两种数

假设两种数分别为a，b

1、定义XOR1 == 0，对这批数连续异或赋值给XOR1，最后结果为XOR1 == a ^ b

又因为a != b (两种数) ，所以XOR1 != 0，==> XOR1的二进制数中肯定有1

2、我们随便取出XOR其中一个位置的1(比如取最右侧的1)定义为onlyOne

用该位置(onlyOne)是否为1**划分出两组数**，**目的是将a、b分离**，a、b必然不在同一组(因为在该位置异或为1)

```java
//用与运算判断，因为onlyOne只有一个1，所以与运算结果要么为0，要么不为0(具体值不确定)
if ((arr[i] & onlyOne) != 0)// 说明该位置有1
if ((arr[i] & onlyOne) == 0)// 说明该位置无1
```

3、再定义一个XOR2  == 0，对其中一组数连续异或赋值给XOR2，最终结果就为a或b

因为无论在哪一组数中除了a或b其余数都为偶数个

4、知道a或b其中一个了，XOR1 ^ XOR2 就是另一个数，如XOR2 == a,XOR1 ^ XOR2 == a ^ b ^ a == b  



### 5、一个数组中有一种数出现K次，其余数均出现M次且M > 1,K < M,找出出现K次的数

要求，空间复制度O(1)，时间复杂度O(N)

假设是int型的数(二进制32位)

1、开辟一个大小为32的count数组去存储该数组所有数二进制每一位的状态

即将所有数的二进制进行算术运算相加（例1+1=2），最终count每一位都记录着数组二进制和中对应位为1的次数

```java
arr：[18,10,10,11,11] K == 1,M == 2
10		00...001100
10		00...001100
11		00...001101
11		00...001101
18		00...010010
count  [00...014412]
```

就会发现count[i]%M == 0的位置18的二进制数必为0,因为是M的倍数，又K<M

所以只要count[i]%M != 0的位置18二进制数为1,我们把这些位置全找出来，所求数就确定了

2、如何存储

```java
//二重循环，将arr中每一个num的每一位依次累加到count数组
//虽然是两个for，但是内循环次数确定(32)，所以是O(N)
for (int num : arr) {
    for (int i = 0; i < 32; i++) {
	  /*if (((num >> i) & 1) != 0) { // 与1(00...001)进行与运算不等于0说明比较的第i位为1,就累加
              count[i]++;
		}*/
        // 优化版本 (count[i] >> i)为0的时候再与1 相当于+0 等于不累加
        count[i] += ((num >> i) & 1);
    }
}
```

3、把count数组还原为对应的值

就是将符合条件的位置上填1的过程

```java
int res = 0;
for (int i = 0; i < 32; i++) {
	if ((count[i] % m) != 0) { // 说明i位上 出现k次那个数的二进制数不为0(即为1)
		res |= (1 << i); // 0依次或上第i位上的1 从右至左在符合条件的位置上填1
	}
}
```

# 排序

## 比较器

实现Comparator< T>接口，调用系统一些容器的sort的函数时，把比较器传进去

```java
public static class IdAscendingComparator implements Comparator<Student> {
    // 返回负数的时候，第一个参数排在前面
    // 返回正数的时候，第二个参数排在前面
    // 返回0的时候，两个参数等级相等
    @Override
    public int compare(Student o1, Student o2) {
        //return o1.getId() - o2.getId();
        //return o2.getAge() -o1.getAge();
        // id升 如果id相等 比较age 降序
        return !o1.getId().equals(o2.getId()) ? o1.getId() - o2.getId() : o2.getAge() - o1.getAge();
    }
}
//
list.sort(new IdAscendingComparator());
Arrays.sort(students, new IdAscendingComparator());
```



## 归并排序

**平均时间复杂度： O(NLogN) **

**最好情况时间复杂度： O(NLogN)**

**最差情况时间复杂度： O(NLogN)**

**所需要额外空间： 递归：O(N + LogN)， 非递归：O（N）**

**稳定性： 稳定**

归并排序基于**分治**（快排也是）

归并排序其实要做两件事：

（1）“分解”——将序列每次折半划分。

（2）“合并”——将划分后的序列段两两合并后排序。



### 1、数组小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子
[1,3,4,2,5]
1左边比1小的数：0
3左边比3小的数：1
4左边比4小的数：1,3
2左边比2小的数：1
5左边比5小的数：1,3,4,2
所以小和为1+1+3+1+1+3+4+2=16

**转换思想：每一个数左边比当前数小的数累加-->如果a右边的数有多少个数比a大，就产生多少个a**

![image-20220126214210314](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220126214210314.png)

例 原数组[3,2,4,1,5,6,3,0]的归并过程：

我们从2这一个数的视角，来感受求该数小和的过程

- 步长为1：

  3,2是作为准备merge后的大组，而2作为里面的右组，是不会产生小和的，但2作为左组例[2,3]和[1,4]merge的时候才会去跟右组[1,4]比较产生小和

- 步长为2：

  [2,3]和[1,4]merge，此时2作为左组，与右组的数比较，有一个4比2大，产生一个2

- 步长为4：

  [1,2,3,4]和[0,3,5,6]merge，2作为左组，与右组的数比较，3、5、6都比2大，产生三个2

- 步长为8：归并结束，上述过程一共产生四个2，所以2右边一共是有四个数比2大的，需要累加四次2

**merge过程中p2移动的方向，如果是升序，p2就从左往右移动，比较一次的前提下才能知道有多少个数比a大**




### 2、数组中逆序对个数

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

同上面一道题，转换为**-->如果a右边的数有多少个数比a小，就产生多少个a**

不同的是p2移动的方向，如果是升序，p2就从右往左移动，比较一次的前提下才能知道有多少个数比a小

315（和本题一样）,327,493,



### 3、数组中x右边有多少个数*2后小于该元素的个数

求总个数

> 注意:这题看似和第二题没有什么区别，但是有个坑，第二题是直接比x小的个数，所以p1、p2指针是从右往左移动的，但是这题不可以，比如

![image-20220127160712721](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127160712721.png)



此时arr[p2] * 2  > arr[p1],我们希望p2继续像左检索寻找符合条件的数，但是又因为arr[p2]已经大于arr[p1]了，arr[p2]是要合并到mergeArr中的并且p1--，这种情况显然从右往左是不行的。

![image-20220127161006163](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127161006163.png)

解决方法一：从右往左

把记录题解的代码和merge的代码分离开，复制p1、p2指针，不要写在同一块里

```java
public static int merge(int[] arr, int L, int M, int R) {
    int[] mergeArr = new int[R - L + 1];
    int i = mergeArr.length - 1;
    int p1 = M;
    int p2 = R;
    int res = 0;
    int p3 = p1;
    int p4 = p2;
    // 记录题解
    while (p3 >= L && p4 > M) {
        if (arr[p3] > arr[p4] * 2) {
            res += p4 - M;
            p3--;
        } else {
            p4--;
        }
    }
    // 正常merge
    while (p1 >= L && p2 > M) {
        mergeArr[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
    }
    while (p1 >= L) {
        mergeArr[i--] = arr[p1--];
    }
    while (p2 > M) {
        mergeArr[i--] = arr[p2--];
    }
    for (i = 0; i < mergeArr.length; i++) {
        arr[L + i] = mergeArr[i];
    }
    return res;
}
```

解决方法二：从左往右

![image-20220127163807301](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127163807301.png)



从左往右，此时右边没有数 * 2 < arr[p1], 数量为0，p1右移至4，p2右移至arr[p2] * 2 不小于arr[p1]的地方，则满足条件的元素有p2 - M个

> p2是不用后退的，因为是升序，既然arr[p1] > arr[p2] * 2，所以有arr[p1 + n] > arr[p2] * 2 (n > 0)

![image-20220127164125900](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127164125900.png)



### 总结

**指针不回退的本质就是单调性**

本质就是mergeSort过程把比较信息变成了有序的，从而加快我们求解

归并升序的情况：

数组中求x右边的情况：相等的时候merge过程就先拷贝右边的，因为我们是想知道x右边数的状况，所以我们需要先移动右组的指针

求右边多少个数比x小，就从右往左merge

求右边多少个数比x大，就从左往右merge



### 4、区间和的个数

[区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

前缀和+归并排序



> 注意：
>
> 前缀和头部插入值为 0 的元素，可简化边界处理
>
> 前缀和数组不是递增的，因为可能有负数

设区间和表示为Aij, 前缀和表示为Si

假设Sj已知

求以j位置结尾的子数组区间和有多少个落在[lower,uppper]上

==> lower <= Aij <= upper

==> lower <= Sj - Si-1 <= upper

==> Sj - upper <= Si-1 <= Sj - lower

因为i <= j （区间长度可以为1）

也就是说我们只需要求在j之前有多少个前缀和落在这个区间上

所以现在我们只需要用到前缀和数组，原数组已经没有用了



## 快速排序

注意边界问题

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    process(arr, 0, arr.length - 1);
}
public static void process(int[] arr, int L, int R) {
    // 注意边界i 有可能跨过去右边
    if (L >= R) {
        return;
    }
    int i = L - 1;
    int j = R + 1;
    int pivot = arr[L + ((R - L) >> 1)];
    while (i < j) {
        do i++; while (arr[i] < pivot);
        do j--; while (arr[j] > pivot);
        if (i < j) {
            swap(arr, i, j);
        }
    }
    // 因为i可能先跨过去,因为do是i操作先 所以跨过去的i位置是没有验证的
    // 而j++是后do的 退出while时j的位置一定是被验证过的
    // 左递归只能穿[L i-1] 或者[L   j]
    // 右递归只能传[i   R] 或者[j+1 R]
    process(arr, L, j);
    process(arr, j+1, R);
}
```



## 堆排序

**堆（优先队列）：**

大根堆：满足根结点>子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

小根堆：满足根结点<子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

完全二叉树：

> **i 结点的左孩子：2 * i + 1，i 结点的右孩子2 * i+2 ，i 结点的父结点 (i - 1)/2 下取整**



**建堆**

如果数据是一次传进来的，可以从下往上建堆，建堆的时间复杂度是可以达到O(N)的

> 分析一下复杂度，因为堆的叶子结点有N / 2个，叶子结点的下沉成本距离为1,只会进行一次while判断,
>
> 叶子结点的上一层有N / 4 个，下沉成本为2，以此类推，下沉成本和深度有关,设有4层
>
> 总下沉成本T(N) = N/2 * 1 + N/4 * 2 + N/8 * 3 + N/16 * 4
>
> ​          2T(N) = N + N/2 * 2 + N/4 * 3 + N/8 * 4
>
> 相减=>T(N) = N + N/2  + N/4  ...  - N/16 显然时间复杂度为O(N)

```java
for (int i = arr.length - 1; i >= 0; i--) {
    // 从下往上建堆 不断调用heapify调整下沉
	heapify(arr, i, arr.length);
}
```



如果数据是一个一个传进来的，只能从上往下建堆，时间复制度O(N*logN)

```java
for (int i = 0; i < arr.length; i++) {
    // 从上往下建堆 不断调用heapInsert调整上浮
	heapInsert(arr, i);
}
```



**维护堆**

堆排序

堆排序额外空间复杂度O(1)

排序过程O(N*logN)

```java
public static void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 建堆的过程
    /*// 从上往下建堆 逐个读入O(logN)
    for (int i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }*/
    // 从下往上建堆 一次读入 O(N)
    for (int i = arr.length - 1; i >= 0; i--) {
        heapify(arr, i, arr.length);
    }
    int heapSize = arr.length;
    
    // 堆排序的过程 靠首尾交换取得最大值从而手动打乱堆 再调用heapify来不断维护 不断获得最值
    swap(arr, 0, --heapSize);
    while (heapSize > 0) {
        heapify(arr, 0, heapSize);
        // 交换后堆大小减一 是逻辑删除该值
        swap(arr, 0, --heapSize);
    }
}
```



### 1、对一个几乎有序的数组进行排序

几乎有序是指，如果把数组排好序，每个元素师移动的距离一定不超过k，并且k大小相对数组长度是较小的，设置合适的排序策略。

使用长度为k + 1的堆来维护存放每个位置上可能出现的元素

例如设k = 5，排序后索引为0的位置的元素只可能是原数组中索引为[0-5]的位置

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
    if (k == 0) {
        return;
    }
    // 默认小根堆
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    int index = 0;
    // k如果大于数组长度，则都放进堆里
    // 先放k + 1个数进入堆
    for (; index < Math.min(arr.length, k); index++) {
        heap.add(arr[index]);
    }
    int i = 0;
    // 弹出堆顶 放入一个 直到数组中所以元素都进入到堆中
    for (; index < arr.length; i++, index++) {
        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    // 弹出堆中所有元素
    while (!heap.isEmpty()) {
        arr[i++] = heap.poll();
    }
}
```



### 2、最大线段重合问题

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

类似[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)



定义：一条线段尾坐标 == 另一条线段头坐标不算有交集(只有一个点重合)

两条不同线段，如果一条线段尾坐标  > 另一条线段头坐标，说明这两条线段有交集

1、将所有线段按头坐标从小到大排序

**借助小根堆存储线段的尾坐标**

2、从小到大遍历每条线段，比较**遍历到的线段**和**小根堆内的尾坐标**，**将小根堆中 <= 该线段的头坐标移除**(说明当前线段与移除的掉的线段没有交集)，**小根堆剩下的尾坐标个数就为与该线段有交集的个数（除去本身）**，**切换到下一线段前，将自身尾坐标加入小根堆**

> 如果求的是有多少条线段重合，则先把自身加入，小根堆的当前的个数就是有多少条线段重合



# 数组

# 哈希表

### 两个数组的交集 II

#### 题目描述

[LeetCode350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

 **提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

 **进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
- 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？



#### 题解

**纯List**

自己实现List的删除给定元素

总时间复杂度`O(n^2)`

```java
public int[] intersect(int[] nums1, int[] nums2) {
    List<Integer> list = new ArrayList<>();
    List<Integer> res = new ArrayList<>();
    for (int x : nums1) {
        list.add(x);
    }
    for (int x : nums2) {
        if (list.contains(x)) {
            remove(list, x);
            res.add(x);
        }
    }

    return res.stream().mapToInt(Integer::intValue).toArray();
}

// list删除指定元素 注意要逆序遍历 避免删除后长度发生变化引起越界
private void remove(List<Integer> list, int val) {
    for (int i = list.size() - 1; i >= 0; i--) {
        if (list.get(i) == val) {
            list.remove(i);
            // 题目要求 一次删除一个
            break;
        }
    }
}
```



**哈希表**

时间复杂度`O(m + n)`

```java
public int[] intersect2(int[] nums1, int[] nums2) {
    // nums中元素可以重复 所以次数有意义 可以用map
    Map<Integer, Integer> map = new HashMap<>();
    List<Integer> list = new ArrayList<>();
    for (int x : nums1) {
        map.put(x, map.getOrDefault(x, 0) + 1);
    }
    for (int x : nums2) {
        if (map.containsKey(x) && map.get(x) > 0) {
            // 用掉一次，减一
            map.put(x, map.get(x) - 1);
            list.add(x);
        }
    }
    return list.stream().mapToInt(Integer::intValue).toArray();
}
```



**排序+双指针**

如果给定数组已经有序，则可以使用双指针来优化

哪个指针所指向的值小，则指针++，若相等则加入结果集

```java
public int[] intersect(int[] nums1, int[] nums2) {
    // 假定已经排好序
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int i = 0;
    int j = 0;
    List<Integer> res = new ArrayList<>();
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] == nums2[j]) {
            res.add(nums1[i]);
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    
    return res.stream().mapToInt(Integer::intValue).toArray();
}
```



**归并外排**

对于大量数据来说，数据太大而无法全部都将数据加载到内存中，这时候就需要外排序。



### 有效的字母异位词

#### 题目描述

[LeetCode242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

 **示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

 

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？



#### 题解

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    // 给定字符串会有重复，与次数有关，使用map
    Map<Character, Integer> map = new HashMap<>();
    char[] arr1 = s.toCharArray();
    char[] arr2 = t.toCharArray();
    boolean flag = true;
    for (char c : arr1) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    for (char c : arr2) {
        if (map.containsKey(c) && map.get(c) > 0) {
            // 用掉一次比较 减一
            map.put(c, map.get(c) - 1);
        } else {
            flag = false;
            break;
        }
    }
    return flag;
}
```



### 快乐数

#### 题目描述

[LeetCode202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```



#### 题解

为什么出现重复的数就说明循环，这里证明了https://leetcode-cn.com/problems/happy-number/solution/kuai-le-de-zhi-shi-dian-zeng-jia-liao-by-sweetiee/

```java
public boolean isHappy(int n) {
    boolean isHappy = true;
    Set<Integer> set = new HashSet<>();

    while (n != 1) {
        if (set.contains(n)) {
            isHappy = false;
            break;
        }
        set.add(n);
        int nextN = 0;
        // 经典取每一个位置上的数字
        while (n != 0) {
            // 取个位数
            int one = n % 10;
            nextN += (one * one);
            n /= 10;
        }
        n = nextN;
    }

    return isHappy;
}
```



### 单词规律

#### 题目描述

[LeetCode290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
```

 

#### 题解

这题关键在与pattern和words是双向映射的，键和值是共存亡并且一一对应的，如果没有这种关系则不符合规律

```java
public boolean wordPattern(String pattern, String s) {
    String[] words = s.split(" ");
    if (words.length != pattern.length()) {
        return false;
    }
    char[] keys = pattern.toCharArray();
    Map<Character, String> map = new HashMap<>();
    Set<String> set = new HashSet<>();
    // 这题关键在与pattern和words是双向映射的，键和值是共存亡并且一一对应的
    for (int i = 0; i < keys.length; i++) {
        if (map.containsKey(keys[i])) {
            // 判断一一对应关系
            if (!map.get(keys[i]).equals(words[i])) {
                return false;
            }
        } else {
            // 判断共存亡关系 不可能出现 没有键却set中已经出现这个键对应的值 这种情况
            if (set.contains(words[i])) {
                return false;
            }
            map.put(keys[i], words[i]);
            set.add(words[i]);
        }
    }
    return true;
}
```



### 同构字符串

#### 题目描述

[LeetCode205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

**示例 3：**

```
输入：s = "paper", t = "title"
输出：true
```



#### 题解

```java
// 这题解法和202单词规律一样
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    char[] keys = s.toCharArray();
    char[] values = t.toCharArray();
    Map<Character, Character> map = new HashMap<>();
    Set<Character> set = new HashSet<>();
    for (int i = 0; i < keys.length; i++) {
        if (map.containsKey(keys[i])) {
            if (map.get(keys[i]) != values[i]) {
                return false;
            }
        } else {
            if (set.contains(values[i])) {
                return false;
            }
            set.add(values[i]);
            map.put(keys[i], values[i]);
        }
    }
    return true;
}
```



### 根据字符出现频率排序

#### 题目描述



#### 题解

**模拟**

```java
public String frequencySort(String s) {
    char[] c = s.toCharArray();
    int[][] count = new int[128][2];
    StringBuilder str = new StringBuilder();
    // 第一维记录下原来的索引，因为后面排序会导致位置发生变化
    for (int i = 0; i < 128; i++) {
        count[i][0] = i;
    }
    // 第二维记录数量
    for (int i = 0; i < c.length; i++) {
        count[c[i]][1]++;
    }
    Arrays.sort(count, (o1, o2)-> o2[1] - o1[1]);
    for (int i = 0; i < 128; i++) {
        // 每一个字符的数量
        int n = count[i][1];
        while (n-- > 0) {
            str.append((char)count[i][0]);
        }
    }
    return str.toString();
}
```



**哈希表+优先队列**

```java
class Node {
    char c;
    int num;
    Node(char c, int num) {
        this.c = c;
        this.num = num;
    }
}
public String frequencySort2(String s) {
    char[] chars = s.toCharArray();
    Map<Character, Integer> map = new HashMap<>();
    StringBuilder str = new StringBuilder();
    PriorityQueue<Node> maxHeap = new PriorityQueue<>(((o1, o2) -> {
        if (o1.num == o2.num) {
            // 如果添加条件 数量一致按字典序
            return o2.c - o1.c;
        } else {
            return o2.num - o1.num;
        }
    }));
    for (int i = 0; i < chars.length; i++) {
        map.put(chars[i], map.getOrDefault(chars[i], 0) + 1);
    }
    for (char c : map.keySet()) {
        maxHeap.add(new Node(c, map.get(c)));
    }

    while (!maxHeap.isEmpty()) {
        Node node = maxHeap.poll();
        int n = node.num;
        while (n-- > 0) {
            str.append(node.c);
        }
    }

    return str.toString();
}
```



##  常见问题





### 反转链表

#### 题目描述

[LeetCode206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)



#### 题解

```java
ListNode<T> pre = null;
ListNode<T> cur = head;
ListNode<T> next = null;
while (cur != null) {
    next = cur.next; //记录next
    cur.next = pre; // 当前next指向pre
    pre = cur; // 将当前节点设置为pre
    cur = next;// cur后移
}
return pre;
```



**进阶反转双链表**

```java
DoubleListNode<T> pre = null;
DoubleListNode<T> cur = head;
DoubleListNode<T> next = null;
while (cur != null) {
    next = cur.next; // 记录next
    cur.next = pre; // 修改cur的pre和next 顺序无所谓
    cur.pre = next; // 因为将cur.next保存给next了 所以先反转pre还是next的顺序无所谓
    pre = cur; // 将当前节点设置为pre
    cur = next; // cur后移 等价于cur = cur.pre 反转前的next值
}
return pre;
```







### 删除排序链表中的重复元素

#### 题目描述

[LeetCode83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)



#### 题解

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while (cur != null && cur.next != null) {
        if (cur.val == cur.next.val) {
            cur.next = cur.next.next;
        } else {
            // 如果有重复值被删除后 cur.next已经被更改，所以next值的正确的值
            cur = cur.next;
        }
    }
    return head;
}
```



### 分隔链表

#### 题目描述

[LeetCode86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```



#### 题解

链表版的荷兰国旗，但是题目要求要保留两个分区中每个结点的初始相对位置。所以其实用快排思想的话，其实不是那么好做。

```java
public ListNode partition(ListNode head, int x) {
    // 分割链表再合并
    ListNode leftCur = new ListNode(-1);
    ListNode rightCur = new ListNode(-1);
    // 记录两个链表头
    ListNode leftHead = leftCur;
    ListNode rightHead = rightCur;
    while (head != null) {
        if (head.val < x) {
            leftCur.next = head;
            leftCur = leftCur.next;
        } else {
            rightCur.next = head;
            rightCur = rightCur.next;
        }
        head = head.next;
    }
    // 左链表接上右链表的第二个结点
    leftCur.next = rightHead.next;
    // 右链表最后记得要置空 否则会出现循环链表
    rightCur.next = null;
    // 返回左链表的第二个结点
    return leftHead.next;
}
```

会出现循环链表的原因是，while 循环结束后，rightCur 的尾结点为 5，leftCur 的尾结点为 2，并且 right 链表要接到 left 的后面，这时如果 right 尾结点的next值没有置空，会仍然指向 2 这个结点，造成一个循环链表

![image-20220322225453548](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220322225453548.png)



### 奇偶链表

#### 题目描述

[LeetCode328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)



#### 题解

解法和分隔链表一样

```java
public ListNode oddEvenList(ListNode head) {
    ListNode oddCur = new ListNode(-1);
    ListNode evenCur = new ListNode(-1);
    ListNode oddHead = oddCur;
    ListNode evenHead = evenCur;
    int count = 1;
    while (head != null) {
        if (count % 2 == 1) {
            oddCur.next = head;
            oddCur = oddCur.next;
        } else {
            evenCur.next = head;
            evenCur = evenCur.next;
        }
        head = head.next;
        count++;
    }
    oddCur.next = evenHead.next;
    evenCur.next = null;
    return oddHead.next;
}
```



### 两数相加

#### 题目描述

[LeetCode2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)



#### 题解

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode sumHead = new ListNode(-1);
    ListNode cur = sumHead;
    int carry = 0;
    while (l1 != null || l2 != null) {
        if (l1 != null) {
            carry += l1.val;
            l1 = l1.next;
        }
        if (l2 != null) {
            carry += l2.val;
            l2 = l2.next;
        }
        // new Node 取余数
        cur.next = new ListNode(carry % 10);
        cur = cur.next;
        // 保留进位
        carry /= 10;
    }
    // 注意最后一个case 是否还有一个进位，有则新增一个node
    if (carry == 1) {
        cur.next = new ListNode(1);
    }
    return sumHead.next;
}
```



### 合并两个有序链表

#### 题目描述

[LeetCode21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```



#### 题解

经典归并，不过是链表的归并排序，只是有一点细节需要注意

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode dummyHead = new ListNode(-1);
    ListNode cur = dummyHead;
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    // 注意剩余不为空的链表结点直接挂上去就行，不需要更改list的next，否则会缺失结点
    cur.next = list1 != null ? list1 : list2;
    return dummyHead.next;
}
```



### 删除排序链表中的重复元素

#### 题目描述

[LeetCode83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

#### 题解

因为是已经排好序的链表，只需要判断当前结点和下一结点是否相等即可

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while (cur != null && cur.next != null) {
        if (cur.val == cur.next.val) {
            cur.next = cur.next.next;
        } else {
            // 如果有重复值被删除后 cur.next已经被更改，所以next值的正确的值
            cur = cur.next;
        }
    }
    return head;
}
```



### 删除排序链表中的重复元素 II

#### 题目描述

[LeetCode82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)



#### 题解

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode dummyHead = new ListNode(-1);
    // 设立虚拟头结点，统一处理
    dummyHead.next = head;
    ListNode cur = dummyHead;
    while (cur.next != null) {
        if ((cur.next.next != null && cur.next.val == cur.next.next.val)) {
            // 记录下被删结点的值
            int memory = cur.next.val;
            cur.next = cur.next.next.next;
            // 如果后面还有非空且值等于memory的结点，继续删
            while (cur.next != null && cur.next.val == memory) {
                cur.next = cur.next.next;
            }
        } else {
            cur = cur.next;
        }
    }
    return dummyHead.next;
}
```



### 移除链表元素

#### 题目描述

[LeetCode203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```
输入：head = [7,7,7,7], val = 7
输出：[]
```



#### 题解

**对头结点特殊判断**

```java
public ListNode removeElements(ListNode head, int val) {
    // 需要对头结点特殊判断 找到一个值不为val的头结点
    while (head != null) {
        if (head.val != val) {
            break;
        }
        head = head.next;
    }
    // 运行到这head是可能为null的
    ListNode cur = head;
    ListNode pre = head;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            // cur值不为val pre紧跟cur
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
```



**设立虚拟头结点**

![image-20220326223331422](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220326223331422.png)

```java
// 不对头结点特殊处理 我们在头结点前新增一个虚拟结点，使得所有结点都统一处理
public ListNode removeElements2(ListNode head, int val) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    // 保证了cur必不为空
    ListNode cur = dummyHead;
    while(cur.next != null) {
        if (cur.next.val == val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return dummyHead.next;
}
```





### 两两交换链表中的节点

#### 题目描述

[LeetCode24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```



#### 题解

![image-20220327111516368](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327111516368.png)

交换后

![image-20220327111533890](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327111533890.png)

![image-20220327111637298](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327111637298.png)

```java
public ListNode swapPairs(ListNode head) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode cur = dummyHead;
    ListNode node1 = null;
    ListNode node2 = null;
    ListNode next = null;
    while (cur.next != null && cur.next.next != null) {
        // 为什么不在循环外面先初始值是因为如果cur.next为null 给node2赋值会空指针异常
        node1 = cur.next;
        node2 = cur.next.next;
        next = node2.next;
        // 交换
        node2.next = node1;
        node1.next = next;
        cur.next = node2;
        // 修改下一次循环的cur指针
        cur = node1;
    }
    return dummyHead.next;
}
```

其实 next 指针并不是必需的，使用next 指针是为了让逻辑更清晰，如果不用 next 指针，就不能先对 node2 的指针进行修改，要先对 node1 的指针指向 node2.next 后再做修改



### K 个一组翻转链表

#### 题目描述

[LeetCode25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**示例 3：**

```
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
```

**示例 4：**

```
输入：head = [1], k = 1
输出：[1]
```



#### 题解

![K 个一组翻转链表.drawio (1)](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.drawio%20(1).png)



```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode node1 = null;
    ListNode node2 = dummyHead;
    ListNode cur = dummyHead;
    // next初始值为head用于判断head是否为null
    ListNode next = dummyHead.next;

    while (next != null) {
        // node1指向上次的next node2指向上次处理的片段链表末尾
        node1 = next;
        for (int i = 0; i < k && node2 != null; i++) {
            node2 = node2.next;
        }
        if (node2 == null) {
            break;
        }
        next = node2.next;
        // cur.next 指向翻转后的头结点 翻转后node1为该片段链表的末尾节点
        cur.next = reverse(node1, next);
        node1.next = next;
        // 更新cur,node2 指向上个片段链表的末尾
        cur = node1;
        node2 = cur;
    }
    return dummyHead.next;
}

// 与普通的翻转链表差不多，只是循环条件由cur != null 改为 cur != end
// end值为整个链表的next指针
private ListNode reverse(ListNode node1, ListNode end) {
    ListNode pre = null;
    ListNode cur = node1;
    ListNode next = null;
    while (cur != end) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



还有一种解法是使用递归，但是使用递归就需要额外的系统栈空间



### 排序链表

#### 题目描述

[LeetCode148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/sort_list_2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

 **提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

 **进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？



#### 题解



**归并递归**

```java
// O(n log n) 时间复杂度 常规解法使用归并递归
public ListNode sortList(ListNode head) {
    // 空 或者元素个数为1 返回
    if (head == null || head.next == null) {
        return head;
    }
    // 经典快慢指针寻找中点
    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null) {
        faster = faster.next.next;
        slower = slower.next;
    }
    // 此时慢指针指向第一个中点，也就是数组排序中M的位置
    ListNode midNext = slower.next;
    // 断开链表
    slower.next = null;
    ListNode left = sortList(head);
    ListNode right = sortList(midNext);
    return merge(left, right);
}

// 合并两个有序链表经典算法
private ListNode merge(ListNode left, ListNode right) {
    ListNode dummyHead = new ListNode(-1);
    ListNode cur = dummyHead;
    while (left != null && right != null) {
        if (left.val < right.val) {
            cur.next = left;
            left = left.next;
        } else {
            cur.next = right;
            right = right.next;
        }
        cur = cur.next;
    }
    cur.next = (left != null) ? left : right;
    return dummyHead.next;
}
```



### 删除链表的倒数第 N 个结点

#### 题目描述

[LeetCode19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 **提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

 **进阶：**你能尝试使用一趟扫描实现吗？



#### 题解



**朴素做法**

遍历两遍，第一遍算出链表长度

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    int count = 0;
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode cur = dummyHead;
    while (cur.next != null) {
        count++;
        cur = cur.next;
    }
    cur = dummyHead;
    for (int i = 0; i < count - n; i++) {
        cur = cur.next;
    }
    cur.next = cur.next.next;
    return dummyHead.next;
}
```





**双指针**



如果要删除倒数第n个结点，那么我们需要站在倒数第n + 1个结点，也就是被删结点的前一个位置 p，再让另一个指针q指向末尾的null，而p和q之前的距离是固定的就是n，那么我们只需要固定住 p 和 q 的**相对位置**，让 p 起始值指向虚拟结点，保持 p 和 q 的**相对位置**往后移动，直到 q 指向 null，p 就是我们想找的位置

![image-20220329210054845](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329210054845.png)

![image-20220329210324294](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329210324294.png)

![image-20220329210544455](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329210544455.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode p = dummyHead;
    ListNode q = dummyHead;
    // q从dummyHead移动n + 1
    for (int i = 0; i <= n; i++) {
        q = q.next;
    }
    // 寻找被删除结点的前一个位置
    while (q != null) {
        p = p.next;
        q = q.next;
    }
    // 删除
    p.next = p.next.next;
    return dummyHead.next;
}
```



### 旋转链表

#### 题目描述

[LeetCode61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 **示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 **提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`



#### 题解

```java
public ListNode rotateRight(ListNode head, int k) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode cur = dummyHead;
    // 记录最后一个结点
    ListNode last = null;
    // 确定链表长度
    int n = 0;
    while (cur.next != null) {
        n++;
        cur = cur.next;
        if (cur.next == null) {
            last = cur;
        }
    }
    cur = dummyHead;
    k = k % n;
    // 不移动
    if (k == 0) {
        return head;
    }
    for (int i = 0; i < (n - k); i++) {
        cur = cur.next;
    }
    // right为倒数第k+1个结点，在此处断开链表 重新连接
    ListNode right = cur.next;
    cur.next = null;
    last.next = dummyHead.next;

    return right;
}
```



### 重排链表

#### 题目描述

[LeetCode143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1626420311-PkUiGI-image.png)

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1626420320-YUiulT-image.png)

```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

 

#### 题解

```java
public void reorderList(ListNode head) {
    ListNode slower = head;
    ListNode faster = head.next;
    while (faster != null && faster.next != null) {
        slower = slower.next;
        faster = faster.next.next;
    }
    // 找到第一个中点的下一个位置 先断开再翻转
    ListNode right = slower.next;
    slower.next = null;
    right = reverse(right);
    
    ListNode left = head;
    // 这里左链表一定大于等于右链表，且至多大一个单位
    // 在原链表上进行连接 注意细节
    while (right != null) {
        ListNode nextL = left.next;
        ListNode nextR = right.next;
        left.next = right;
        left = nextL;

        right.next = left;
        right = nextR;
    }
}
// 翻转
private ListNode reverse(ListNode head) {
    ListNode cur = head;
    ListNode next = null;
    ListNode pre = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 回文链表

#### 题目描述

[LeetCode234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

 **进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？



#### 题解

**不使用额外空间，经典做法是翻转链表**

```java
public boolean isPalindrome(ListNode head) {
    // 所给数据个数大于等于1
    boolean flag = true;

    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null) {
        slower = slower.next;
        faster = faster.next.next;
    }
    ListNode right = reverse(slower.next);
    while(right != null) {
        if (head.val != right.val) {
            flag = false;
            break; 
        }
        right = right.next;
        head = head.next;
    }
    // 最后最好把右链表再翻转一遍 还原回来
    return flag;    
}

private ListNode reverse(ListNode head) {
    ListNode cur = head;
    ListNode pre = null;
    ListNode next = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 双链表实现双端队列、队列、栈



## 常见问题

### 回文链表

[剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

一般解法借助容器类如栈

最优解：

**快慢指针+反转链表**



注意的点：

1、是不用判断奇偶的，因为右链表总是小于等于左链表，while以数量小的那个判空停下就行，因为如果是奇数，中间那个数是不用比较的。

2、判断快慢指针越界的时候，不仅仅要判faster.next.next,  faster.next也要判空 否则会空指针

3、如果要还原链表，需要复制一个指针，不能直接用reverse 会被改变

```java
// 快慢指针
public static boolean isPal2(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    // 1 快慢指针找中点
    ListNode faster = head.next; //简化边界问题
    ListNode slower = head;
    // 快慢指针 快2倍 如果奇数个 while停下 慢指针指向中点
    // 如果偶数个 慢指针指向第一个中点
    // 这里注意faster.next也要判空 否则会空指针 只需要判快指针
    while (faster != null && faster.next!= null ) {
        faster = faster.next.next;
        slower = slower.next;
    }
    boolean res = true;
    // 2 反转右链表对比
    ListNode reverse = reverse(slower.next);
    // 如果要还原链表的话不能直接用reverse 会被改变
    ListNode temp = reverse;
    while (temp != null) {
        if (temp.data != head.data) {
            res = false;
            break;
        }
        temp = temp.next;
        head = head.next;
    }
    // 3 还原链表
    slower.next = reverse(reverse);
    return res;
}

public static ListNode reverse(ListNode head) {
    ListNode next = null;
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 复杂链表的复制

[剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

一般解：哈希表

最优解：

使用哈希表能解决的原因是，我们可以得到原结点和副本的一一对应结构，只要我们人为去构造这种对应的结构就不需要哈希表。

1、在每个原结点后复制出一个新的

2、一对一对（origin + copy）的遍历 添加副本结点的random指针

3、分离原结点和副本

```java
public Node copyRandomList(Node head) {
    // 这个是有必要的 否则下面的Node copyHead = head.next可能会空指针
    if (head == null) {
        return null;
    }
    Node cur = head;
    Node next = null;
    // 1 在每个原结点后复制出一个新的
    while (cur != null) {
        next = cur.next;
        // copy = cur.next; copy.next = next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }
    // 一对一对（origin + copy）的遍历 添加副本结点的random指针
    cur = head;
    Node curCopy = null;
    // 这里为什么不用判cur.next != null 是因为cur.next是cur的副本 只用判cur就可以了
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        // cur.random是原结点的random 我们通过它获取cur.random的副本 而副本是接在原结点后面的
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node copyHead = head.next;
    // 分离原结点和副本
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = curCopy.next;
        // 要特殊处理一下最后一个结点next为空 next.next会报错
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return copyHead;
}
```

对最后一个结点进行操作的时候需要特判一下next为不为空

![image-20220129231741596](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220129231741596.png)

### 相交链表(有环无环)

#### 题目描述

给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 

【要求】 如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。



#### 题解

这应该是链表里最难的题目之一了，一道题里组合了环形链表和普通相交链表

分析一下题目的可能性：

一共有五种可能性：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220202221828729.png)

```java
// 主方法
public static ListNode isIntersection(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode loopA = findLoopNode(headA);
    ListNode loopB = findLoopNode(headB);
    // 两个无环链表相交问题
    if (loopA == null && loopB == null) {
        return getIntersectionNoLoop(headA, headB);
    }
    // 两个有环链表相交问题
    if (loopA != null && loopB != null) {
        return getIntersectionAllLoop(headA, loopA, headB, loopB);
    }
    // 一个有环 一个无环 必不相交
    return null;
}

// 判断链表是否有环，有则返回入环点，无则返回null
public static ListNode findLoopNode(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null && faster != slower) {
        faster = faster.next.next;
        slower = slower.next;
    }
    if (faster == null || faster.next == null) {
        return null;
    }
    slower = slower.next;
    faster = head;
    while (faster != slower) {
        faster = faster.next;
        slower = slower.next;
    }
    return faster;
}

// 求两个有环链表相交问题 如果相交求出交点
public static ListNode getIntersectionAllLoop(ListNode headA, ListNode loopA, ListNode headB, ListNode loopB) {
    ListNode curA = headA;
    ListNode curB = headB;
    // 入环点一样 那么入环点之前的情况跟无环链表一样
    if (loopA == loopB) {
        while (curA != curB) {
            // 不让指针走入环内
            curA = (curA != loopA) ? curA.next : headB;
            curB = (curB != loopA) ? curB.next : headA;
        }
        return curA;
    }
    // 入环点不一样 即相交点就等于入环点 随便返回一个
    return loopA;

}

// 求两个无环链表相交问题 如果相交求出交点
public static ListNode getIntersectionNoLoop(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode curA = headA;
    ListNode curB = headB;
    while (curA != curB) {
        curA = (curA != null) ? curA.next : headB;
        curB = (curB != null) ? curB.next : headA;
    }
    return curA;
}

// 测试样例 for test
public static void main(String[] args) {
    // 1->2->3->4->5->6->7->null
    ListNode head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);

    // 0->9->8->6->7->null
    ListNode head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

    // 1->2->3->4->5->6->7->4...
    head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);
    head1.next.next.next.next.next.next = head1.next.next.next; // 7->4

    // 0->9->8->2...
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next; // 8->2
    System.out.println(isIntersection(head1, head2).val);

    // 0->9->8->6->4->5->6..
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

}
```





### 链表排序



# 队列和栈

## 设计题

![image-20220313234930488](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220313234930488.png)

### 数组实现队列和栈

### 最小栈设计

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

1、创建两个栈，一个数据栈，一个最小栈，最小栈的栈顶为最小值

2、怎么维护最小栈的栈顶为元素最小值

- 第一种方法：

  入栈情况：

  - 当最小栈为空，第一个进入的元素就进最小栈（数据栈正常入栈）
  - 当最小栈不为空，且入栈的元素**小于等于**最小栈栈顶，才进入最小栈（数据栈正常入栈）

  出栈情况：

  - 当数据栈出栈的元素等于最小栈栈顶时，最小栈同时出栈，否则只有数据栈出栈

- 第二种方法：

  入栈情况：

  - 数据栈和最小栈同步入栈，但是只有入栈元素小于最小栈栈顶时，才将该元素入最小栈，否则将最小栈栈顶入最小栈

  出栈情况：

  - 同步出栈

> 注意第一种方法，等于的时候也要入最小栈的，因为数据栈肯定是要正常入栈的，当这个元素出栈时最小栈也要出栈，而此时数据栈有重复的元素，最小栈只有一个，会出错。



### 用队列实现栈

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

两个队列实现：

1、将原队列的元素导入另一个辅助队列直到只剩下一个元素，输出

2、将两队列地址互换，改变输入的队列

3、重复上述过程

![image-20220125183527993](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220125183527993.png)



一个队列实现：

只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

![image-20220125184034130](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220125184034130.png)





### 用栈实现队列

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 必须是popStack为空才能倒数据
- 如果导数据，必须从pushStack一次性倒完

只要满足上面两个要求，导数据的时机什么时候都可以，可以在每次push操作后，也可以在每次pop或peek的时候导，或者push和pop操作都导。



### 递归实现栈的逆序



## 常见问题

### 有效的括号

#### 题目描述

[LeetCode20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

#### 题解

逻辑不难，使用栈作为存储结构，注意需要将所有的情况都要考虑到

```java
public boolean isValid(String s) {
    // 字符长度为奇数肯定不有效
    if (s.length() % 2 == 1) {
        return false;
    }
    Deque<Character> stack = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '{' || c == '[' || c == '(') {
            stack.push(s.charAt(i));
        } else {
            // 只有右符号的情况
            if (stack.isEmpty()) {
                return false;
            }
            char pop = stack.pop();
            if ((pop == '{' && s.charAt(i) == '}') || (pop == '[' && s.charAt(i) == ']') || ((pop == '(' && s.charAt(i) == ')'))) {
            } else {
                // 不匹配返回false
                return false;
            }
        }
    }
    // 注意还要判断只有左符号的情况
    return stack.isEmpty();
}
```



### 逆波兰表达式求值

#### 题目描述

[LeetCode150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)



#### 题解

```java
public int evalRPN(String[] tokens) {
    if (tokens.length == 0) {
        return 0;
    }
    int n = tokens.length;
    int res = 0;
    Deque<String> stack = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        if (isOperator(tokens[i])) {
            int num1 = Integer.parseInt(stack.pop());
            int num2 = Integer.parseInt(stack.pop());
            switch (tokens[i]) {
                case "+":
                    res = num2 + num1;
                    break;
                case "-":
                    res = num2 - num1;
                    break;
                case "*":
                    res = num2 * num1;
                    break;
                case "/":
                    res = num2 / num1;
                    break;
            }
            stack.push(res + "");
        }
        if (isNum(tokens[i])) {
            stack.push(tokens[i]);
        }
    }
    // 操作完栈中只有一个元素 注意返回的是栈中的元素 而不是res 因为表达式只有一个数时["18"] 返回res会不正确
    return Integer.parseInt(stack.peek());
}
// 虽然题目给的都是合法数据 最好还是校验一下
private boolean isNum(String c) {
    try {
        Integer.parseInt(c);
    } catch (Exception e) {
        return false;
    }
    return true;
}
private boolean isOperator(String c) {
    return "+".equals(c) || "-".equals(c) || "*".equals(c) || "/".equals(c);
}
```



**进阶版**

TODO

思考一下，如果数据给的操作符范围更广，数据不仅有整数，还可能会有浮点数



### 简化路径

#### 题目描述

[LeetCode71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)



#### 题解

```java
public String simplifyPath(String path) {
    assert path.length() > 0;
    // 选用切割"/"的方案 这样就可以将完整的每个文件夹分开 ".."也是一个完整的字符串 不需要记录前一个的"."
    String[] paths = path.split("/");
    if (paths.length == 0) {
        return "/";
    }
    Deque<String> stack = new ArrayDeque<>();
    for (String s : paths) {
        // 注意split出来的可能还会有空字符串
        if ("".equals(s) || ".".equals(s)) {
            continue;
        }
        // ".."且栈不为空 弹出一个文件夹
        if ("..".equals(s)) {
            if (!stack.isEmpty()) {
                stack.pop();
            }
            continue;
        }
        // 如果是文件夹 入栈
        stack.push(s);
    }
    // 到这里 栈中已经有正确路径的文件夹了，只需要逆序出来补上"/"即可
    if (stack.isEmpty()) {
        return "/";
    }
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
        // 头插法
        sb.insert(0, stack.pop());
        sb.insert(0, "/");
    }
    return sb.toString();
}
```

注意一下`split()`的切割用法

```java
System.out.println(Arrays.toString("/".split("/")));
System.out.println(Arrays.toString("//".split("/")));
System.out.println(Arrays.toString("///".split("/")));
System.out.println(Arrays.toString("8///".split("/")));
System.out.println(Arrays.toString("/8///".split("/")));
System.out.println(Arrays.toString("/8////8".split("/")));
System.out.println(Arrays.toString("/8////8/".split("/")));
//-----------------分别打印出------------------------------
[]
[]
[]
[8]
[, 8]
[, 8, , , , 8]
[, 8, , , , 8]
```

如果不熟悉 StringBuilder 的 api 的话，对于结果的处理可以再开一个栈进行倒数就行，这题如果是笔试，直接使用双端队列会更方便



### 扁平化嵌套列表迭代器

#### 题目描述

[LeetCode341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

#### 题解

**栈**

这题相当于是对广义表的遍历，不过广义表的的一些方法题目已经给我们提供了

![扁平化嵌套列表迭代器.drawio (1)](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8.drawio%20(1).png)

```java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 		// 该广义表对象是否是一个整数
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 		// 如果该广义表对象是一个整数类型 那么返回这个整数
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return empty list if this NestedInteger holds a single integer
 		// 如果该广义表对象不是一个整数 那么返回这个广义表的子广义表列表
 *     public List<NestedInteger> getList();
 * }
 */
public class NestedIterator implements Iterator<Integer> {

    private Deque<NestedInteger> stack = new ArrayDeque<>();

    public NestedIterator(List<NestedInteger> nestedList) {
        // 对一层逆序压栈
        toStack(nestedList);
    }

    @Override
    public Integer next() {
        // 因为测试代码迭代器是有下一个元素才会调用next 没有就不会调用 所以这里的否定写什么都行
        return hasNext() ? stack.pollLast().getInteger() : Integer.MAX_VALUE;
    }

    @Override
    public boolean hasNext() {
        if (stack.isEmpty()) {
            return false;
        } else {
            if (stack.peekLast().isInteger()) {
                return true;
            } else {
                List<NestedInteger> nestedList = stack.pollLast().getList();
                // 不是数字 说明是列表 有层级继续调用 对一层逆序压栈
                toStack(nestedList);
                // 处理完一层后 递归调用hasNext()直至栈顶出现数字类型
                return hasNext();
            }
        }
    }
    // 对一层逆序压栈
    private void toStack(List<NestedInteger> nestedList) {
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.addLast(nestedList.get(i));
        }
    }
}
```



**DFS**

TODO



### 二叉树的层序遍历

#### 题目描述

[LeetCode102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

#### 题解

对于普通的层序遍历，多记录一个每一层的信息

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> levelList;
    if (root == null) {
        return res; 
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    int levelCount = 0;
    while (!queue.isEmpty()) {
        levelList = new ArrayList<>();
        levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 记录每一层的信息
        res.add(levelList);
    }
    return res;
}
```



### 二叉树的层序遍历 II

#### 题目描述

[LeetCode107二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

#### 题解



```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode cur = root;
    queue.offer(cur);

    while (!queue.isEmpty()) {
        int levelCount = queue.size();
        List<Integer> levelList = new ArrayList<>();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 每一层的数据采用头插法即可，忘记这个api可以在最后翻转一下res即可
        res.add(0, levelList);
    }
    return res;
}
```



### 二叉树的锯齿形层序遍历

#### 题目描述

[LeetCode103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)



#### 题解

**BFS**

如果担心使用插入效率不高，可以用 LinkedList 实现，或者 用 ArrayList，每一层最后 reverse 就好了

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new ArrayDeque<>();
    int index = 1;
    queue.offer(cur);
    while (!queue.isEmpty()) {
        List<Integer> levelList = new LinkedList<>();
        int levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            if (index % 2 == 1) {
                // 奇数层 左到右接收
                levelList.add(cur.val);
            } else {
                // 偶数层 右到左接收
                levelList.add(0, cur.val);
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        res.add(levelList);
        index++;
    }
    return res;
}
```



### 二叉树的右视图

#### 题目描述

[LeetCode199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)



#### 题解

**BFS**

存入每一层中最右侧的结点，即可获取右视图

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new ArrayDeque<>(); 
    queue.offer(cur);
    while(!queue.isEmpty()) {
        int levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
            // 如果是一层中的最右侧的一个节点 加入值
            if (i == levelCount - 1) {
                res.add(cur.val);
            }
        }
    }
    return res;
}
```



**DFS**

```java
// dfs
private List<Integer> res = new ArrayList<>();

public List<Integer> rightSideView1(TreeNode root) {
    dfs(root, 0);
    return res;
}

private void dfs(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    // 这里depth指的是上一层的depth 也就是说当前res的大小仍然等于上一层的深度，说明当前节点是该层出现的第一个结点
    // 我们先访问右子树 在右子树不为空的情况下控制每层出现的第一个结点为最右侧的结点
    if (depth == res.size()) {
        res.add(root.val);
    }
    dfs(root.right, depth + 1);
    dfs(root.left, depth + 1);
}
```



## 优先队列

关键词：前k个最值



### 数据流中的第 K 大元素

#### 题目描述

[LeetCode703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

#### 题解

```java
public static class KthLargest {
    // 默认小根堆
    private PriorityQueue<Integer> heap;
    private int k;
    public KthLargest(int k, int[] nums) {
        this.k = k;
        heap = new PriorityQueue<>();
        for (int x : nums) {
            // 调用自己写的add
            this.add(x);
        }
    }

    public int add(int val) {
        heap.offer(val);
        // 维护容量为k的小根堆 则堆顶的元素即为第k大的元素
        if (heap.size() > k) {
            heap.poll();
        }
        assert heap.size() > 0;
        return heap.peek();
    }
}
```



### 前 K 个高频元素

#### 题目描述

[LeetCode347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)



#### 题解

面试时最好先问下面试官 k 与 n 到底是什么样的关系，如果 k 是远小于 n 的，那么我们是可以维护大小为 k 的小根堆从而达到一个`O(n * logk)`的复杂度的。但是如果 k 非常接近 n 的话我们就可以维护一个大小为 m - k （m为不同元素的数量）的大根堆，不在堆中的元素就是我们的res

```java
public int[] topKFrequent(int[] nums, int k) {
    int[] res = new int[k];
    // key：元素的值 value：元素出现的频率
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        // getOrDefault如果找不到key返回defaultValue
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());
    // 维护大小为k的小根堆（频率）O(n * logK)
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        heap.offer(entry);
        if (heap.size() > k) {
            heap.poll();
        }
    }

    // 返回堆中的元素的值
    for (int i = k - 1; i >= 0; i--) {
        res[i] = heap.poll().getKey();
    }
    return res;
}
```



```java
public int[] topKFrequent(int[] nums, int k) {
    int[] res = new int[k];
    // key：元素的值 value：元素出现的频率
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        // getOrDefault如果找不到key返回defaultValue
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>((o1, o2) -> o2.getValue() - o1.getValue());
    int m = map.size();
    // 维护大小为m - k的大根堆（频率）
    int index = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        heap.offer(entry);
        if (heap.size() > (m - k)) {
            res[index] = heap.poll().getKey();
            index++;
        }
    }
    return res;
}
```



## 哈希表

增删改查复杂度都认为是O(1)，但是这个常数级别有点大

哈希表存入非基础数据类型占用内存非常小，只会记录引用值，不会复制值

```java
Integer a = 1111111111;
Integer b = 1111111111;
Student student1 = new Student(2);
Student student2 = new Student(2);
HashMap<Student,String> map1 = new HashMap<>();
HashMap<Integer,String> map = new HashMap<>();

// 基础数据类型的包装类且范围不在常量池，存放在哈希表中时，根据值匹配，属同一对象。
map.put(a,"我是a");
System.out.println(map.containsKey(b));

// 非包装类的引用类型，存放在哈希表中时，根据引用值匹配，不属同一对象。
map1.put(student2,"student2");
System.out.println(map1.containsKey(student1));
```



## 有序表

TreeMap 有序表 只是一个接口

能实现有序表的：红黑树、AVL树、SBT(Size Balanced tree)、跳表

增删改查时间复杂度都是O(logN),功能比有序表强大

Java中TreeMap是用红黑树实现的



非数值类型和String类型传入TreeMap需要自己定义比较器，否则会报错

当排序规则比较简单时，可以使用lambda表达式实现比较器

```java
//
TreeMap<Student, String> treeMap = new TreeMap<>(
                (stu1, stu2) -> !stu1.getId().equals(stu2.getId()) ? 
                        stu1.getId() - stu2.getId() : stu2.getAge() - stu1.getAge());
//
TreeMap<Student, String> treeMap = new TreeMap<>((stu1, stu2) -> stu1.getId() - stu2.getId());
// IDEA推荐写成这样
TreeMap<Student, String> treeMap = new TreeMap<>(Comparator.comparingInt(Student::getAge));
```

> 注意TreeMap一般情况下是不允许存放重复元素的，所以当传进来的比较器只比较id的话，treemap会认为相同age的student是同一个元素（即使两个student对象不一样），只会存进去一个student

解决方法，如果age相等的话，再比较内存地址（hashCode也可能重复），就能保证age相等的不同样本都留下来

# 二叉树

## 经典问题

### 遍历



### 序列化与反序列化



### 二叉树最大深度

#### 题目描述

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)



#### 题解

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(1 + maxDepth(root.left), 1 + maxDepth(root.right));
}
```



### 二叉树最小深度

#### 题目描述

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。



#### 题解

注意是通向叶子结点的路径我们才需要记录并取最小值，通向null的就不需要记录

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 子树如果为空说明不是通向叶子结点 不需要记录
    int leftInfo = minDepth(root.left);
    int rightInfo = minDepth(root.right);
    // 返回不为空子树的信息 如果都为空只有root一个结点 直接返回1
    if (leftInfo == 0 || rightInfo == 0) {
        return 1 + leftInfo + rightInfo;
    }
    // 两个子树不为空存在叶子结点 取最短路径
    return Math.min(leftInfo, rightInfo) + 1;
}
```



### 翻转二叉树

#### 题目描述





#### 题解

**DFS**

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    // 后序翻转 也可以先对左右子树交换 再dfs 
    invertTree(root.left);
    invertTree(root.right);

    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;

    return root;
}
```



**BFS**

也就是层序遍历，借用辅助队列

![bfs](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/bfs.gif)

```java
// 层序遍历
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    TreeNode temp = null;
    TreeNode cur = null;
    while(!queue.isEmpty()) {
        cur = queue.poll();
        temp = cur.right;
        cur.right = cur.left;
        cur.left = temp;
        
        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right); 
        }
    }
    return root;
}
```



**迭代遍历**

前序后序都可以，但是前序迭代比较简单

```java
// 迭代
public TreeNode invertTree(TreeNode root) {
    TreeNode cur = root;
    Deque<TreeNode> stack = new LinkedList<>();
    while(cur != null || !stack.isEmpty()) {
        if (cur != null) {
            // 前序交换
            TreeNode temp = cur.left;
            cur.left = cur.right;
            cur.right = temp;
            
            stack.offer(cur);
            cur = cur.left;
        } else {
            cur = stack.poll();
            cur = cur.right;
        }
    }
    return root;
}
```



### 对称二叉树

#### 题目描述

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```



#### 题解

**DFS**

如果没有考虑镜像对称，可能一开始会有这题不是递归结构的想法，因为一看可能觉得子树并没有递归结构，因为是镜像对称，我们考虑递归结构要放到对应的镜像上去

在这道题里，根节点没什么用，把根节点拿掉来看，就是两棵子树，我们需要的就是比较两颗子树是否镜像

既然是**镜像比较**，那么就是**左子树的左子树和右子树的右子树进行比较、左子树的右子树和右子树的左子树进行比较**

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return dfs(root.left, root.right);
}

private boolean dfs(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    // 仅有一颗子树为null
    if (left == null || right == null) {
        return false;
    }
    // left和right不为空且值不相等
    if (left.val != right.val) {
        return false;
    }
    // 镜像递归两组： 左子树的左子树和右子树的右子树、左子树的右子树和右子树的左子树
    return dfs(left.left, right.right) && dfs(left.right, right.left);
}
```



**层序遍历**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/45a663b08efaa14193d63ef63ae3d1d130807467d13707f584906ad3af4adc36-1.gif)

```java
// 层序遍历 队列 使用栈也是可以的
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root.left);
    queue.add(root.right);
    while(!queue.isEmpty()) {
        // 确认取出的两个是一组镜像
        TreeNode left = queue.remove();
        TreeNode right = queue.remove();
        // 都为null
        if (left == null && right == null) {
            continue;
        }
        // 仅有一个为null
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        // 两组放入顺序可以变 但是要保证依次放入的是一组镜像
        queue.add(left.left);
        queue.add(right.right);

        queue.add(left.right);
        queue.add(right.left);
    }
    return true;
}
```



### 相同的树

#### 题目描述

[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)



#### 题解

这题和对称二叉树的思想一模一样



**DFS**

```java
// dfs
public boolean isSameTree(TreeNode p, TreeNode q) {
    // 都为null
    if (p == null && q == null) {
        return true;
    }
    // 仅有一个为null
    if (p == null || q == null) {
        return false;
    }
    // 都不为null且值不相等
    if (p.val != q.val) {
        return false;
    }
    // 递归子树是否相等
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```



**层序遍历**

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(p);
    queue.offer(q);
    while(!queue.isEmpty()) {
        TreeNode temp1 = queue.poll();
        TreeNode temp2 = queue.poll();
        // 都为null
        if (temp1 == null && temp2 == null) {
            // return true; 不能直接return true 可能出现p:[1] q:[1,null,2]这种情况
            continue;
        }
        // 仅有一个为null
        if (temp1 == null || temp2 == null) {
            return false;
        }
        // 都不为null且值不等
        if (temp1.val != temp2.val) {
            return false;
        }
        queue.offer(temp1.left);
        queue.offer(temp2.left);

        queue.offer(temp1.right);
        queue.offer(temp2.right);
    }
    return true;
}
```



### 完全二叉树的节点个数

#### 题目描述





#### 题解



普通做法遍历整颗树：

```java
// 递归遍历
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}

// 迭代遍历
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int res = 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()) {
        int n = queue.size();
        for (int i = 0; i < n; i++) {
            TreeNode cur = queue.poll();
            res++;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
    }
    return res;
}
```



**完全二叉树做法**

完全二叉树只有两种情况，**情况一：就是满二叉树，情况二：最后一层叶子节点没有满。**

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

完全二叉树（一）如图：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631803818-YYYuSS-file_1631803818211)

完全二叉树（二）如图：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631803818-tpJmfp-file_1631803818273)


可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

**所以我们只要求子树的深度即可**

比较难想的点

- 对于完全二叉树来说如果左子树深度等于右子树深度 说明左子树是满二叉树
- 如果左右子树深度不等于 对于完全二叉树来说只能是左子树深度比右子树深度大1 说明右子树是满二叉树

```java
// O(logN*logN)比O(N)快
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = getDepth(root.left);
    int rightDepth = getDepth(root.right);
    // 如果左子树深度等于右子树深度 说明左子树是满二叉树
    if (leftDepth == rightDepth) {
        return (1 << leftDepth) - 1 + countNodes(root.right) + 1;
    } else {
        // 如果不等于 对于完全二叉树来说只能是左子树深度比右子树深度大1 说明右子树是满二叉树
        return (1 << rightDepth) - 1 + countNodes(root.left) + 1;
    }
}
// 计算完全二叉树的深度
private int getDepth(TreeNode root) {
    // 一直往左下遍历即可
    int depth = 0;
    while(root != null) {
        depth++;
        root = root.left;
    }
    return depth;
}
```





### 二叉树的最大宽度



### 路径总和

#### 题目描述

[LeetCode112. 路径总和](https://leetcode-cn.com/problems/path-sum/)



#### 题解

就是一道路径和类的问题，如果学过回溯这道题就很简单，用dfs就是回溯思想

注意的是题目要求的是**根结点到叶子结点的路径**，而不是任一路径

**DFS**

先贴一段错误代码：

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return dfs(root, targetSum);
}
private boolean dfs(TreeNode root, int targetSum) {
    if (root == null) {
        return targetSum == 0;
    }
    return dfs(root.left, targetSum - root.val) || dfs(root.right, targetSum - root.val);
}
```

上诉代码为什么错误？因为`root == null`的时候，我们忽视了上级结点是否为叶子结点，即使`targetSum == 0`，但它不是一条从根结点到叶子结点的路径，所以逻辑不对。

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220307235213797.png)



这题和**二叉树最小深度**的递归的终止条件差不多，**只有叶子结点才是有效信息**

正确代码：

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return dfs(root, targetSum);
}
private boolean dfs(TreeNode root, int targetSum) {
    // 为空直接返回false
    if (root == null) {
        return false;
    }
    // 如果是叶子结点判断当前这个叶子结点是否能凑够targetSum
    if (root.left == null && root.right == null) {
        return targetSum == root.val;
    }
    return dfs(root.left, targetSum - root.val) || dfs(root.right, targetSum - root.val);

}
```



**其他解法**

TODO



### 路径总和 II

#### 题目描述

[LeetCode113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)



#### 题解



**回溯**

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return res;
    }
    dfs(root, targetSum);
    return res;
}

private void dfs(TreeNode root, int targetSum) {
    // 递归终止1
    if (root == null) {
        return;
    }
    // 递归终止2 叶子结点只能在上一结点判断
    if (root.left == null && root.right == null) {
        if (targetSum == root.val) {
            // 当前结点的值还没添加到列表中，所以要先添加，然后再移除
            path.add(root.val);               
            res.add(new ArrayList<>(path));
            path.remove(path.size() - 1);
        }
        return;
    }
    // 下面就是经典的回溯 状态重置 其实可以再简洁一点 因为进入左右分支的 path 是一样的 所以可以省略掉左递归之后的remove 和 右递归之前的add 
    path.add(root.val);
    dfs(root.left, targetSum - root.val);
    path.remove(path.size() - 1);

    path.add(root.val);
    dfs(root.right, targetSum - root.val);
    path.remove(path.size() - 1);
}
```



也可以这样写，但是个人觉得上面那种比较容易理解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return res;
    }
    dfs(root, targetSum);
    return res;
}

private void dfs(TreeNode root, int targetSum) {
    // 递归终止1
    if (root == null) {
        return;
    }
    path.add(root.val); // 也可以把add写在if外面 注意add和remove一定可以在同一条件两个都能执行，否则就会状态重置出现问题
    // 递归终止2 叶子结点只能在上一结点判断
    if (root.left == null && root.right == null) {
        if (targetSum == root.val) {         
            res.add(new ArrayList<>(path));    
        }
        path.remove(path.size() - 1);
        return;
    }
    // 下面就是经典的回溯 状态重置 其实可以再简洁一点 因为进入左右分支的 path 是一样的 所以可以省略掉左递归之后的remove 和 右递归之前的add 
    dfs(root.left, targetSum - root.val);
    path.remove(path.size() - 1);

    path.add(root.val);
    dfs(root.right, targetSum - root.val);
    path.remove(path.size() - 1);
}
```





### 路径总和

#### 题目描述



#### 题解



**DFS**

在路径总和、路径总和 II中，我们设计了以下的递归，按这种思路一直递归下去，其实默认了一个条件：`root`这个结点一定在路径中，因为在调用`dfs`时，`tarSum`已经减去了`root.val`的一部分，相当于root已经充当了路径的一部分。

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.drawio.png)

但是对于这题而言，root不一定要在路径上，此时我们应该分类情况讨论

- root在路径上
- root不在路径上



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E5%9B%BE.drawio.png)



```java
private int res = 0;
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return 0;
    }
    dfs(root, targetSum);
    return res;
}

// 只有在确定路径起点结点这一步中 每个结点才有选与不选两种选择
// 一旦路径起点被确定 后面的结点就一定要选上
private void dfs(TreeNode root, int targetSum) {
    if (root == null) {
        return;
    }
    // 选择root当路径
    dfsHasRoot(root, targetSum);
    // 不选root当路径
    dfs(root.left, targetSum);
    dfs(root.right, targetSum);
}

private void dfsHasRoot(TreeNode root, int targetSum) {
    // 注意因为结点值可能有负值，后面的路径可能还会满足res 所以不能直接return
    if (targetSum == root.val) {
        res += 1;
    }
    // 一旦root被选上当路径，也就是路径起点 root的子树一定要选，因为路径是连续的
    if (root.left != null) {
        dfsHasRoot(root.left, targetSum - root.val);
    }
    if (root.right != null) {
        dfsHasRoot(root.right, targetSum - root.val);
    }
}
```



**前缀和**



### 左子树之和

#### 题目描述

[LeetCode404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)



#### 题解

注意判断当前节点是不是左叶子是无法判断的，**必须要通过节点的父节点来判断其左孩子是不是左叶子**，条件是左孩子不为空且左孩子的孩子都为空，则该左孩子是叶子结点

**递归DFS**

```java
// 递归
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // curInfo表示当前root结点能获取到左叶子结点的信息
    int curInfo = 0;
    // Info表示root的孩子结点能获取到左叶子结点的信息
    int leftInfo = sumOfLeftLeaves(root.left);
    int rightInfo = sumOfLeftLeaves(root.right);
    // 判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子
    // 左孩子不为空且左孩子是叶子结点
    if (root.left != null && root.left.left == null && root.left.right == null) {
        curInfo = root.left.val;
    }
    // 返回信息和
    return curInfo + leftInfo + rightInfo;
}
```



**迭代DFS**

```java
// 迭代 前中都可以 
public int sumOfLeftLeaves(TreeNode root) {
    TreeNode cur = root;
    Deque<TreeNode> stack = new LinkedList<>();
    int res = 0;
    while(cur != null || !stack.isEmpty()) {
        if (cur != null) {
            if (cur.left != null && cur.left.left == null && cur.left.right == null) {
                res += cur.left.val;
            }
            stack.offer(cur);
            cur = cur.left;
        } else {
            cur = stack.poll();
            cur = cur.right;
        }
    }
    return res;
}
```



**层序遍历**

```java
// 层序遍历
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode cur = root;
    queue.offer(cur);
    int res = 0;
    while (!queue.isEmpty()) {
        cur = queue.poll();
        if (cur.left != null) {
            if (cur.left.left == null && cur.left.right == null) {
                res += cur.left.val;
            }
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }
    }
    return res;
}
```



### 二叉树的所有路径和

#### 题目描述

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)



#### 题解

**递归DFS**

```java
private List<String> res = new ArrayList<>();

public List<String> binaryTreePaths(TreeNode root) {
    if (root == null) {
        return res;
    }
    dfs(root, "");
    return res;
}

// path用的字符串 隐式回溯
private void dfs(TreeNode root, String path) {
    if (root == null) {
        return;
    }
    dfs(root.left, path + root.val + "->");
    dfs(root.right, path + root.val + "->");
    // 前序处理也是可以的
    if (root.left == null && root.right == null) {
        // 注意到了叶子结点就不需要加 -> 了
        res.add(path + root.val);
    }
}
```



**迭代DFS**

回溯其实用迭代的方法是不太好写

可以利用同一个栈，同时作为结点栈和路径栈

这里前序迭代跟我平时写的习惯不太一样

```java
// 迭代
public List<String> binaryTreePaths2(TreeNode root) {
    if (root == null) return res;
    Deque<Object> stack = new LinkedList<>();
    stack.push(root);
    stack.push(String.valueOf(root.val)); // 节点，当前路径
    while (!stack.isEmpty()) {
        // 注意pop的顺序要对应上
        String path = (String) stack.pop();
        TreeNode cur = (TreeNode) stack.pop();
        if (cur.left == null && cur.right == null) {
            res.add(path);
        }
        // 因为root的值先加了 所以 -> 后拼上
        if (cur.right != null) {
            stack.push(cur.right);
            stack.push(path + "->" + cur.right.val);
        }
        if (cur.left != null) {
            stack.push(cur.left);
            stack.push(path + "->" + cur.left.val);
        }
    }
    return res;
}
```



**BFS**

同理

```java
// bfs
public List<String> binaryTreePaths3(TreeNode root) {
    List<String> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Queue<Object> queue = new LinkedList<>();
    queue.offer(root);
    queue.offer(root.val + "");
    while (!queue.isEmpty()) {
        TreeNode cur = (TreeNode) queue.poll();
        String path = (String) queue.poll();
        //如果到叶子节点，说明找到了一条完整路径
        if (cur.left == null && cur.right == null) {
            res.add(path);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
            queue.offer(path + "->" + cur.right.val);
        }
        if (cur.left != null) {
            queue.offer(cur.left);
            queue.offer(path + "->" + cur.left.val);
        }
    }
    return res;
}
```



### 求根节点到叶节点数字之和

#### 题目描述

[LeetCode129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)



#### 题解



**回溯**

代码1：

最容易理解的做法

```java
public int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    dfs(root);
    return res;
}

// 回溯
private void dfs(TreeNode root) {
    // 递归终止1
    if (root == null) {
        return;
    }
    // 递归终止2
    if (root.left == null && root.right == null) {
        path.add(root.val);
        res += getValue(path);
        path.remove(path.size() - 1);
        return;
    }
    // 经典回溯
    path.add(root.val);
    dfs(root.left);
    path.remove(path.size() - 1);

    path.add(root.val);
    dfs(root.right);
    path.remove(path.size() - 1);
}

// 转化成正确的值
private int getValue(List<Integer> path) {
    int n = path.size();
    int value = 0;
    for (int i = 0; i < n; i++) {
        // 10的n - 1 - i 次方 乘上 i位的值
        value += Math.pow(10, n - 1 - i) * path.get(i);
    }
    return value;
}

// 对于转化成数值还可以 只不过一个是一次性扩大次方，一个是逐步扩大
/*
private int getValue2(List<Integer> path) {
    int value = 0;
    for (int i : path) {
        value += i * 10 + path.get(i);
    }
    return value;
}
*/
```



代码2：

对于路径变量可以选择字符串，并当做方法参数，可以做隐式回溯，自动做一个状态重置，并且字符串做path的话转换成数值也会简单很多。

```java
private int res = 0;
public int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    dfs(root, "");
    return res;
}

// 回溯
private void dfs(TreeNode root,String path) {
    // 递归终止1
    if (root == null) {
        return;
    }
    path += root.val;
    // 递归终止2
    if (root.left == null && root.right == null) {
        res += Integer.parseInt(path);
        return;
    }
    // 经典回溯
    dfs(root.left, path);
    dfs(root.right, path);
}
```



代码3：

别的题解，直接将累加和当做参数传递，不是很常规的做法

```java
public int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return sumNumbers(root, 0);
}

private int sumNumbers(TreeNode root, int cumsum) {
    if (root == null) {
        return 0;
    }
    cumsum = 10 * cumsum + root.val;
    if (root.left == null && root.right == null) {
        return cumsum;
    }
    return sumNumbers(root.left, cumsum) + sumNumbers(root.right, cumsum);
}
```



### 二叉树层序遍历进阶

#### 问题描述

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```



#### 题解

层序遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> levelList;
    if (root == null) {
        return res; 
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    int levelCount = 0;
    while (!queue.isEmpty()) {
        levelList = new ArrayList<>();
        levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 记录每一层的信息
        res.add(levelList);
    }
    return res;
}
```



总结：最大宽度和该题都是**层次划分**的套路，每次while循环记录一下levelCount，按levelCount在里面for循环遍历即可

### 树与二叉树的转化

### 折痕问题

#### 题目描述

```java
* 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。
* 此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。
* 如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，
* 从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，
* 请从上到下打印所有折痕的方向。 例如：
* N=1时，
* 打印： down
* N=2时，
* 打印： down down up
```



#### 题解

```java
/**
 * 实际上就是一颗二叉树 折痕当做结点
 * 该树的特点 树的根节点是凹 左孩子结点为凹 右孩子结点为凸
 * 用 i 表示层数 如果是纸条从上往下打印 就是中序遍历
 * @param N
 */
public static void printAllFolding(int N) {
    inOrder(1, N, true);
}

public static void inOrder(int i, int N, boolean isDown) {
    if (i > N) {
        return;
    }
    inOrder(i + 1, N, true);
    System.out.print(isDown ? "第" + i + "次凹 " : "第" + i + "次凸 ");
    inOrder(i + 1, N, false);
}
```



### 二叉树完全性检验

#### 题目描述

[958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

给定一个二叉树的 `root` ，确定它是否是一个 *完全二叉树* 。

在一个 **[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)** 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 `1` 到 `2h` 节点之间的最后一级 `h` 。

 

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/complete-binary-tree-1.png)

```
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
```

**示例 2：**

**![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/complete-binary-tree-2.png)**

```
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
```

 

#### 题解

层序遍历框架改写加两个原则：

- 有右孩子但是没有左孩子，必不为完全二叉树
- 某一层中若出现某结点的子树不全(只有一个孩子或者没有孩子)，则剩下结点若不都是叶子结点，必不为完全二叉树

层序遍历完全，若不违反上面两个原则，则为完全二叉树

```java
public static boolean isCompleteBTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    // 是否有孩子不全的结点
    boolean isNotFullChild = false;
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    while (!queue.isEmpty()) {
        cur = queue.poll();

        // 第一种情况：有孩子不全的结点出现且后面结点不都为叶子结点
        // 第二种情况：右子树为空且左子树不为空
        if ((isNotFullChild && (cur.left != null || cur.right != null))
                || (cur.right != null && cur.left == null)) {
            return false;
        }

        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }

        // 第一次出现孩子不全的结点，进行标记
        // 标记一定要在最后进行，因为我们判断的是之后的结点是否都为叶子结点，
        // 如果if放在前面会出现把自己标记，又拿自己参与判断的情况
        if (cur.left == null || cur.right == null) {
            isNotFullChild = true;
        }

    }
    return true;
}
```



### 平衡二叉树

#### 题目描述

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```



#### 题解

虽然不是最优解，但是是比较容易理解的自顶向下递归方式

1. **找整个递归的终止条件：递归应该在什么时候结束？**
2. **找返回值：应该给上一级返回什么信息？**
3. **本级递归应该做什么：在这一级递归中，应该完成什么任务？**

我们只需要关心最顶层的递归需要做什么才能得到答案

判断一颗二叉树是否为平衡二叉树的条件：

- 左子树为平衡二叉树
- 右子树为平衡二叉树
- 左右子树的高度差不大于1

上面三个条件只要满足了，整颗二叉树就是平衡二叉树

那我们只需要每次递归中返回子树的两个信息：是否为平衡二叉树和最深深度

将这两个信息进行处理就能得到答案

```java
public static class Info{
    public boolean isBalanced;
    public int depth;
    public Info(boolean isBalanced,int depth) {
        this.isBalanced = isBalanced;
        // 深度
        this.depth = depth;
    }
}
public static boolean isBalanced(TreeNode root) {
    return process(root).isBalanced;
}
public static Info process(TreeNode root) {
    // 为空 递归结束 返回信息
    if (root == null) {
        return new Info(true,0);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean isBalanced = true;
    // 子树中最深的一条路径 + 1 就是root的最深路径
    int depth = Math.max(leftInfo.depth,rightInfo.depth) + 1;
    // 不同时满足三个条件的root就不是平衡二叉树
    if (!leftInfo.isBalanced || !rightInfo.isBalanced
            || Math.abs(leftInfo.depth - rightInfo.depth) > 1) {
        isBalanced = false;
    }
    return new Info(isBalanced,depth);
}
```



如果不用info类这种套路的话，我们依然是需要记录子树的信息的，左右子树是否为平衡二叉树和左右子树的高度差，显然直接使用`boolean`类型记录是不够用的，我们使用一个`int`类型就能表示我们需要的所有信息，`-1`表示不平衡，非负整数表示树的高度

```java
public boolean isBalanced(TreeNode root) {
    return getHeight(root) != -1;
}
private int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = getHeight(root.left);
    int rightHeight = getHeight(root.right);
    // 左右子树至少有一个没有平衡性 则整颗树不平衡
    if (leftHeight == -1 || rightHeight == -1) {
        return -1;
    }
    // 左右子树都为平衡二叉树 但是左右子树高度差大于1
    if (Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    }
    // 返回以root为根的树的高度
    return Math.max(leftHeight, rightHeight) + 1;
}
```



### 二叉树直径

#### 题目描述

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。



#### 题解

DFS求左右子树的最深路径，左右子树最深路径之和的最大值就是直径

```java
private int res = 0;
public int diameterOfBinaryTree(TreeNode root) {
    process(root);
    // 注意是返回res 不是process的返回值
    return res;
}
public int process(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = process(root.left);
    int rightDepth = process(root.right);
    res = Math.max(res, leftDepth + rightDepth);
    // 返回左右子树的最深一条路径 加上来自己的一个距离
    return Math.max(leftDepth, rightDepth) + 1;
}
```

比如对于4来说，它的左右子树最深路径都为0，返回的时候要加上来4的一个距离

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220201214320795.png)

整棵树的其中一个直径就是1的左子树2的最深路径加上1的右子树3的最深路径

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220201214638741.png)



### 满二叉树检验

#### 问题描述

```
对于满二叉树的定义，国内外不一样
* 国内：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
* 国外：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。
* 这里算法按照国内的来
```

所以满二叉树满足    结点数= 2 ^ 二叉树的深度 - 1，

我们只需要返回每棵子树的结点数和深度就可以进行递归判断

#### 题解

```java
public static class Info {
    public int depth;
    public int nodes;

    public Info(int depth, int nodes) {
        this.depth = depth;
        this.nodes = nodes;
    }
}

public static boolean isFullBTree(TreeNode root) {
    Info rootInfo = process(root);
    //return Math.pow(2, rootInfo.depth) - 1 == rootInfo.nodes;
    // 次方可以用位运算
    return (1 << rootInfo.depth) - 1 == rootInfo.nodes;
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(0, 0);
    }

    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);
    int curDepth = Math.max(leftInfo.depth, rightInfo.depth) + 1;
    int curNodes = leftInfo.nodes + rightInfo.nodes + 1;
    return new Info(curDepth, curNodes);
}
```



## 二叉搜索树

- [ ] 删除二叉搜索树中的节点 
- [ ] 看二叉搜索树的基本操作
- [ ] ceshi 
- [ ] ceshi 

### 验证二叉搜索树

#### 问题描述

[LeetCode98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/BSTree.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`



#### 题解

思路一，可以用中序遍历验证是否升序

思路二，递归

**容易理解的递归**

- root的左子树满足二叉搜索树
- root的右子树满足二叉搜索树
- 左子树的最大值严格小于root.val且右子树的最小值严格大于root.val

**因为判断root == null 在递归中info比较难处理，那就换个思路，子树不为null才进入递归**

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return process(root).isBST;
}

public class Info {
    public int max;
    public int min;
    public boolean isBST;
    public Info(boolean isBST, int max, int min) {
        this.isBST = isBST;
        this.max = max;
        this.min = min;
    }
}

public Info process(TreeNode root) {
    Info curInfo = new Info(true, root.val, root.val);
    if (root.left != null) {
        Info leftInfo = process(root.left);
        if (!leftInfo.isBST || leftInfo.max >= root.val) {
            curInfo.isBST = false;
        }
        // 只需要在左子树更新最小值和在右子树更新最大值，就算出现了不是搜索子树导致更新最值不正确也没什么所谓，因为已经记录的false值了
        //curInfo.max = Math.max(leftInfo.max,root.val);
        curInfo.min = Math.min(leftInfo.min, root.val);
    }
    if (root.right != null) {
        Info rightInfo = process(root.right);
        if (!rightInfo.isBST || rightInfo.min <= root.val) {
            curInfo.isBST = false;
        }
        curInfo.max = Math.max(rightInfo.max, root.val);
        //curInfo.min = Math.min(rightInfo.min,root.val);
    }
    return curInfo;
}
```

个人比较习惯写法：

还是在递归里处理null

```java
public static Info process2(TreeNode root) {
    if (root == null) {
        return new Info(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process2(root.left);
    Info rightInfo = process2(root.right);
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    boolean curIsBST = false;
    if (leftInfo.isBST && rightInfo.isBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curIsBST = true;
    }
    return new Info(curIsBST, curMax, curMin);
}
```



**DFS**

其他写法

```java
// 更新
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return dfs(root, null, null);
}

private boolean dfs(TreeNode node, Integer min, Integer max) {
    if (node == null) {
        return true;
    }
    if (min != null && min >= node.val) {
        return false;
    }
    if (max != null && max <= node.val) {
        return false;
    }
    return dfs(node.left, min, node.val) && dfs(node.right, node.val, max);
}
```



**中序遍历**

```java
// 中序遍历验证
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }

    List<Integer> res = new ArrayList<>();
    inOrder(root, res);

    int n = res.size();
    // 注意边界
    for (int i = 0; i < n - 1; i++) {
        if (res.get(i + 1) <= res.get(i)) {
            return false;
        }
    }
    return true;
}

private void inOrder(TreeNode node, List<Integer> res) {
    if (node == null) {
        return;
    }
    inOrder(node.left, res);
    res.add(node.val);
    inOrder(node.right, res);
}
```



### 最大二叉搜索树

#### 题目描述

leetcode333

给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。注意：子树必须包含其所有后代。

#### 题解

递归套路，自顶向下跟子树要信息

返回最大结点数量

```java
public static int findMaxSubBSTreeSize(TreeNode root) {
    /*if (root == null) {
        return 0;
    }*/
    return process(root).maxBSTSubTreeSize;
}

public static class Info {
    public boolean isAllBST;
    public int maxBSTSubTreeSize;
    public int max;
    public int min;

    public Info(boolean isAllBST, int maxBSTSubTreeSize, int max, int min) {
        this.isAllBST = isAllBST;
        this.maxBSTSubTreeSize = maxBSTSubTreeSize;
        this.max = max;
        this.min = min;
    }
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean curIsAllBST = false;
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    // 若左右子树都不存在搜索树 curMaxBSTSubTreeSize默认值就是1 自身一个节点（假定只有一个结点时也是二叉搜索树）
    int curMaxBSTSubTreeSize = 1;
    // 子树存在最大二叉搜索树，取其最大值
    if (leftInfo.maxBSTSubTreeSize != 0 || rightInfo.maxBSTSubTreeSize != 0) {
        curMaxBSTSubTreeSize = Math.max(leftInfo.maxBSTSubTreeSize, rightInfo.maxBSTSubTreeSize);
    }
    // 左右子树整颗都为二叉搜索树且满足左子树最大值 < root.val 右子树最小值> root.val
    // 更新curMaxBSTSubTreeSize 等于左+右+自身的一个节点
    if (leftInfo.isAllBST && rightInfo.isAllBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curMaxBSTSubTreeSize = leftInfo.maxBSTSubTreeSize + rightInfo.maxBSTSubTreeSize + 1;
        curIsAllBST = true;
    }
    return new Info(curIsAllBST, curMaxBSTSubTreeSize, curMax, curMin);
}
```

返回最大二叉搜索子树





### 二叉搜索树的最近公共祖先

#### 题目描述

[LeetCode235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)



#### 题解



**DFS**

根据 p、q 结点的位置分类讨论

- p、q 结点位于 node 结点的两侧，则 node 结点就是 p、q 最近公共祖先
- p、q 结点都位于 node 结点同一侧，则它们的最近公共祖先一定在 p、q 所在的一侧，继续递归调用 p、q 所在的一侧的子树
- p、q 其中之一位于 node 结点，则 node 结点就是 p、q 最近公共祖先

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%881.drawio.png)





### 删除二叉搜索树中的节点

#### 题目描述

[LeetCode450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

#### 题解



### 将有序数组转换为二叉搜索树

#### 题目描述

[LeetCode108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

#### 题解





### 二叉搜索树中第K小的元素

#### 题目描述

[LeetCode230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

#### 题解



# 并查集

### 模板

并查集的两个优化

- 路径压缩
- 按秩合并

同时使用两个的话，并查集的查询和合并的效率是可以达到O(1)的

```java
/**
 * 经典并查集
 *
 * @author novo
 * @date 2022/2/3-22:39
 */
public class UnionFindSet {
    private int[] parent;
    private int[] rank;

    public UnionFindSet(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
    }

    public void build(int n) {
        for (int i = 0; i < n; i++) {
           	rank[i] = 1;
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            //return find(parent[x]);
            // 在返回的路上进行路径压缩 在每次查找时 把查找路径上(注意只压缩路径上的)的每个结点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int x, int y) {
        if (x == y) {
            return;
        }
        // 将x接到y
        parent[find(x)] = find(y);
    }

    // 按秩合并
    public void union2(int x, int y) {
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
    }

    // 返回集合个数
    public int getUnionSize(int n) {
        int size = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i) {
                size++;
            }
        }
        return size;
    }
}
```



### 1、省份数量

#### 题目描述

[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/graph1.jpg)

```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

**示例 2：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/graph2.jpg)

```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```



#### 题解

经典并查集模型

如果相连，就加入同一集合，最后返回集合的个数

```java
private int[] parent;
public int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}
public void union(int x, int y) {
    if (x == y) {
        return;
    }
    parent[find(x)] = find(y);
}
public int getUnionSize(int n) {
    int size = 0;
    for (int i = 0; i < n; i++) {
        if (find(i) == i) {
            size++;
        }
    }
    return size;
}
public int findCircleNum(int[][] isConnected) {
    int n = isConnected.length;
    parent = new int[n];
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
    // j = i + 1 只遍历右上角且不遍历对角线 因为对称
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                union(i, j);
            }
        }
    }
    // 返回并查集集合的个数
    return getUnionSize(n);
}
```



### 2、岛屿数量

#### 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等1527收藏分享切换为英文接收动态反馈

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示**：

- ```
  m == grid.length
  ```

- ```
  n == grid[i].length
  ```

- ```
  1 <= m, n <= 300
  ```

- ```
  grid[i][j] 的值为 '0' 或 '1'
  ```

  

#### 题解

看题目给的数据范围，时间复杂度O(m * n)是可以的

##### **深搜**

把数组都遍历一遍，将所有为1的都合并在一起，为1的进去递归，对上下左右都递归，形象的比喻成感染，对上下左右感染，递归退出则合并完毕

```java
public int numIslands(char[][] grid) {
    int islands = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == '1') {
                islands++;
                merge(grid, i, j);
            }
        }
    }
    return islands;
}

public void merge(char[][] grid, int i, int j) {
    if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] != '1') {
        return;
    }
    grid[i][j] = 'X';
    merge(grid, i - 1, j);
    merge(grid, i + 1, j);
    merge(grid, i, j - 1);
    merge(grid, i, j + 1);
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220204234121850.png)

##### **并查集**

把都为1的合并

二维数组使用并查集需要将每个二维坐标转换成一维坐标，就能使每个索引唯一

```
(i, j) ==> i * 列数 + j
就是将二维数组转换成一维数组该怎么表示
```



```java
public class UnionFindSet {
    // 并查集模板...
}
public int numIslands(char[][] grid) {
    // 方向数组
    int[][] directs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int m = grid.length;
    int n = grid[0].length;
    // 需要记录0的地方
    int zero = 0;
    UnionFindSet set = new UnionFindSet(m * n);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                // 检索四个方向
                for (int[] direct : directs) {
                    int x = i + direct[0];
                    int y = j + direct[1];
                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == '1') {
                        // 合并
                        set.union(x * n + y, i * n + j);
                    }
                }
            } else {
                zero++;
            }
        }
    }
    // 注意要记录0的数量 减去0的数量
    return set.getUnionSize(m * n) - zero;
}
```

虽然代码量比较多，而且跑出来执行用时不太好看，但是跟深搜都是一样的时间复杂度O(m * n)，都是最优解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220204233443138.png)





### 3、岛屿数量 II

#### 题目描述

[305. 岛屿数量 II](https://leetcode-cn.com/problems/number-of-islands-ii/)

给你一个大小为 `m x n` 的二进制网格 `grid` 。网格表示一个地图，其中，`0` 表示水，`1` 表示陆地。最初，`grid` 中的所有单元格都是水单元格（即，所有单元格都是 `0`）。

可以通过执行 `addLand` 操作，将某个位置的水转换成陆地。给你一个数组 `positions` ，其中 `positions[i] = [ri, ci]` 是要执行第 `i` 次操作的位置 `(ri, ci)` 。

返回一个整数数组 `answer` ，其中 `answer[i]` 是将单元格 `(ri, ci)` 转换为陆地后，地图中岛屿的数量。

**岛屿** 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/10/tmp-grid.jpg)

```
输入：m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
输出：[1,1,2,3]
解释：
起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
- 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。此时存在 2 个岛屿。
- 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。此时存在 3 个岛屿。
```

**示例 2：**

```
输入：m = 1, n = 1, positions = [[0,0]]
输出：[1]
```

注意：addland可能出现同一个位置

**提示：**

- `1 <= m, n, positions.length <= 104`
- `1 <= m * n <= 104`
- `positions[i].length == 2`
- `0 <= ri < m`
- `0 <= ci < n`

**进阶：**你可以设计一个时间复杂度 `O(k log(mn))` 的算法解决此问题吗？（其中 `k == positions.length`）



#### 题解

这题只能用并查集求连通分量，相比于岛屿数量问题1，它是动态的生成岛屿，而不是全部给出来

对于每个 addLand 操作。需要注意的逻辑是：

如果 addLand 操作的顶点已经访问过，跳过；
如果 addLand 操作的顶点没有访问过，此时需要增加连通分量个数，然后再将它与「上」「下」「左」「右」合并。



```java
public List<Integer> numIslands2(int m, int n, int[][] positions) {
    UnionFindSet set = new UnionFindSet(m * n);
    List<Integer> res = new ArrayList<>();
    int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] position : positions) {
        int i = position[0];
        int j = position[1];
        set.visited[i * n + j] = true;
        for (int[] direct : directs) {
            int x = i + direct[0];
            int y = j + direct[1];
            // x、y没有越界且已经变成岛屿
            if (x >= 0 && y >= 0 && x < m && y < n && set.visited[x * n + y]) {
                set.union2(i * n + j, x * n + y);
            }
        }
        res.add(set.getUnionSize(m * n));
    }
    return res;
}

public class UnionFindSet {
    private int[] parent;
    private int[] rank;
    public boolean[] visited;
	// ...省略常用方法
    // 返回集合个数
    public int getUnionSize(int n) {
        int size = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i && visited[i]) {
                size++;
            }
        }
        return size;
    }
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220205151254844.png)



差点超时了，如果降落的次数为k的话，总的时间复杂度是O(k + m * n)，速度太慢应该是，每次降落后都要调用set.getUnionSize(m * n)查询连通分量，于是对并查集进行了优化，再定义一个size变量来记录连通分量。

```java
public List<Integer> numIslands2(int m, int n, int[][] positions) {
    UnionFindSet set = new UnionFindSet(m * n);
    List<Integer> res = new ArrayList<>();
    int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] position : positions) {
        int i = position[0];
        int j = position[1];
        // 注意没被降落过的才size++
        if (!set.visited[i * n + j]) set.size++;
        set.visited[i * n + j] = true;
        for (int[] direct : directs) {
            int x = i + direct[0];
            int y = j + direct[1];
            // x、y没有越界且已经变成岛屿
            if (x >= 0 && y >= 0 && x < m && y < n && set.visited[x * n + y]) {
                // 注意合并的方法这里需要判断是否已经合并过 否则size不准
                set.union2(i * n + j, x * n + y);
            }
        }
        // 直接返回set.size
        res.add(set.size);
    }
    return res;
}

public class UnionFindSet {
    private int[] parent;
    private int[] rank;
    private int size;
    public boolean[] visited;
    public UnionFindSet(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
        this.visited = new boolean[size];
        build(size);
    }

    public void build(int n) {
        for (int i = 0; i < n; i++) {
            visited[i] = false;
            rank[i] = 1;
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            //return find(parent[x]);
            // 在返回的路上进行路径压缩 在每次查找时 把查找路径上(注意只压缩路径上的)的每个结点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 注意合并的时候需要判断 是否已经合并过了，因为测试用例可能会重复，否则size会多减
    public void union(int x, int y) {
        if (x == y) {
            return;
        }
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        // 将x接到y
        parent[x] = y;
        size--;
    }

    // 按秩合并
    public void union2(int x, int y) {
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
        size--;
    }
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220205152410321.png)







# 递归与回溯

这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， **为什么有的时候用 `used` 数组，有的时候设置搜索起点 `begin` 变量**，理解状态变量设计的想法。 ----- Copyright by liweiwei1419. Link: https://suanfa8.com/algorithm-idea/backtracking/07-practice/

回溯其实就是横向遍历，纵向递归的组合。

说白了就是一种尝试的过程，试过了返回再次尝试下一种可能



## 排列

### 全排列

#### 题目描述

[46. 全排列](https://leetcode-cn.com/problems/permutations/)



#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used ;
public List<List<Integer>> permute(int[] nums) {
    if (nums == null || nums.length == 0) {
        return res;
    }
    used = new boolean[nums.length];
    backTracking(nums, 0);
    return res;
}

// path和index都可以作为可变参数 需要知道为什么传这个参数，这个参数的目的，而不是固定传参
public void backTracking(int[] nums, int index) {
    if (index == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++){
        if(!used[i]) {
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums, index + 1);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



### 全排列 II

#### 题目描述

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)



#### 题解

去重

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> permuteUnique(int[] nums) {
    used = new boolean[nums.length];
    Arrays.sort(nums);
    backTracking(nums);
    return res;
}

public void backTracking(int[] nums) {
    if (path.size() == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (!used[i]) {
            // used[i - 1] == false 说明被回溯过 回到同一层，若此时nums[i] == nums[i - 1]说明在树层出现重复，即深搜起点一样需要剪枝
            // 当used[i - 1] == true 说明在深搜树枝，可以重复
            if (i > 0 && !used[i - 1] && nums[i] == nums[i - 1]) {
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums);
            // 回溯
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



#### 题解



## 组合

```
// 按序搜索是避免 出现组合重复 [2, 2, 1], [2, 1, 2]
// 而used数组是为了避免在同一层级上选到值一样的元素 第三位的2虽然来源不相等 但是他们的值是一样的 [2, 1, 2], [2, 1, 2]
```



### 电话号码的字母组合

#### 题目描述

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。



#### 题解

时间复杂度: `O(2^len(digits.length))`

时间复杂度: `O(log(len(digits.length))`

以digits == "23"为例：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220207133312605.png)

```java
private String[] letterMap = {
            " ",   // 0
            "",    // 1
            "abc", // 2
            "def", // 3
            "ghi", // 4
            "jkl", // 5
            "mno", // 6
            "pqrs",// 7
            "tuv", // 8
            "wxyz" // 9
    };
    private List<String> res = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        // 测试用例为空时 输出：[] 而不是[""]
        if ("".equals(digits)){
            return res;
        }
        String path = "";
        backTracking(digits.toCharArray(), 0, path);
        return res;
    }

    public void backTracking(char[] digits, int index, String path) {
        System.out.println(index + ":" + path);
        if (index == digits.length) {
            res.add(path);
            return;
        }
        // 减去'0' 对应的就是哪个letter
        String letters = letterMap[digits[index] - '0'];
        int n = letters.length();
        for (int i = 0; i < n; i++) {
            System.out.println("digits[" + index + "] = " + path + " , use " + letters.charAt(i));
            backTracking(digits, index + 1, path + letters.charAt(i));
        }
        System.out.println("digits[" + index + "] = " + path + " complete, return");
    }
```



### 组合

#### 题目描述

[77. 组合](https://leetcode-cn.com/problems/combinations/)

#### 题解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220208153744231.png)



```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combine(int n, int k) {
    if (n <= 0 || k <= 0 || k > n) {
        return res;
    }
    backTracking(n, k, 1);
    return res;
}

public void backTracking(int n, int k, int index) {
    if (path.size() == k) {
        res.add(new ArrayList<>(path));
        return;
    }
    // [1, n]的组合 所以index从1开始 <= n
    // 还剩 k - path.size() 个空位，所以[i...n]中至少要有k-path.size()个元素
    // 例如至少要有2个元素 i要<= n-1 至少要有1个元素 i <= n
    for (int i = index; i <= n - (k - path.size()) + 1; i++) {
        /*if (path.size() >= k) {
            break;
        }*/
        path.add(i);
        /*System.out.println("index:" + index);
        System.out.println("path: " + path);*/
        backTracking(n, k, i + 1);
        path.remove(path.size() - 1);
    }
}
```



### 组合总和

#### 题目描述

[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

#### 题解

核心点就是用i来控制在一次深搜中可以回头，出现分支(另一次深搜)不可以回头

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    if (candidates == null || candidates.length == 0) {
        return res;
    }
    backTracking(candidates, 0, target);
    return res;
}

// 使用index
public void backTracking(int[] candidates, int index, int target) {
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        if (candidates[i] > target) {
            // 没用排序 只能continue  如果用排序的话可以直接break
            continue;
        }
        path.add(candidates[i]);
        // 可以用i来控制每次的深搜都可以选所有值，而不是i+1 一次完整的深搜到尽头后才会++，又保证的下一次深搜不会选到重复的值
        backTracking(candidates, i, target - candidates[i]);
        path.remove(path.size() - 1);
    }
}
```



### 组合总和 II

#### 题目描述

[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)



#### 题解

总结：

给定数组中可能出现重复元素，每次不能选相同位置的元素，用used数组，不能回头

给定数组中不会出现重复元素，而每次可以选相同的位置元素的情况下，不需要used数组，可以回头

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    if (candidates == null || candidates.length == 0) {
        return res;
    }
    used = new boolean[candidates.length];
    Arrays.sort(candidates);
    backTracking(candidates, 0, target);
    return res;
}

public void backTracking(int[] candidates, int index, int target) {
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        // 去重 used[i - 1] == false 说明现在处在同一层 被回溯过不可以选
        if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
            continue;
        }
        // 剪枝
        if (candidates[i] > target) {
            // 已经有序 可以break
            break;
            //continue;
        }
        used[i] = true;
        path.add(candidates[i]);
        backTracking(candidates, i + 1, target - candidates[i]);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}
```



### 组合总和 III

#### 题目描述

[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)



#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combinationSum3(int k, int n) {
    if (k == 0) {
        return res;
    }
    backTracking(k, 1, n);
    return res;
}

public void backTracking(int k, int index, int n) {
    // 如果path大小等于k都要return，不需要继续深搜
    if (path.size() == k) {
        if(n == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }
    // 只能选1~9且不能重复 数据太小剪枝意义不大
    for (int i = index; i <= 9; i++) {
        path.add(i);
        backTracking(k, i + 1, n - i);
        path.remove(path.size() - 1);
    }
}
```



### 组合总和 Ⅳ

#### 题目描述

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

#### 题解

这里不能用回溯，回溯会超时

[点击跳转](#combination-sum-iv)

### 二进制手表

#### 题目描述

google面试题

[401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)



#### 题解

```java
// 比较巧妙的是这两个hours和minutes数组，相当于将所有灯的选择都合并在一起，
// for横向遍历的时候都选择两个数组的元素，实际上只选择了一个，因为另一个是0
int[] hours = new int[]{1, 2, 4, 8, 0, 0, 0, 0, 0, 0};
int[] minutes = new int[]{0, 0, 0, 0, 1, 2, 4, 8, 16, 32};
List<String> res = new ArrayList<>();

public List<String> readBinaryWatch(int turnedOn) {
    backTracking(turnedOn, 0, 0, 0);
    return res;
}

public void backTracking(int turnedOn, int index, int hour, int minute) {
    //4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。
    if (hour > 11 || minute > 59) {
        return;
    }
    if (turnedOn == 0) {
        StringBuilder path = new StringBuilder();
        path.append(hour).append(":");
        if (minute < 10) {
            path.append("0");
        }
        path.append(minute);
        res.add(path.toString());
        return;
    }
    for (int i = index; i < 9; i++) {
        backTracking(turnedOn - 1, i + 1, hour + hours[i], minute + minutes[i]);
        // 回溯体现在hour + hours[i]、minute + minutes[i]这个操作只是做了参数传递，退出来后hour已经还原了
    }
}
```



## 子集

### 子集

#### 题目描述

[78. 子集](https://leetcode-cn.com/problems/subsets/)



#### 题解

求子集问题，本质就是要遍历整颗树，不需要剪枝



**第一种思路**

对于每个位置，只有选与选两种抉择，本质上就是一颗二叉树

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1643212121-zZXdpR-image.png)

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    backTracking(nums, 0, path);
    return res;
}

public void backTracking(int[] nums, int index, List<Integer> path) {
    if (index == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    // 为什么不需要for循环 因为本质上就是一颗二叉树 每个结点只有选和不选两种选择，而不是选什么元素的问题
    // 不选
    backTracking(nums, index + 1, path);

    // 选
    path.add(nums[index]);
    backTracking(nums, index + 1, path);
    path.remove(path.size() - 1);
```



**第二种思路**

关心选什么元素，也就是最常见的回溯，需要for遍历

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631607104-NFVwFo-file_1631607104526)

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    backTracking(nums, 0, path);
    return res;
}

public void backTracking(int[] nums, int index, List<Integer> path) {
    res.add(new ArrayList<>(path));
    // 这里判断可以省略 
    if (path.size() == nums.length) {
        return;
    }
    for (int i = index; i < nums.length; i++) {
        path.add(nums[i]);
        backTracking(nums, i + 1, path);
        path.remove(path.size() - 1);
    }
}
```





### 子集 II

#### 题目描述

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

在子集1的问题上加了used去重以及按序搜索排除组合重复

#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;
public List<List<Integer>> subsetsWithDup(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    Arrays.sort(nums);
    used = new boolean[nums.length];
    backTracking(nums, 0);
    return res;
}

public void backTracking(int[] nums, int index) {
    res.add(new ArrayList<>(path));
    // 终止条件可以不写
    if (index == nums.length) {
        return;
    }

    for (int i = index; i < nums.length; i++) {
        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false){
            continue;
        }
        used[i] = true;
        path.add(nums[i]);
        backTracking(nums, i + 1);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}
```





## 分割

### 1、复原IP地址

#### 题目描述

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

#### 题解

![93.复原IP地址](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631606390-ioqLGF-file_1631606390061)



这题的可以剪枝的情况很多，但是如果都要对所有情况进行剪枝判断的话，反而效率会下降，我们只考虑对每一小段IP区间进行剪枝判断

```java
private List<String> res = new ArrayList<>();
// 需要频繁修改字符串
StringBuilder IP = new StringBuilder();

public List<String> restoreIpAddresses(String s) {
    IP.append(s);
    backTracking(IP, 0, 0);
    return res;
}

public void backTracking(StringBuilder IP, int index, int pointNum) {
    // 最后一个"."添加完 判断最后一段是否合法
    if (pointNum == 3) {
        if (isValid(IP.substring(index, IP.length()))) {
            res.add(IP.toString());
        }
        return;
    }
    // 属于切割问题 给定字符串上的数字我们是不能修改的，我们只能添加"."，我们并没有用path 所以这个i是不会回退的
    for (int i = index; i < IP.length(); i++) {
        System.out.println("index:" + index + "  i+1:" + (i + 1));
        // 判断选定区间是否合法   substring 左闭右开 [ )
        if (!isValid(IP.substring(index, i + 1))) {
            break;
        }
        // 合法
        IP.insert(i + 1, ".");
        System.out.println(IP);
        backTracking(IP, i + 2, pointNum + 1);
        // 消除痕迹 回溯
        IP.deleteCharAt(i + 1);
    }
}

// 校验每一小段的IP是否合法
public boolean isValid(String str) {
    System.out.println("小段区间：" + str);
    if (str == null || str.length() == 0) {
        return false;
    }
    // 校验是否含前导0
    if (str.charAt(0) == '0' && str.length() > 1) {
        return false;
    }
    // 校验每一位字符是否为0~9
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) < '0' || str.charAt(i) > '9') {
            return false;
        }
    }
    // 校验是否属于0~255
    if (Long.parseLong(str) > 255 || Long.parseLong(str) < 0) {
        return false;
    }
    return true;
}
```



### 2、分割回文串

#### 题目描述

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)



#### 题解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631606009-OMGnoi-image.png)



```java
private List<List<String>> res = new ArrayList<>();
private List<String> path = new ArrayList<>();
private StringBuilder str = new StringBuilder();

public List<List<String>> partition(String s) {
    str.append(s);
    backTracking(str, 0);
    return res;
}

public void backTracking(StringBuilder str, int index) {
    // 切割完毕
    if (index == str.length()) {
        System.out.println("path：" + path + "切割完成");
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < str.length(); i++) {
        System.out.print("path:" + path + "   ");
        System.out.println("index: " + index + " i: " + i);
        // 不是回文串
        if (!isPalindrome(str, index, i)) {
            continue;
        }
        // [index, i + 1)
        String s = str.substring(index, i + 1);
        path.add(s);
        backTracking(str, i + 1);
        path.remove(path.size() - 1);
    }
}

// 判断是否回文
private boolean isPalindrome(StringBuilder s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
    }
    return true;
}
```



## 二维平面

遇到这个问题，一个非常重要的事情是：**问清楚面试官，是否可以修改传来的 nums 数组**

如果可以修改的话，代码可以写得比较简洁，就不需要用额外的visited数组来标记了

### 单词搜索

#### 题目描述

[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

#### 题解

二维平面上使用回溯

只要是涉及下标越界的地方，先判断是否越界是更好的做法。

```java
// 也可以用二维数组
private boolean[] visited;
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private int m;
private int n;

public boolean exist(char[][] board, String word) {
    if (board == null || board.length == 0 || word == null || word.length() == 0) {
        return false;
    }
    m = board.length;
    n = board[0].length;
    visited = new boolean[m * n];
    char[] wordChar = word.toCharArray();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 只要找到一个就提前return true
            if (dfs(board, wordChar, 0, i, j)) {
                return true;
            }
        }
    }
    return false;
}

public boolean dfs(char[][] board, char[] wordChar, int index, int x, int y) {
    // 搜索到单词字母最后一个 需要返回结果 不需要再深搜 提前return
    if (index == wordChar.length - 1) {
        return board[x][y] == wordChar[index];
    }

    if (board[x][y] == wordChar[index]) {
        visited[x * n + y] = true;
        for (int[] direct : directs) {
            int newX = x + direct[0];
            int newY = y + direct[1];
            // 先判断是否越界
            if (inArea(newX, newY) && !visited[newX * n + newY]) {
                if (dfs(board, wordChar, index + 1, newX, newY)) {
                    return true;
                }
            }
        }
        // 回溯 状态重置 保证在深搜的过程不会去搜重复的，但是退出深搜进行横向遍历的时候可以搜重复的
        visited[x * n + y] = false;
    }
    return false;
}

// 搜索区域是否合法
private boolean inArea(int x, int y) {
    return x >= 0 && y >= 0 && x < m && y < n;
}
```

### N 皇后

#### 题目描述

[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

#### 题解

N 皇后问题是有很多种优化方案的，这是比较经典的解法



**diagSub对角线**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212113406422.png)

**diagMain对角线**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212113248496.png)





```java
/**
 * 以 4 皇后为例的棋盘
 * [00, 01, 02, 03]
 * [10, 11, 12, 13]
 * [20, 21, 22, 23]
 * [30, 31, 32, 33]
 * <p>
 * 因为数组索引从0开始 我们用索引i - j + n - 1代表处于哪一条左对角线上
 * diagMain[-3, -2, -1, 0, 1, 2, 3] ==> [0, 1, 2, ..., i - j + n - 1]
 * <p>
 * diagSub[0, 1, 2, 3, 4, 5, 6] 用i + j代表代表处于哪一条右对角线上
 */
// 列状态 记录哪一列有皇后
private boolean[] col;
// 记录左上->右下的对角线状态 特点：对角线上每个元素i - j 相等
private boolean[] diagMain;
// 记录右上->左下的对角线状态 特点：对角线上每个元素i + j 相等
private boolean[] diagSub;
private List<List<String>> res = new ArrayList<>();
// 每个完整结果皇后的列坐标
private List<Integer> path = new ArrayList<>();

public List<List<String>> solveNQueens(int n) {
    col = new boolean[n];
    diagMain = new boolean[2 * n - 1];
    diagSub = new boolean[2 * n - 1];
    backTracking(n, 0);
    return res;
}

// index为行坐标
private void backTracking(int n, int index) {
    if (index == n) {
        // 将列坐标结果集转化为棋盘
        List<String> board = convert2board(path,n);
        res.add(board);
        return;
    }

    // 对列遍历 每一列选出一个皇后
    for (int j = 0; j < n; j++) {
        // 不在同一列、不在同一对角线
        if (!col[j] && !diagMain[index - j + n - 1] && !diagSub[index + j]) {
            path.add(j);
            col[j] = true;
            diagMain[index - j + n - 1] = true;
            diagSub[index + j] = true;

            backTracking(n, index + 1);
            // 回溯 状态重置
            path.remove(path.size() - 1);
            col[j] = false;
            diagMain[index - j + n - 1] = false;
            diagSub[index + j] = false;
        }
    }
}

// 将结果的列坐标转换成棋盘 path存储的是所有皇后的列坐标
private List<String> convert2board (List<Integer> path, int n) {
    List<String> board = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        char[] arr = new char[n];
        // 棋盘每一行先填充'.' 在将有皇后的位置修改为'Q'
        Arrays.fill(arr,'.');
        arr[path.get(i)] = 'Q';
        board.add(new String(arr));
    }
    return board;
}
```



### N 皇后 II

#### 题目描述

[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

N 皇后是求具体的解（棋盘的布局），而这题是求解的个数

#### 题解

可以直接用上一题的解，返回解的个数

```java
/**
    * 以 4 皇后为例的棋盘
    * [00, 01, 02, 03]
    * [10, 11, 12, 13]
    * [20, 21, 22, 23]
    * [30, 31, 32, 33]
    * <p>
    * 因为数组索引从0开始 我们用索引i - j + n - 1代表处于哪一条左对角线上
    * diagMain[-3, -2, -1, 0, 1, 2, 3] ==> [0, 1, 2, ..., i - j + n - 1]
    * <p>
    * diagSub[0, 1, 2, 3, 4, 5, 6] 用i + j代表代表处于哪一条右对角线上
    */
// 列状态 记录哪一列有皇后
private boolean[] col;
// 记录左上->右下的对角线状态 特点：对角线上每个元素i - j 相等
private boolean[] diagMain;
// 记录右上->左下的对角线状态 特点：对角线上每个元素i + j 相等
private boolean[] diagSub;
private List<List<Integer>> res = new ArrayList<>();
// 每个完整结果皇后的列坐标
private List<Integer> path = new ArrayList<>();

public int totalNQueens(int n) {
    col = new boolean[n];
    diagMain = new boolean[2 * n - 1];
    diagSub = new boolean[2 * n - 1];
    backTracking(n, 0);
    return res.size();
}

// index为行坐标
private void backTracking(int n, int index) {
    if (index == n) {
        res.add(new ArrayList<>(path));
        return;
    }

    // 对列遍历 每一列选出一个皇后
    for (int j = 0; j < n; j++) {
        // 不在同一列、不在同一对角线
        if (!col[j] && !diagMain[index - j + n - 1] && !diagSub[index + j]) {
            path.add(j);
            col[j] = true;
            diagMain[index - j + n - 1] = true;
            diagSub[index + j] = true;

            backTracking(n, index + 1);
            // 回溯 状态重置
            path.remove(path.size() - 1);
            col[j] = false;
            diagMain[index - j + n - 1] = false;
            diagSub[index + j] = false;
        }
    }
}
```



### 解数独

#### 题目描述

[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

#### 题解

这题难点是求解状态的表示

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

怎么设置上面的状态是关键

还有怎么加快搜索

```java
// 第二维的大小都设置成 10 是为了让 '1' 落在下标 1 的位置，'9' 落在下标 9 的位置
// row第一维表示哪一行，第二维表示含有哪个数字
private boolean[][] row = new boolean[9][10];
// col第一维表示哪一列，第二维表示含有哪个数字
private boolean[][] col = new boolean[9][10];
// cell 的第一维表示在哪个3*3的宫内
private boolean[][] cell = new boolean[9][10];

public void solveSudoku(char[][] board) {
    // 1 遍历一遍棋盘 将已有的数字设置状态
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                // 减去 '0' 是有 1 个位置的偏移
                int num = board[i][j] - '0';
                row[i][num] = true;
                col[j][num] = true;
                // [i][j] ==> [i / 3][j / 3]将9 * 9的小格缩小成3 * 3的大格
                // [i / 3][j / 3] ==> [i / 3 * 3 + j / 3] 二维转一维
                cell[i / 3 * 3 + j / 3][num] = true;
            }
        }
    }
    // 2 找到第一个为'.'的位置进行dfs搜索 这里至多只会执行n次，因为只是找出一个位置
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                backTracking(board, i * 9 + j);
            }
        }
    }
}

private boolean backTracking(char[][] board, int index) {
    // dfs到最后一个位置说明求解成功
    if (index == 9 * 9) {
        return true;
    }
    // 剪枝 找到下一个为'.'的一维值 否则会超时
    int next = index + 1;
    for (; next < 9 * 9; next++) {
        // 一维==>二维  i * n + j 所以二维坐标的i就等于一维值整除列数，j等于一维值模列数
        if (board[next / 9][next % 9] == '.') {
            break;
        }
    }

    int x = index / 9;
    int y = index % 9;
    for (int i = 1; i <= 9; i++) {
        if (!row[x][i] && !col[y][i] && !cell[x / 3 * 3 + y / 3][i]) {
            row[x][i] = true;
            col[y][i] = true;
            cell[x / 3 * 3 + y / 3][i] = true;
            // 将整型强制类型转换为字符型，JVM 会把数字当成字符的 ASCII 编码来处理
            // 所以要转传成正确的字符，要先加上48再强转，也是加上字符'0'
            board[x][y] = (char) ('0' + i);

            if (backTracking(board, next)) {
                return true;
            }
            // 回溯，状态重置
            row[x][i] = false;
            col[y][i] = false;
            cell[x / 3 * 3 + y / 3][i] = false;
            board[x][y] = '.';
        }
    }

    // 当前解尝试错误
    return false;
}
```



### 有效的数独

这题分类不是回溯，只是顺便放到这

#### 题目描述

[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，**验证已经填入的数字是否有效即可**。
- 空白格用 `'.'` 表示。

#### 题解

这题是比解数独简单很多的，因为只需要校验已经填入的部分数字是否有效即可

设置状态的思路是一样的

```java
private boolean[][] row = new boolean[9][10];
private boolean[][] col = new boolean[9][10];
private boolean[][] cell = new boolean[9][10];

public boolean isValidSudoku(char[][] board) {
    // 遍历棋盘
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            // 对已经填入的数字做校验
            if (board[i][j] != '.') {
                int num = board[i][j] - '0';
                // 在三个区域内第一次遇到num 设置为true
                if (!row[i][num] && !col[j][num] && !cell[i / 3 * 3 + j / 3][num]) {
                    row[i][num] = true;
                    col[j][num] = true;
                    cell[i / 3 * 3 + j / 3][num] = true;
                } else {
                    // 否则说明在同一区域内有重复数字出现
                    return false;
                }
            }
        }
    }
    // 遍历完没有非法数字
    return true;
}
```



### FloodFill算法

### 岛屿数量

#### 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)



#### 题解

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private boolean[] visited;
private int m;
private int n;

public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    int islands = 0;
    m = grid.length;
    n = grid[0].length;
    visited = new boolean[m * n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1' && !visited[i * n + j]) {
                islands++;
                dfs(grid, i, j);
            }
        }
    }
    return islands;
}

// floodfill算法实质就是深度优先遍历

/**
 * 注意点：
 * 1、这里表面并没有设置递归终止的条件
 * 但是搜索的位置的有限的，并且没有对visited进行状态重置
 * 所以递归的终止条件隐藏在if的判断语句中
 * 2、这个dfs没有回溯的过程，没有对visited进行状态重置，
 * 因为我们的目的只是将最初[i,j]这个位置相连的地方都标记为同一个岛屿而已，
 * 而不是在其中找到某一个具体的序列或值
 **/
private void dfs(char[][] grid, int x, int y) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 位置合法的陆地且没有被访问过
        if (inArea(newX, newY) && grid[newX][newY] == '1' && !visited[newX * n + newY]) {
            dfs(grid, newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && y >= 0 && x < m && y < n;
}
```



### 被围绕的区域

#### 题目描述

[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

> 注意：任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。



#### 题解

**DFS**

因为我们要区分出于在边界的'O'及与它相连的'O'，所以我们要从边界，**从外到内dfs**，对这些不需要被填充的成'X'的'O'进行一个标记

这里我用了visited数组，也可以不用，直接将不需要被填充的成'X'的'O'改成其它字符，最后再改回来

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private int m;
private int n;
private boolean[] visited;

public void solve(char[][] board) {
    if (board == null || board.length == 0) {
        return;
    }
    m = board.length;
    n = board[0].length;
    visited = new boolean[m * n];
    //1 对最外面一圈进行dfs，标记与外界相连的'0'
    // 对第一列和最后一列dfs
    for (int i = 0; i < m; i++) {
        if (board[i][0] == 'O') {
            dfs(board, i, 0);
        }
        if (board[i][n - 1] == 'O') {
            dfs(board, i, n - 1);
        }
    }
    // 对第一行和最后一行dfs
    for (int j = 0; j < n; j++) {
        if (board[0][j] == 'O') {
            dfs(board, 0, j);
        }
        if (board[m - 1][j] == 'O') {
            dfs(board, m - 1, j);
        }
    }
    // 2 遍历整个矩阵 将没有被标记到的'0'都填充成'X'
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'O' && !visited[i * n + j]) {
                board[i][j] = 'X';
            }
        }
    }
}

private void dfs(char[][] board, int x, int y) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY) && board[newX][newY] == 'O' && !visited[newX * n + newY]) {
            dfs(board, newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**BFS**

这里标记的过程也可以改成广度优先

**并查集**

另一种思路就是使用并查集

设置一个dummy虚拟节点，所有不需要覆盖的都和它相连，最后在遍历一遍，没有和dummy相连的就置为'X'。



### 太平洋大西洋水流问题

#### 问题描述

[417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)



#### 题解

这题跟**被围绕的区域**思路一样，都是**从外层开始dfs**，区别就是需要用两个不同的visited来标记太平洋和大西洋的访问状态



1、找出所有从**太平洋**出发升序的最高顶点

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1619850901-ToWmLO-8e9c842a24968824d18c4de2c520a6e.png)



2、找出所有从**大西洋**出发升序的最高顶点

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1619850909-byyyNx-521bfa8063d14254466a5d7f6600ae9.png)

3、这些重合的点最高顶点就是**可以使雨水同时流向太平洋和大西洋的地方**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1619850883-mLzTrV-06ce3f99a8742231c3f7d42dcac0c69.png)

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private List<List<Integer>> res = new ArrayList<>();
private boolean[] visitedP; // dfs太平洋状态
private boolean[] visitedA; // dfs大西洋状态
private int m;
private int n;

public List<List<Integer>> pacificAtlantic(int[][] heights) {
    if (heights == null || heights.length == 0) {
        return res;
    }
    m = heights.length;
    n = heights[0].length;
    visitedA = new boolean[m * n];
    visitedP = new boolean[m * n];

    // 对最外面一层dfs
    for (int i = 0; i < m; i++) {
        // 第一列太平洋
        dfs(heights, i, 0, visitedP);
        // 最后一列大西洋
        dfs(heights, i, n - 1, visitedA);
    }
    for (int j = 0; j < n; j++) {
        // 第一行太平洋
        dfs(heights, 0, j, visitedP);
        // 最后一行大西洋
        dfs(heights, m - 1, j, visitedA);
    }
	
    // 遍历整个岛屿 找出重合点
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (visitedA[i * n + j] && visitedP[i * n + j]) {
                List<Integer> position = new ArrayList<>();
                position.add(i);
                position.add(j);
                res.add(new ArrayList<>(position));
            }
        }
    }
    return res;
}

// 找出所有逆向的的终点即山顶位置，visitedP和visitedA的交集就是结果
private void dfs(int[][] heights, int x, int y, boolean[] visited) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 未被访问过的合法区域且heights[x][y] <= heights[newX][newY]即逆向
        if (inArea(newX, newY) && !visited[newX * n + newY] && heights[x][y] <= heights[newX][newY]) {
            dfs(heights, newX, newY, visited);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



# 动态规划

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212221152809.png)

记忆化搜索和动态规划的本质都是一样的

动态规划表示的是一堆集合的某种属性，而DFS是一个一个的枚举



记忆化搜素代码复制度比较低，自顶向下的方式容易调试，特别是一些区间，二维面积的问题，

一些线性的问题比较适合枚举的方式

## 经典问题



### 斐波那契数

#### 题目描述

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

#### 题解

**记忆化搜索**

```java
// memory都初始化为-1
    private int[] memory;

    // 记忆化搜索-自顶向下的解决问题 调用2n - 1次
    public int fib(int n) {
        if (n < 2) {
            return n;
        }
        memory = new int[n + 1];
        for (int i = 0; i < n + 1; i++) {
            memory[i] = -1;
        }
        memory[0] = 0;
        memory[1] = 1;
        return dfs(n);
    }

    private int dfs(int n) {
        if (memory[n] == -1) {
            memory[n] = dfs(n - 1) + dfs(n - 2);
        }
        return memory[n];
    }
```



**动态规划**

```java
// 动态规划 自底向上
public int fib(int n) {
    if (n < 2) {
        return n;
    }
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```





### 爬楼梯

#### 题目描述

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)



#### 题解

这个问题和斐波那契本质就是一样的



**记忆化搜索**

自顶向下思考：

爬上n阶楼梯，只有两类，第一类是从n-1阶再爬一阶，第二类是从n-2阶再爬两阶

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212222102767.png)

最底层就是爬0阶的可能性有1种，爬1阶的可能性有1中，爬2阶 = 爬0阶 + 爬1阶

```java
private int[] memory;
// 记忆化搜索
public int climbStairs(int n) {
    memory = new int[n + 1];
    for (int i = 0; i < n + 1;i++) {
        memory[i] = -1;
    }
    memory[0] = 1;
    memory[1] = 1;
    return dfs(n);
}
private int dfs(int n) {
    if (memory[n] == -1) {
        memory[n] = dfs(n - 1) + dfs(n - 2);
    }
    return memory[n];
}
```



**动态规划**

```java
// 动态规划
public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```



### 三角形最小路径和

#### 题目描述

[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

```java
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

**数据范围：**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-104 <= triangle[i][j] <= 104`

**进阶：**

- 你可以只使用 `O(n)` 的额外空间（`n` 为三角形的总行数）来解决这个问题吗？

#### 题解



**回溯**

按题目给的数据范围，回溯肯定是会超时的，但是顺便复习下回溯的思路解法

```java
private List<Integer> res = new ArrayList<>();
private int path;

public int minimumTotal(List<List<Integer>> triangle) {
    if (triangle == null || triangle.size() == 0) {
        return 0;
    }
    backTracking(triangle, 0, 0);
    // 选取最小路径和
    Collections.sort(res);
    return res.get(0);
}

// index 记录上次横向遍历的位置 下次只能从[index,index + 1]做选择 row记录当前层
private void backTracking(List<List<Integer>> triangle, int index, int row) {
    if (row == triangle.size()) {
        res.add(path);
        return;
    }
    for (int i = index; i < index + 2; i++) {
        // 检查每一层的i是否越界
        if (i != triangle.get(row).size()) {
            path += triangle.get(row).get(i);
            backTracking(triangle, i, row + 1);
            path -= triangle.get(row).get(i);
        }
    }
}
```

结果就是内存超了

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220213001048117.png)





**递归**

先自顶向下思考问题，再用记忆化搜索优化，再尝试自底向上使用动态规划

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/007S8ZIlgy1ggqa6f1notj317c0o8jti.jpg)

整颗树的最小路径，就是以3为根节点的树和以4为根节点的树其中路径和的最小值加上2这个顶点

```java
// 自顶向下递归
public int minimumTotal3(List<List<Integer>> triangle) {
    return dfs(triangle, 0, 0);
}

private int dfs(List<List<Integer>> triangle, int index, int j) {
    if (index == triangle.size() - 1) {
        return triangle.get(index).get(j);
    }
    int path1 = dfs(triangle, index + 1, j);
    int path2 = dfs(triangle, index + 1, j + 1);
    return Math.min(path1, path2) + triangle.get(index).get(j);
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220213164852659.png)

毫无疑问也是超时，接下来用记忆化搜索优化



**记忆化搜索**

```java
// 记忆化搜索
private int[][] memory;

public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    memory = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 数据范围 -10^4 <= triangle[i][j] <= 10^4
            memory[i][j] = Integer.MIN_VALUE;
        }
    }
    return dfs(triangle, 0, 0);
}

private int dfs(List<List<Integer>> triangle, int index, int j) {
    if (index == triangle.size() - 1) {
        return triangle.get(index).get(j);
    }
    if (memory[index][j] == Integer.MIN_VALUE) {
        int path1 = dfs(triangle, index + 1, j);
        int path2 = dfs(triangle, index + 1, j + 1);
        memory[index][j] = Math.min(path1, path2) + triangle.get(index).get(j);
    }
    return memory[index][j];
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220213170040073.png)



**动态规划**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/007S8ZIlgy1ggqa51dsbdj319w0q840q.jpg)

```java
// 4 动态规划
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    // 使用一维数组是只要求顶点一个位置的最小路径，只要底部拿到数据累加覆盖就行
    // 设置成n + 1是为了防止当j为一层的最后一个时，j + 1越界
    int[] dp = new int[n + 1];
    for (int i = n - 1; i >= 0; i--) {
        // j是小于等于i 因为i是对应的索引
        for (int j = 0; j <= i; j++) {
            // 有个隐含的点是 数组new出来后初始化都为0 所以最底层的局部最小就是0+0+本身
            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
        }
        System.out.println("第" + i + "层 " + Arrays.toString(dp));
    }
    return dp[0];
}
```

打印的结果

```java
第3层 [4, 1, 8, 3, 0]
第2层 [7, 6, 10, 3, 0]
第1层 [9, 10, 10, 3, 0]
第0层 [11, 10, 10, 3, 0]
```





### 最小路径和

#### 题目描述

[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/minpath.jpg)

**数据范围：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

#### 题解



**回溯**

练练回溯的思路，但是题目给的数据范围使用回溯肯定是超时或超内存

回溯法的优势是可以求出所有的路径

```java
private int[][] directs = new int[][]{{0, 1}, {1, 0}};
private int m;
private int n;
private int path = 0;
private List<Integer> paths = new ArrayList<>();
public int minPathSum(int[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    // 先把左顶点加进去
    path += grid[0][0];
    backTracking(grid, 0, 0);
    // 将所求的所有路径和排序
    Collections.sort(paths);
    return paths.get(0);
}

private void backTracking(int[][] grid, int x, int y) {
    // 终止条件 到达右下顶点 因为是path已经先加的值的再dfs 所以位于[m - 1][n - 1]位置时已经添加了该位置
    if (x == m - 1 && y == n - 1) {
        paths.add(path);
        return;
    }
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY)) {
            path += grid[newX][newY];
            backTracking(grid, newX, newY);
            path -= grid[newX][newY];
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**动态规划**

题目中给出了 `grid[i][j]` 非负整数，可以保证走得越长，sum 的值越大；**只能向右走或者向下走**，即为单调性，保证了在非负整数矩阵的情况下，**sum 的最小值存在**。



因为题目说明移动**只能从下或往右走**，所以对于每个位置来说，只能从上或左边到达

- 对于i = 0的位置（上边界），每个位置只能从左边到达

- 对于j = 0的位置（左边界），每个位置只能从上边到达
- 其他位置（里面的位置），每个位置可以从上或左边到达，只要选最短路径和最短的前一个位置加上本身

我们在每次移动时，都**记录下起点(0,0)到该位置的最短路径**

只需要用一个一维长度为n的滚动数组即可

```java
// 动态规划
public int minPathSum1(int[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    int m = grid.length;
    int n = grid[0].length;
    // 空间优化，只用一维 只记录一层，下一层的直接覆盖上一层就行
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 && j == 0) {
                // 先加入起点
                dp[0] = grid[0][0];
            } else if (i == 0) {
                // 上边界,只能从左边来
                dp[j] = dp[j - 1] + grid[0][j];
            } else if (j == 0) {
                // 左边界,只能从上边来 j是相等的 dp[j]是上一层的记录，现在要刷新
                dp[j] = dp[j] + grid[i][0];
            } else {
                // 其他位置，可以从从上或左边到，选取最小的
                dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
            }
        }
    }
    return dp[n - 1];
}
```

也可以不用dp数组，直接在原数组上操作



### 整数拆分

#### 题目描述

[LeetCode343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)



#### 题解

**最优子结构**

通过其子问题的最优解，可以获得原问题的最优解

所以对于递归问题应该同时满足**重叠子问题**和**最优子结构**两种性质的情况下，才可以用**记忆化搜索**和**动态规划**来解决



**回溯**

画出递归树

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220214230447448.png)

```java
// 回溯
public int integerBreak(int n) {
    return backTracking(n);
}

// 将n分割 至少分割两部分
private int backTracking(int n) {
    if (n == 1) {
        return 1;
    }
    // 用res来记录分割n产生的乘积的最大值 不断更新
    // 因为最小分割成两个且n为大于等于2的正整数 所以res初始值只要小于等于1都可以
    int res = 0;
    for (int i = 1; i < n; i++) {
        // 注意这里是取3个值比较，一个是之前的res，另一个是子问题产生的乘积的最大值，最容易漏的一个就是当前的分割方案的值i * (n - i)，
        // 因为有可能当前方案就是最优解
        res = max3(res, i * (n - i), i * backTracking(n - i));
    }
    return res;
}

private int max3(int num1, int num2, int num3) {
    return Math.max(Math.max(num1, num2), num3);
}
```



**记忆化搜索**

```java
// 记忆化搜索
private int[] memory;

public int integerBreak(int n) {
    // 加一个偏移量 方便理解  memory[1]表示的就是分割1的最优解
    memory = new int[n + 1];
    for (int i = 0; i < n + 1; i++) {
        memory[i] = -1;
    }
    memory[0] = 0;
    memory[1] = 1;

    return backTracking(n);
}

private int backTracking(int n) {
    if (n == 1) {
        return 1;
    }
    int res = 0;
    if (memory[n] == -1) {
        for (int i = 1; i < n; i++) {
            res = max3(res, i * (n - i), i * backTracking(n - i));
        }
        memory[n] = res;
    }
    return memory[n];
}
```



**动态规划**

可以发现递归树里存在相同的子问题

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220214230550280.png)

```java
// 动态规划
public int integerBreak(int n) {
    // 加一个偏移量 方便理解  dp[1]表示的就是分割1的最优解
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        // 求解dp[i]
        int res = 0;
        for (int j = 1; j < i; j++) {
            res = max3(res, j * (i - j), j * dp[i - j]);
        }
        dp[i] = res;
    }
    return dp[n];
}

private int max3(int num1, int num2, int num3) {
    return Math.max(Math.max(num1, num2), num3);
}
```



### 完全平方数

#### 题目描述

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)



#### 题解

贪心算法为什么不行？

假设贪心策略：**先将比所求数小的最大平方数加入结果中**

反例

12 = 9 + 1 + 1 + 1

12 = 4 + 4 + 4



递归结构



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220217002218747.png)





![image-20220216234807478](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220216234807478.png)

**动态规划**

```java
/**
 * 拉格朗日四平方和定理
 * 拉格朗日四平方和定理说明任何一个数，都可以由小于等于4个的完全平方数相加得到。
 * 所以dp值可以初始化为4
 *
 * @param n
 * @return
 */
// 完全背包
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    for (int i = 1; i < n + 1; i++) {
        dp[i] = Integer.MAX_VALUE;
    }

    for (int i = 1; i <= n; i++) {
        int res = Integer.MAX_VALUE;
        for (int j = 1; j * j <= i; j++) {
            // 这里的1 + dp[i - j * j]用自顶向下更容易理解一些 因为可以拆出一个j*j的平方数所以得加1
            // 拆出一个平方数后 剩余的数是i - j * j，必然小于等于当前的i 这个之前已经求过了
            res = Math.min(res, 1 + dp[i - j * j]);
        }
        dp[i] = res;
    }
    return dp[n];
}
```



**BFS**

这题可以转化成多叉树的广度优先遍历，依然是这个递归图

问题转化成，求按照完全平方数和凑成 target 的最短路径，也就是第一个结点值为0的那条路径的深度 - 1



![image-20220216234807478](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220216234807478.png)

```java
// BFS
public int numSquares1(int n) {
    // visited数组用来剪枝 避免重复访问相同值的结点
    boolean[] visited = new boolean[n + 1];
    Queue<Integer> queue = new ArrayDeque<>();
    queue.offer(n);
    visited[n] = true;
    int depth = 0;
    while (!queue.isEmpty()) {
        int levelCount = queue.size();
        depth++;
        // 多叉数的BFS
        for (int i = 0; i < levelCount; i++) {
            int cur = queue.poll();
            // 访问当前节点的子节点，类比于二叉树的左右子节点 这里是多叉树
            for (int j = 1; j * j <= cur; j++) {
                int next = cur - j * j;
                if (next == 0) {
                    return depth;
                }
                // next的值未被访问才考虑这条路径，
                // 因为如果这个值之前已经被访问过，说明之前有更短的路径达到这个值，那么当前这个比它长的路径就没有必要尝试下去了
                if (!visited[next]) {
                    queue.offer(next);
                    visited[next] = true;
                }
            }
        }
    }
    // 这个问题必有解因为n可以被n个1相加 正常情况是不会走到这里的 必然能在BFS中找到解
    throw new IllegalArgumentException();
}
```



### 解码方法

#### 题目描述

[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)



#### 题解

这题与爬楼梯很类似



对于字符串 s 的某个位置 i 而言，我们只关心**位置 i 自己能否形成合法独立编码**和**位置 i 能够与上一位置（i-1）能否形成合法的编码**，而不关心 i-1 之前的位置。

因为合法编码为0~26，最多只有两位

对于字符串 s 的任意位置 i 而言，其存在三种情况：

- 只能由位置 i 的单独作为一个独立合法编码，设为one，转移的前提是one的数值范围为 [1,9][1,9]，转移逻辑为 `f[i] = f[i - 1]`。
- 只能由位置 i 的与前一位置（i-1）共同作为一个合法编码，设为two，转移的前提是two的数值范围为 [10,26][10,26]，转移逻辑为 `f[i] = f[i - 2]`(i位置为0的情况，比如10只能由两个位置作为一个合法编码)。
- 位置 i 既能作为独立合法编码也能与上一位置形成合法编码，转移逻辑为` f[i] = f[i - 1] + f[i - 2]`。
  因此，我们有如下转移方程：

$$
\begin{cases} f[i] = f[i - 1], 1 \leqslant a \leq 9 \\ f[i] = f[i - 2], 10 \leqslant b \leqslant 26 \\ f[i] = f[i - 1] + f[i - 2], 1 \leqslant a \leq 9, 10 \leqslant b \leqslant 26 \\ \end{cases}
$$

我们用dp[i]来表示前i个字符可以解码回去的字符串个数，对于字符串的最后一个字符要么对应一个数字要么对应两个数字，所以是加法

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int n = s.length();
    // 这里加了个空格 配合循环从1开始可以简化越界[i - 2]的处理
    char[] str = (" " + s).toCharArray();
    int[] dp = new int[n + 1];
    Arrays.fill(dp,0);
    // 对于dp[0]设置成1 与爬楼梯一样 递推的边界
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        int one = str[i] - '0';
        int two = (str[i - 1] - '0')* 10 + one;
        if (one >= 1 && one <= 9) {
            dp[i] = dp[i] + dp[i - 1];
        }
        if (two >= 10 && two <= 26) {
            dp[i] = dp[i] + dp[i - 2];
        }
    }
    return dp[n];
}
```







### 不同路径

#### 题目描述

[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)



#### 题解

**回溯**

现在回溯倒是写得很顺畅，动态规划还是不熟

```java
// 超时
private int[][] directs = new int[][]{{1, 0}, {0, 1}};
private int m;
private int n;
private int path = 0;

public int uniquePaths(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    this.m = m;
    this.n = n;
    backTracking(0, 0);
    return path;
}

private void backTracking(int x, int y) {
    if (x == m - 1 && y == n - 1) {
        path++;
        return;
    }
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY)) {
            backTracking(newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**动态规划**

这题跟最小路径和一模一样

由于机器人只能往下或往右走，所以对于每一个位置来说，机器人只能从该位置的左边或上边到达

```java
// 动态规划
public int uniquePaths(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    // 只需要用一个一维长度为n的滚动数组
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 分状态讨论即可
            // 对于边界位置来说 由于机器人只能往下或往右走，所以只有一种走法，下面前三种可以简化一条语句
            if (i == 0 && j == 0) {
                dp[j] = 1;
            } else if (i == 0) {
                dp[j] = 1;
            } else if (j == 0) {
                dp[j] = 1;
            } else {
                // 对于里面的位置 只能从该位置的左边或上边 分类用加法
                dp[j] = dp[j] + dp[j - 1];
            }

        }
    }
    return dp[n - 1];
}
```



添加哨兵，简化边界，代码可以简洁很多

```java
// 动态规划 添加哨兵 简化边界处理
public int uniquePaths3(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    int[] dp = new int[n];
    // dp[0] 概括了j = 0的边界，并且dp[j]初始化为0 i = 0时 dp[j] = dp[j] + dp[j - 1] = 0;
    dp[0] = 1;
    for (int i = 0; i < m; i++) {
        // 从第一行第二个开始
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j] + dp[j - 1];
        }
    }
    return dp[n - 1];
}
```



### 不同路径 II

#### 题目描述

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

#### 题解

注意这里的边界处理

dp[0] = 1 然后j从1开始遍历这样做是不行的，不同于上一题没有障碍物，所以对于j=0的情况只有一条路可以走，但是这题出现在j = 0的位置存在障碍物的话，那么dp[0] 就等于0，所以是不能这么设置的

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220218235857697.png)

所以我们要对j从0开始遍历，这就又会出现一个问题，因为第二个状态转移方程为`dp[j] = dp[j] + dp[j - 1]   `，就会出现越界的情况，为了简化边界我们将所有状态方程的dp数组的索引都往后挪一位，变成`dp[j + 1] = dp[j + 1] + dp[j]   `和`dp[j + 1] = 0   `

```java
// 动态规划
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if (obstacleGrid == null || obstacleGrid.length == 0) {
        return 0;
    }
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[] dp = new int[n + 1];
    // 哨兵 简化边界
    // 注意这里为什么不能用dp[0] = 1 然后j从1开始遍历
    dp[1] = 1;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 到达障碍物的路径为0条
            if (obstacleGrid[i][j] == 1) {
                dp[j + 1] = 0;
            } else {
                dp[j + 1] = dp[j + 1] + dp[j];
            }
        }
    }
    return dp[n];
}
```



### 打家劫舍

#### 题目描述

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)



#### 题解

![image-20220220154213324](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220220154213324.png)

**回溯**

计算出所有盗窃方案，选取最大值

```java
// 回溯 超时
private List<Integer> res = new ArrayList<>();
private int path;

public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    backTracking(nums, 0);
    Collections.sort(res);
    return res.get(res.size() - 1);
}

private void backTracking(int[] nums, int index) {
    if (index >= nums.length) {
        res.add(path);
        return;
    }
    for (int i = index; i < nums.length; i++) {
        path += nums[i];
        // 注意传的是i + 2 而不是index + 2
        backTracking(nums, i + 2);
        path -= nums[i];
    }
}
```



**记忆化搜索**

从上面的递归树中可以看出，该问题属于最优子结构且存在重复子问题，所以可以用记忆化搜索和动态规划来解决

```java
// 记忆化搜索
private int[] memory;
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    memory = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        memory[i] = -1;
    }
    return backTracking(nums, 0);
}
private int backTracking(int[] nums, int index) {
    if (index >= nums.length) {
        return 0;
    }
    if (memory[index] == -1) {
        int res = 0;
        for (int i = index; i < nums.length; i++) {
            res = Math.max(res, nums[i] + backTracking(nums, i + 2));
        }
        memory[index] = res;
    }
    return memory[index];
}
```



**动态规划**

定义状态：**考虑偷取[x...n - 1]范围里的房子**

得出状态转移方程

```java
f(0) = max{ v(0) + f(0 + 2), v(1) + f(1 + 2), v(2) + f(2 + 2), ..., v(n - 3) + f(n - 3 + 2), v(n - 2), v(n - 1)}
```

```java
// 动态规划
// 转移方程f(0) = max{ v(0) + f(0 + 2), v(1) + f(1 + 2), v(2) + f(2 + 2), ..., v(n - 3) + f(n - 3 + 2), v(n - 2), v(n - 1)}
// 自底向上就是上面方程的从右到左
public int rob3(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int[] dp = new int[n];
    // 最基础的子问题考虑抢劫[n - 1, n - 1]只有一个房子
    dp[n - 1] = nums[n - 1];
    // 自底向上
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            // 注意索引越界
            dp[i] = Math.max(dp[i], nums[j] + (j + 2 < n ? dp[j + 2] : 0));
        }
    }
    return dp[0];
}
```



还有另一种状态的定义方式：**考虑偷取[0 ... x]的房子**，时间复制度可以降到O(N)

那么对于每个x只有两个状态，偷和不偷

可以推出状态转移方程：

```java
取房子x：dp[i] = dp[i - 1]
不偷取房子x：dp[i] = dp[i - 2] + nums[i]
```

```java
public int rob4(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    // 防越界
    if (nums.length == 1) {
        return nums[0];
    }
    int n = nums.length;
    int[] dp = new int[n];
    // 最基础的子问题
    dp[0] = nums[0];
    dp[1] = Math.max(dp[0],nums[1]);
    for (int i = 2; i < n; i++){
        // 对于房子i 在偷与不偷中选择一个最大值
        dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);
    }
    return dp[n - 1];
}
```



### 打家劫舍 II

#### 题目描述

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)



#### 题解

相比打家劫舍1的单排列，这题的区别是一个环状排列，其实本质是一样的，分类讨论就可以转换成打家劫舍1，取金额最大的一类

- 选择了偷窃第一个房子，就**不能选**最后一间房子
- 没有选择偷窃第一个房子，就**可以选择**最后一间房子(不一定选)

那就是可以定义两个状态

- 状态一：**考虑偷取[0 ... n - 2]的房子**
- 状态二：**考虑偷取[1 ... n - 1]的房子**

状态转移方程跟上一题的一样

```java
取房子x：dp[i] = dp[i - 1]
不偷取房子x：dp[i] = dp[i - 2] + nums[i]
```

```java
// 这类的判断不能放在fun方法里，否则样例只有一个元素时，数组复制都为空，答案错误
    if (nums == null || nums.length == 0) {
        return 0;
    }
    if (nums.length == 1) {
        return nums[0];
    }
    // 因为数组复制的原因 所以要保证原数组要大于等于3个元素，或者对dp数组进行偏移也可以
    if (nums.length == 2) {
        return Math.max(nums[0], nums[1]);
    }
    // 分两类转化成打家劫舍1 取最大值
    int[] nums1 = Arrays.copyOfRange(nums,0,nums.length - 1);
    int[] nums2 = Arrays.copyOfRange(nums, 1,nums.length);
    return Math.max(fun(nums1),fun(nums2));
}
// 动态规划 打家劫舍1的方法
private int fun(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    dp[0] = nums[0];
    dp[1] = Math.max(dp[0],nums[1]);
    for (int i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i - 1],dp[i - 2] + nums[i]);
    }
    return dp[n - 1];
}
```



### 打家劫舍 III

树形dp问题

[点击跳转](#house-robber-iii)





## 背包问题

关于背包问题，如果是ACM模式自己控制输入的话，**最好输入从1开始**，就可以避免对物品0的特殊处理



### 0 - 1背包

#### 题目描述

[AcWing2. 01背包问题](https://www.acwing.com/problem/content/description/2/)

有 `N` 件物品和一个容量是 `C` 的背包。**每件物品只能使用一次**。

每一件物品的重量是 `w(i)`，价值是 `v(i)`。

求解将哪些物品装入背包，使得不超过背包容量的基础上，物品总价值最大。



#### 题解

贪心算法解决0 - 1背包为什么不对

按平均价值顺序放入背包：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220221231446899.png)

不按平均价值顺序放入背包：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220221231633901.png)

结果显而易见，我们举出了贪心算法的一个反例

**状态定义：**

`F(n, C)`：考虑将n个物品放入容量为C的背包的最大价值

**状态转移：**

`F(i, c) = max(F(i - 1, c), v(i) + F(i - 1, c - w(i)))`



**DFS**

其实状态转移方程本来就是自顶向下的方法，先用自顶向下看待问题

```java
public int bestValue(int[] w, int[] v, int C) {
    int n = w.length;
    return dfs(w, v, n - 1, C);
}

private int dfs(int[] w, int[] v, int index, int c) {
    if (index < 0 || c <= 0) {
        return 0;
    }
    // 对于索引为index的物品，不放入背包中
    int res = dfs(w, v, index - 1, c);
    // 对于索引为index的物品，背包容量充足 放入背包中
    if (w[index] <= c) {
        // 两种策略取最值
        res = Math.max(res, v[index] + dfs(w, v, index - 1, c - w[index]));
    }
    return res;
}
```



**记忆化搜索**

存在重叠子问题和最优子结构，重叠子问题来源于`index`和`c`构成的数据对，在整个的求解的过程中存在重复的数据对，因为背包问题是有两个约束条件，所以开辟二维数组来记忆化

```java
// 记忆化搜索
private int[][] memory;
public int bestValue(int[] w, int[] v, int C) {
    int n = w.length;
    // 一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    memory = new int[n][C + 1];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= C; j++) {
            memory[i][j] = -1;
        }
    }
    return dfs(w, v, n - 1, C);
}

private int dfs(int[] w, int[] v, int index, int c) {
    if (index < 0 || c <= 0) {
        return 0;
    }
    if (memory[index][c] == -1) {
        // 对于索引为index的物品，不放入背包中
        int res = dfs(w, v, index - 1, c);
        // 对于索引为index的物品，背包容量充足 放入背包中
        if (w[index] <= c) {
            // 两种策略取最值
            res = Math.max(res, v[index] + dfs(w, v, index - 1, c - w[index]));
        }
        memory[index][c] = res;
    }
    return memory[index][c];
}
```



**动态规划**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222174325641.png)

```java
public int bestValue(int[] w, int[] v, int C) {
    if (w == null || w.length == 0) {
        return 0;
    }
    int n = w.length;
    // dp数组：所持最大价值，一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    int[][] dp = new int[n][C + 1];
    // 最基础的问题 对于0这个物品
    for (int j = 0; j <= C; j++) {
        dp[0][j] = (w[0] <= j ? v[0] : 0);
    }
    // 考虑[1,n)个物品
    for (int i = 1; i < n; i++) {
        // 背包容量为j
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            dp[i][j] = dp[i - 1][j];
            if (w[i] <= j) {
                // 放入背包
                dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - 1][j - w[i]]);
            }
        }
    }
    return dp[n - 1][C];
}
```



**动态规划的空间优化**

根据转移方程`F(i, c) = max(F(i - 1, c), v(i) + F(c - w(i)))`可知第`i`行元素只依赖第`i- 1`行元素，所以理论上只需要维持两行元素

空间复杂度：`O(n * C) ==> O(2C)  `

```java
// 空间优化
public int bestValue4(int[] w, int[] v, int C) {
    if (w == null || w.length == 0) {
        return 0;
    }
    int n = w.length;
    // dp数组：所持最大价值，一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    int[][] dp = new int[2][C + 1];
    // 最基础的问题 对于0这个物品
    for (int j = 0; j <= C; j++) {
        dp[0][j] = (w[0] <= j ? v[0] : 0);
    }
    // 考虑[1,n)个物品
    for (int i = 1; i < n; i++) {
        // 背包容量为j
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            // 使用余数 只使用两行
            dp[i % 2][j] = dp[(i - 1) % 2][j];
            if (w[i] <= j) {
                // 放入背包
                dp[i % 2][j] = Math.max(dp[i % 2][j], v[i] + dp[(i - 1) % 2][j - w[i]]);
            }
        }
    }
    return dp[(n - 1) % 2][C];
}
```



**动态规划进一步空间优化**

直接使用一维dp数组

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222212506866.png)

每次更新下一行的`dp[i][j]`时，我们永远只会使用`dp[i][j]`上面的元素及上一行左边的元素，永远不会使用上一行右边的元素，这就提示我们如果只使用一维dp数组的话，我们可以**从右向左**刷新元素

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222213003360.png)

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220222213236130.png)

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220223221114105.png)

我们可以看到使用一维数组从右向左更新，还可以提前结束

```java
// O(C)空间复杂度 代码更加简洁
public int bestValue5(int[] w, int[] v, int C) {
    if (w == null || w.length == 0) {
        return 0;
    }
    int n = w.length;
    // dp数组：所持最大价值，一维表示考虑[0 - n)个物品可以放入 二维表示当前背包容量 加一个偏移量便于理解
    int[] dp = new int[C + 1];
    // 最基础的问题 对于0这个物品
    for (int j = 0; j <= C; j++) {
        dp[j] = (w[0] <= j ? v[0] : 0);
    }
    // 考虑[1,n)个物品
    for (int i = 1; i < n; i++) {
        // 背包容量为j 从右到左更新
        for (int j = C; j >= w[i]; j--) {
            // 不放入背包:dp[j] 放入背包：v[i] + dp[j - w[i]]
            dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
        }
    }
    return dp[C];
}
```

ACM 模式

```java
import java.util.Scanner;

public class Test {
    static int n;
    static int C;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int[] w = new int[n];
        int[] v = new int[n];
        int[] dp = new int[C + 1];
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }

        for (int i = 0; i < n; i++) {
            for (int j = C; j >= w[i]; j--) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
        System.out.println(dp[C]);
    }
}
```



### 完全背包

#### 题目描述

[AcWing3. 完全背包问题](https://www.acwing.com/problem/content/description/3/)

有 `N` 件物品和一个容量是 `C` 的背包。**每件物品可以无限使用**。

每一件物品的重量是 `w(i)`，价值是 `v(i)`。

求解将哪些物品装入背包，使得不超过背包容量的基础上，物品总价值最大。



#### 题解



**朴素解法**

对于每个dp[i, j]的来源：第 i 个物品有 k 种选法，可以选1个i物品，可以选两个i物品...

![image-20220327211424210](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327211424210.png)

```java
import java.util.*;

public class Test {
    static int n;
    static int C;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int[] w = new int[n];
        int[] v = new int[n];
        int[][] dp = new int[n][C + 1];
        
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }
        // 注意考虑物品0的时候要将所有值都填正确
        for (int j = 1; j <= C; j++) {
            dp[0][j] = dp[0][j - 1];
            if (j % w[0] == 0) {
                dp[0][j] = (j / w[0]) * v[0];
            }
        }
        // 朴素的完全背包
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= C; j++) {
                for (int k = 0; k * w[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], k * v[i] + dp[i - 1][j - k * w[i]]);
                }
            }
        }
        
        System.out.println(dp[n - 1][C]);
    }
}
```



完全背包二维公式推导：
朴素的状态转移：

```
f(i,j) = Max(f(i-1,j), v + f(i-1,j-w), 2v + f(i-1, j-2w)), 3v + f(i-1, j-3w), ... k*v + f(i-1, j-k*w))
```

那么将`j = j-w`代入上式有

```
f(i,j-w) = Max(f(i-1,j-w), v + f(i-1,j-2w), 2v + f(i-1, j-3w)), 3v + f(i-1, j-4w), ... (k-1)*v + f(i-1, j-k*w))
```

因为k是取不完的，所有我们可以将两式对齐吗，所以可以将`f(i,j-w)`+`v`代替朴素公式后面的项

```
f(i,j) = Max(f(i-1,j), v + f(i,j-w))
```

此时`f(i,j)`只依赖两项，从而由三维降到二维



**状态定义：**

`F(n, C)`：考虑将n个物品放入容量为C的背包的最大价值

**状态转移：**

`F(i, c) = max(F(i - 1, c), v(i) + F(i, c - w(i)))`

> 注意：完全背包与01背包的区别就是在转移方程这里，放入背包的转移方程为`v(i) + F(i, c - w(i))`，而不是`v(i) + F(i - 1, c - w(i))`，为什么不是`i - 1`，因为对于前`i`件物品，背包容量为`c - w[i]`时可能已经放入了第`i`件物品，而每件物品是可以放入无限次的，所以容量为`c`时还可以放入第i件物品，所以用`f[i][j - w(i)]`来更新`f[i][j]`

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220223223021946.png)

而且可以看到，对于同一行来说每个不同容量的背包更新的跨度为`v(i)`，`f[j]`的更新依赖的是同一行的新值`f[j - w(i)]`和上一行的旧值`f[j]`，所以在空间优化时使用顺序更新，如果逆序更新的话`f[j]`的更新拿到的是旧值`f[j - w(i)]`

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220223234350891.png)

```java
// 动态规划 空间复杂度O(n * C)
public int bestValue(int[] w, int[] v, int C) {
    int n = w.length;
    int dp[][] = new int[n][C + 1];
	// 对于第一行的初始化二维不能放进下面的循环里 因为第一维依赖于i - 1不能从0开始
    for (int j = 0; j <= C; j++) {
        dp[0][j] = dp[0][j - 1];
        if (j % w[0] == 0) {
            dp[0][j] = (j / w[0]) * v[0];
        }
    }

    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            dp[i][j] = dp[i - 1][j];
            if (w[i] <= j) {
                // 放入背包 两种策略取最优值
                dp[i][j] = Math.max(dp[i][j], v[i] + dp[i][j - w[i]]);
            }
        }
    }
    return dp[n - 1][C];
}
```

**空间优化**

```java
// 空间优化
public int bestValue2(int[] w, int[] v, int C) {
    int n = w.length;
    int dp[] = new int[C + 1];
	// 对于第一行的初始化也可以放进下面的循环里 i从0开始
    for (int j = 0; j <= C; j++) {
        dp[j] = (w[0] <= j ? v[0] 
                 : 0);
    }

    /*for (int i = 1; i < n; i++) {
        for (int j = 0; j <= C; j++) {
            // 不放入背包
            dp[j] = dp[j];
            if (w[i] <= j) {
                // 放入背包 两种策略取最优值
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
    }*/

    // 可以省略if判断 背包容量从装得下w[i]的物品开始，前面装不下w[i]的直接使用旧值，不需要更新
    for (int i = 1; i < n; i++) {
        for (int j = w[i]; j <= C; j++) {
            // 两种策略取最优值
            dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
        }
    }
    return dp[C];
}
```



ACM模式

```java
import java.util.*;

public class Test {
    static int n;
    static int C;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int[] w = new int[n];
        int[] v = new int[n];
        int[] dp = new int[C + 1];
        
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
        }

        // 一维
        for (int i = 0; i < n; i++) {
            for (int j = w[i]; j <= C; j++) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
        
        System.out.println(dp[C]);
    }
}
```



### 多重背包

#### 题目描述

[AcWing4. 多重背包问题](https://www.acwing.com/problem/content/description/4/)

有 `N` 件物品和一个容量是 `C` 的背包。**每件物品不止一个，有`num[i]`个**。

每一件物品的重量是 `w(i)`，价值是 `v(i)`。

求解将哪些物品装入背包，使得不超过背包容量的基础上，物品总价值最大。

#### 题解



**朴素版**



其实和完全背包朴素版的状态转移方程一样，第三维都是枚举所有的数量

![image-20220328153816241](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220328153816241.png)

多重背包朴素的状态转移方程：

```
f(i,j) = Max(f(i-1,j), v + f(i-1,j-w), 2v + f(i-1, j-2w)), 3v + f(i-1, j-3w), ... s[i]*v + f(i-1, j-s[i]*w))
```



朴素版

```java
import java.util.*;

public class Test {
    static int n;
    static int C;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        
        int[] w = new int[n + 1];
        int[] v = new int[n + 1];
        int[] s = new int[n + 1];
        int[][] dp = new int[n + 1][C + 1];
        
        for (int i = 1; i <= n; i++) {
            w[i] = sc.nextInt();
            v[i] = sc.nextInt();
            s[i] = sc.nextInt();
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= C; j++) {
                // k小于i件物品的总数量且背包能够装得下
                for (int k = 0; k <= s[i] && k * w[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], k * v[i] + dp[i - 1][j - k * w[i]]);
                }
            }
        }
        
        System.out.println(dp[n][C]);
    }
}
```



**二维优化**

我们能否用完全背包的思路取优化朴素版的多重背包

我们来看一下
朴素的状态转移：

```
f(i,j) = Max(f(i-1,j), v + f(i-1,j-w), 2v + f(i-1, j-2w)), 3v + f(i-1, j-3w), ... s*v + f(i-1, j-s*w))
```

那么将`j = j-w`代入上式有

```
f(i,j-w) = Max(f(i-1,j-w), v + f(i-1,j-2w), 2v + f(i-1, j-3w)), 3v + f(i-1, j-4w), ... s*v + f(i-1, j-(s+1)*w))
```

因为多重背包的s是确定的，我们没办法对齐后面的项，会多出来最后一项

![image-20220328160759763](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220328160759763.png)

我们没有办法通过`f(i,j-w)`的最大值再减去某一项的值而推出剩下项的最大值，最大值是不可以做减法的



所以不能通过完全背包的优化思路来优化多重背包。



**将多重背包通过二进制数组合转化为01背包**

```java
import java.util.*;

public class Test {
    static int n;
    static int C;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        C = sc.nextInt();
        int count = 1;

        // 新物品的数量是 n * ([logSmax] + 1) --> 上取整 n为原不同物品的数量，所以wv的数组只要比它大就行
        int[] w = new int[20 * n];
        int[] v = new int[20 * n];
        int[] dp = new int[C + 1];

        for (int i = 1; i <= n; i++) {
            int W = sc.nextInt();
            int V = sc.nextInt();
            int S = sc.nextInt();
            int k = 1;
            // 按二进制拆分多个物品组合成一个新的物品，我们就可以当每一件组合成的物品都是不一样的，从而转化为01背包求解
            while (k <= S) {
                w[count] = k * W;
                v[count] = k * V;
                S -= k;
                k <<= 1; // 左移一位
                count++;
            }
            // 还有剩余
            if (S > 0) {
                w[count] = S * W;
                v[count] = S * V;
                count++;
            }
        }

        // 组合后新物品的总数量
        n = count;
		// 直接使用空间优化后的01背包套路
        for (int i = 1; i <= n; i++) {
            for (int j = C; j >= w[i]; j--) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }

        System.out.println(dp[C]);
    }
}

```



### 二维费用背包

#### 题目描述

要同时考虑物体的体积和重量两个维度



### 分割等和子集

#### 题目描述

[LeetCode416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)



#### 题解

典型的**01背包问题**，在n个物品中选出一定物品，**填满sum/2的背包**，不牵涉物品的价值，只是将背包填满



**状态定义：**

`F(n, C)`：考虑将n个物品能否填满容量为C的背包（布尔值）

**状态转移：**

如果使用`i - 1`个物品能填满c，那么之后我们就不用选择其他物品，第`i`个物品肯定也能填满c

或者是我们用`i - 1`个物品已经填了`c - w(i)`的容量，那么我们就选择将`nums(i)`放入背包也能填满c

`F(i, c) = F(i - 1, c) || F(i - 1, c - w(i))  `



**DFS**

```java
// dfs超时
public boolean canPartition(int[] nums) {
    if (nums == null || nums.length == 0) {
        return false;
    }
    int n = nums.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
    }
    // 最基本的条件所有子集的和为偶数才能分割
    if (sum % 2 != 0) {
        return false;
    }
    return dfs(nums, n - 1, sum / 2);
}

// 使用nums[0...index]，是否可以完全填充一个容量为c的背包
private boolean dfs(int[] nums, int index, int c) {
    if (c == 0) {
        return true;
    }
    if (index < 0 || c < 0) {
        return false;
    }
    return dfs(nums, index - 1, c)
            || dfs(nums, index - 1, c - nums[index]);
}
```



**记忆化搜索**

```java
// 记忆化搜索
// -1 表示未计算; 1 表示可以填充; 0 表示不可以填充
// memory为什么使用int而不是用boolean，因为当前的状态除了能否填满，还要表示之前是否使用过，所以boolean不够用
private int[][] memory;
public boolean canPartition(int[] nums) {
    if (nums == null || nums.length == 0) {
        return false;
    }
    int n = nums.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
    }
    // 最基本的条件所有子集的和为偶数才能分割
    if (sum % 2 != 0) {
        return false;
    }
    memory = new int[n][sum / 2 + 1];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= sum / 2; j++) {
            memory[i][j] = -1;
        }
    }
    return dfs(nums, n - 1, sum / 2);
}

// 使用nums[0...index]，是否可以完全填充一个容量为c的背包
private boolean dfs(int[] nums, int index, int c) {
    if (c == 0) {
        return true;
    }
    if (index < 0 || c < 0) {
        return false;
    }
    if (memory[index][c] == -1) {
        memory[index][c] = ((dfs(nums, index - 1, c)
                || dfs(nums, index - 1, c - nums[index]))) ? 1 : 0;
    }
    return memory[index][c] == 1;
}
```



**动态规划**

```java
public boolean canPartition3(int[] nums) {
    int n = nums.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
    }
    if (sum % 2 != 0) {
        return false;
    }
    // 在递推的过程中肯定是从小问题去向大问题逐步递推 所以不牵涉到判断某一个值是否被计算过 这里可以使用boolean
    // 因为肯定是没有被计算过的
    int C = sum / 2;
    boolean[] dp = new boolean[C + 1];
    // 初始化 最基础的问题 对于0索引这个物品是否能将容量为j的背包填满
    for(int j = 0; j <= C; j++) {
        dp[j] = (nums[0] == j);
    }

    for (int i = 1; i < n; i++) {
        for (int j = C; j >= nums[i]; j--) {
            // dp[j]能被填满或者dp[j - nums[i]]这个背包加上当前的nums[i]可以被填满
            dp[j] = dp[j] || dp[j - nums[i]];
        }
    }
    return dp[C];
}
```



### 零钱兑换

#### 题目描述

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)



#### 题解

**典型完全背包问题**

物品可以无限使用，将背包(目标和)填满



**状态定义：**

`dp[i]`：凑齐总价值 `i` 需要的最少硬币个数

**状态转移：**

`dp[i] = min(dp[i], 1 + dp[i - coins[i]])`

填满容量为`i`的背包或者可以填满`i  - coin[i]`这个背包再加一个物品`coin[i]`，两种策略去最小值



**DFS**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.png)

```java
// dfs超时
private int res;

public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return -1;
    }
    res = Integer.MAX_VALUE;
    dfs(coins, amount, 0);
    if (res == Integer.MAX_VALUE) {
        return -1;
    }
    return res;
}

private void dfs(int[] coins, int amount, int index) {
    if (amount == 0) {
        // index从0开始 这里的index已经+1所以是正确的
        res = Math.min(res, index);
        return;
    }
    if (amount < 0) {
        // 不能凑出amount res的初始值不会被改变
        return;
    }
    for (int i = 0; i < coins.length; i++) {
        dfs(coins, amount - coins[i], index + 1);
    }
}
```



**记忆化搜索**

```java
// 记忆化搜素
private int[] memory;

public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return -1;
    }
    // 初始化为0
    memory = new int[amount + 1];
    return dfs(coins, amount);
}

private int dfs(int[] coins, int amount) {
    if (amount == 0) {
        // 填满容量为0的背包 不需要放入物品 物品个数为0
        return 0;
    }
    if (amount < 0) {
        // 不能填满容量为amount的背包
        return -1;
    }
    if (memory[amount] == 0) {
        int minCount = Integer.MAX_VALUE;
        for (int i = 0; i < coins.length; i++) {
            // res 为填满容量为amount - coin[i]的最少个数
            int res = dfs(coins, amount - coins[i]);
            if (res != -1 && res + 1 < minCount) {
                // 如果存在解 且res解所需的硬币+1 < minCount 则更新minCount
                // 可以填满amount - coin[i]这个背包 再加上当前的coins[i]这一个物品就能填满amount
                minCount = res + 1;
            }
        }
        memory[amount] = (minCount == Integer.MAX_VALUE ? -1 : minCount);
    }
    return memory[amount];
}
```



**动态规划**

直接上空间优化版

```java
// 动态规划
public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return -1;
    }
    int n = coins.length;
    // 凑齐总价值为j 需要的最少硬币个数
    int[] dp = new int[amount + 1];
    // dp数组初始化为一个不可能达到的最大值
    Arrays.fill(dp, amount + 1);
    // 容量为0的背包 最少放0个硬币
    dp[0] = 0;
    // 对物品从0开始遍历 因为每个物品都是可以重复选择，对于物品0我们也放进去遍历更方便
    for (int i = 0; i < n; i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]);
        }
    }
    return dp[amount] == (amount + 1) ? -1 : dp[amount];
}
```





### 零钱兑换 II

#### 题目描述



#### 题解

这道题和「力扣」第 39 题：[组合总和](https://leetcode-cn.com/problems/combination-sum/) 很像，只不过：

- 第 39 题问的是所有的组合列表，应该使用 **回溯算法** 求解；
- 第 518 题问的是组合有多少种，而不是问具体的解。应该使用 **动态规划** 求解。



这题是一道经典的完全背包问题，但是注意的是单纯完全背包的两个for循环的先后顺序都是可以的。

**但本题就不行了！**

因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间要求没有顺序。

所以纯完全背包是能凑成总和就行，不用管怎么凑的。

本题是求凑出来的方案个数，且每个方案个数是为组合数。

那么本题，两个for循环的先后顺序可就有说法了。

我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

代码如下：

```cpp
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序，代码如下：

```text
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**



**动态规划**

**状态定义：**

`dp[i][j]`：考虑`[0, i]`个物品凑齐总价值 `j` 需要的最少硬币个数

**状态转移：**

`dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]] `

对于每一个物品，都有选与不选两种选择，分类计数使用加法



```java
public int change(int amount, int[] coins) {
    if (coins.length < 1) {
        if (amount == 0) {
            return 1;
        }
        return 0;
    }
    int n = coins.length;
    int[][] dp = new int[n][amount + 1];
    dp[0][0] = 1;
    // 初始化 只考虑物品0 只有背包容量为物品0的倍数时 才能恰好装满 j += coins[0]
    for (int j = coins[0]; j <= amount; j += coins[0]) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= amount; j++) {
            // 不选择将coins[i] 放入背包
            dp[i][j] = dp[i - 1][j];
            if (j - coins[i] >= 0) {
                // 如果背包容量装得下coins[i] 选择放入背包 分类是加法
                dp[i][j] += dp[i][j - coins[i]];
            }
        }
    }
    return dp[n - 1][amount];
}
```



**空间优化**

```java
public int change(int amount, int[] coins) {
    if (coins == null || coins.length == 0) {
        if (amount == 0) {
            return 1;
        }
        return 0;
    }
    int n = coins.length;
    int[] dp = new int[amount + 1];
    // 初始化 只考虑物品0
    dp[0] = 1;
    // 对物品从0开始遍历 因为每个物品都是可以重复选择，对于物品0我们也放进去遍历更方便
    for (int i = 0; i < n; i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] += dp[j - coins[i]];
        }
    }
    return dp[amount];
}
```



### 组合总和 Ⅳ

#### 题目描述

<span id="combination-sum-iv">组合总和 Ⅳ</span>

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

#### 题解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220224220521637.png)





**回溯**

```java
// 回溯超时
private List<Integer> path = new ArrayList<>();
private List<List<Integer>> res = new ArrayList<>();

public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    backTracking(nums, target);
    return res.size();
}

private void backTracking(int[] nums, int target) {
    if (target <= 0) {
        if (target == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        path.add(nums[i]);
        backTracking(nums, target - nums[i]);
        path.remove(path.size() - 1);
    }
}
```



**记忆化搜索**



**状态定义：**

`dp[i]`：所有能凑齐 `i` 的所有排列数

**状态转移：**

`dp[i] = dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... + dp[i - nums[n - 1]]`

并且定义 `dp[0] = 1 `，它表示如果 `nums` 里有一个数恰好等于 `target`，它单独成为 1 种可能。



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/0794281ad38dd4fc9a47b890b27ca14d61d4be41820f36fc7f8fcf09086293ea-image.png)

```java
// 记忆化搜索
private int[] memory;

public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    memory = new int[target + 1];
    for (int i = 0; i <= target; i++) {
        memory[i] = -1;
    }
    return dfs(nums, target);
}

private int dfs(int[] nums, int target) {
    if (target <= 0) {
        // dp[0] = 1
        if (target == 0) {
            return 1;
        }
        return 0;
    }
    if (memory[target] == -1) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res = res + dfs(nums, target - nums[i]);
        }
        memory[target] = res;
    }
    return memory[target];
}
```



**动态规划**

实际意义上这道题不能算作完全背包问题，因为这题跟零钱兑换不同之处是 **对于物品是考虑放入的顺序的**，实际上是一道排列题

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```java
// 动态规划
public int combinationSum42(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] <= i) {
                dp[i] = dp[i] + dp[i - nums[j]];
            }
        }
    }

    return dp[target];
}
```





### 一和零

#### 题目描述

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)



#### 题解



**DFS**

```java
// dfs超时
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0 || (m == 0 && n == 0)) {
        return 0;
    }
    return dfs(strs,0, m, n);
}

private int dfs(String[] strs,int index, int m, int n) {
    if (index == strs.length) {
        return 0;
    }
    char[] str = strs[index].toCharArray();
    int one = 0;
    int zero = 0;
    for (int i = 0; i < str.length; i++) {
        if (str[i] == '0') {
            zero++;
        }
        if (str[i] == '1') {
            one++;
        }
    }
    // 当前str[index] 0 和 1 的个数都不超过m和n才有选与不选两种选择，否则只能不选
    if (m >= zero && n >= one) {
        return Math.max(dfs(strs, index + 1, m, n), 1 + dfs(strs, index + 1, m - zero, n - one));
    } else {
        return dfs(strs, index + 1, m, n);
    }
}
```



**记忆化搜索**

这题实际上就是一个**01背包问题**，m和n两个背包

**状态定义：**

`dp[i][j][k]`：考虑前 `i`件物品至多用`j`个0，`k`个1的`strs`的最大子集的长度

**状态转移：**

`dp[i][j][k] = max(dp[i - 1][j][k], 1 + dp[i - 1][j - zero][k - one])`

```java
// 自顶向下 记忆化搜索
private int[][][] memory;
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0 || (m == 0 && n == 0)) {
        return 0;
    }
    memory = new int[strs.length][m + 1][n + 1];
    for (int i = 0; i < strs.length; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                memory[i][j][k] = -1;
            }
        }
    }
    return dfs(strs,strs.length - 1, m, n);
}

private int dfs(String[] strs, int index, int m, int n) {
    if (index < 0) {
        return 0;
    }
    int zero = 0;
    int one = 0;
    char[] str = strs[index].toCharArray();
    for (int i = 0; i < str.length; i++) {
        if (str[i] == '0') {
            zero++;
        }
        if (str[i] == '1') {
            one++;
        }
    }
    if (memory[index][m][n] == -1) {
        // 当前str[index] 0 和 1 的个数都不超过m和n才有选与不选两种选择，否则只能不选
        if (m >= zero && n >= one) {
            memory[index][m][n] = Math.max(dfs(strs, index - 1, m, n), 1 + dfs(strs, index - 1, m - zero, n - one));
        } else {
            memory[index][m][n] = dfs(strs, index - 1, m, n);
        }
    }
    return memory[index][m][n];
}
```

因为使用三维数组和三重循环，虽然能通过效率不是很高



**动态规划**

```java
// 三维数组动态规划
public int findMaxForm(String[] strs, int m, int n) {
    int len = strs.length;
    int[][] strInfo = new int[len][2];
    // 存储所有字符的01信息
    for (int i = 0; i < len; i++) {
        char[] str = strs[i].toCharArray();
        int zero = 0;
        int one = 0;
        for (int j = 0; j < str.length; j++) {
            if (str[j] == '0') {
                zero++;
            }
            if (str[j] == '1') {
                one++;
            }
        }
        strInfo[i] = new int[] {zero, one};
    }

    int[][][] dp = new int[len][m + 1][n + 1];
    // 初始化dp数组 考虑第一件物品 这个也可以放到下面的循环一起
    for (int j = 0; j <= m; j++)  {
        for (int k = 0; k <= n; k++) {
            if (strInfo[0][0] <= j && strInfo[0][1] <= k) {
                dp[0][j][k] = 1;
            } else {
                dp[0][j][k] = 0;
            }
        }
    }

    for (int i = 1; i < len; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                // 当前strInfo 0 和 1 的个数都不超过m和n才有选与不选两种选择，否则只能不选
                if (strInfo[i][0] <= j && strInfo[i][1] <= k) {
                    dp[i][j][k] = Math.max(dp[i - 1][j][k], 1 + dp[i - 1][j - strInfo[i][0]][k - strInfo[i][1]]);
                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                }
            }
        }
    }
    return dp[len - 1][m][n];
}
```



**动态规划的空间优化**

因为本质上是一道01背包，可以取消物品维度进行空间优化，使用逆序遍历

```java
// 空间优化 取消物品维度
public int findMaxForm(String[] strs, int m, int n) {
    int len = strs.length;
    int[][] strInfo = new int[len][2];
    // 存储所有字符的01信息
    for (int i = 0; i < len; i++) {
        char[] str = strs[i].toCharArray();
        int zero = 0;
        int one = 0;
        for (int j = 0; j < str.length; j++) {
            if (str[j] == '0') {
                zero++;
            }
            if (str[j] == '1') {
                one++;
            }
        }
        strInfo[i] = new int[]{zero, one};
    }

    int[][] dp = new int[m + 1][n + 1];
    // 初始化dp数组 考虑第一件物品 这个也可以放到下面的循环一起
    for (int j = 0; j <= m; j++) {
        for (int k = 0; k <= n; k++) {
            if (strInfo[0][0] <= j && strInfo[0][1] <= k) {
                dp[j][k] = 1;
            } else {
                dp[j][k] = 0;
            }
        }
    }

    for (int i = 1; i < len; i++) {
        // 和01背包的空间优化一样 逆序遍历 可以提前结束 省去了额外的if判断
        for (int j = m; j >= strInfo[i][0]; j--) {
            for (int k = n; k >= strInfo[i][1]; k--) {
                dp[j][k] = Math.max(dp[j][k], 1 + dp[j - strInfo[i][0]][k - strInfo[i][1]]);
            }
        }
    }
    return dp[m][n];
}
```



### 单词拆分

#### 题目描述



#### 题解



**回溯**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/78fd09b2deabeae972809c2795ddb8be96720b8e62377cf01b7f70e7fb3dbf8c-image.png)



```java
// 回溯超时
public boolean wordBreak(String s, List<String> wordDict) {
    if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) {
        return false;
    }
    // 一个技巧将list转化成set，使用contains可以降低时间复杂度到大常数级别
    // 而list本质就是通过数组实现的，查找一个元素是否包含要用到遍历，时间复杂度是O（n）
    Set<String> set = new HashSet<>(wordDict);
    return backTracking(s, set, 0);
}

private boolean backTracking(String s, Set<String> set, int index) {
    if (index >= s.length()) {
        return true;
    }
    for (int i = index; i < s.length(); i++) {
        // 如果wordDict含有[index, i + 1)的子串，则继续对剩余子串做考察
        // 由于subString生成了新的字符串对象，因此不会对原来的字符串产生影响，因此回溯之后不需要做状态重置。
        if (set.contains(s.substring(index, i + 1))) {
            // 如果wordDict不含有剩余子串则回溯到上一层，i递进 继续考察[index, i + 1)
            if (backTracking(s, set, i + 1)) {
                return true;
            }
        }
    }
    return false;
}
```



**记忆化搜搜**

图中数字代表index指针，可以看到递归树中存在大量的重复子问题，所以可以用记忆化数组存储值，索引为index指针

`memory[index] = -1`表示未使用

`memory[index] = 1`表示可以用`wordDict`的元素凑出`s`0-index的子串

`memory[index] = 0`表示可以用`wordDict`的元素不能凑出`s`0-index的子串

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/5cba31457da78b75f3d593ef6f3c64c34e80db00c5e619f7e03affb1d6b829f0-image.png)



```java
private int[] memory;

public boolean wordBreak(String s, List<String> wordDict) {
    if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) {
        return false;
    }
    memory = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        memory[i] = -1;
    }
    Set<String> set = new HashSet<>(wordDict);
    return backTracking(s, set, 0);
}

private boolean backTracking(String s, Set<String> set, int index) {
    if (index >= s.length()) {
        return true;
    }
    if (memory[index] != -1) {
        return memory[index] == 1;
    }
    for (int i = index; i < s.length(); i++) {
        // 如果wordDict含有[index, i + 1)的子串，则继续对剩余子串做考察
        // 由于subString生成了新的字符串对象，因此不会对原来的字符串产生影响，因此回溯之后不需要做状态重置。
        if (set.contains(s.substring(index, i + 1))) {
            // 如果wordDict不含有剩余子串则回溯到上一层，i递进 继续考察[index, i + 1)
            if (backTracking(s, set, i + 1)) {
                memory[index] = 1;
                return true;
            }
        }
    }
    memory[index] = 0;
    return false;
}
```





**动态规划**

完全背包问题，字典可以重复使用，只要求能组合出给定字符串

**状态定义：**

`dp[i]`：表示可以从字典中组合出给定字符串索引为`0 - i`的子串

**状态转移：**

`dp[i] = dp[pre] && wordDict.contain(s.substring(pre, i)  `





![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220227202845068.png)



```java
// 动态规划
public boolean wordBreak(String s, List<String> wordDict) {
    int n = s.length();
    Set<String> set = new HashSet<>(wordDict);
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    // 遍历背包 字符串
    for (int i = 1; i <= n; i++) {
        // 遍历物品 字典
        for (String word : wordDict) {
            int pre = i - word.length();
            if (pre >= 0 && set.contains(s.substring(pre, i)) && dp[pre] == true) {
                dp[i] = true;
                // 只要有一个可以组成就break
                break;
            }
        }
    }
    return dp[n];
}
```





### 目标和

#### 题目描述





#### 题解

**DFS**

由于数据范围较小，dfs可以通过

```java
// dfs
private int count = 0;
public int findTargetSumWays(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    dfs(nums, target, 0);
    return count;
}

private void dfs(int[] nums, int target, int index) {
    if (index == nums.length) {
        if (target == 0) {
            this.count++;
        }
        return;
    }
    // 添加负号
    dfs(nums, target - nums[index], index + 1);
    // 添加正号
    dfs(nums, target + nums[index], index + 1);
}
```



**记忆化搜索**



```java
// 记忆化搜索
// 由于target可能是负权值 所以不能直接使用一维来做缓存
// index和target两个条件限制 用String来表示这两个条件
private Map<String, Integer> memory = new HashMap<>();

public int findTargetSumWays(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    return dfs(nums, target, 0);
}

private int dfs(int[] nums, int target, int index) {
    if (index == nums.length) {
        // 能凑出target 返回一种方案 否则0方案
        if (target == 0) {
            return 1;
        }
        return 0;
    }
    String key = index + "_" + target;
    if (!memory.containsKey(key)) {
        int res = dfs(nums, target - nums[index], index + 1) + dfs(nums, target + nums[index], index + 1);
        memory.put(key, res);
    }
    return memory.get(key);
}
```



**动态规划**

转化为01背包问题，**装满容量为target背包，有几种方法**

**状态定义：**

`dp[i][j]`：考虑前`i`个数，当前计算结果为`j`的方案数

**状态转移：**

`dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j + nums[i - 1]]  `



```java
// 动态规划
public int findTargetSumWays2(int[] nums, int target) {
    int n = nums.length;
    int border = 0;
    for (int i = 0; i < n; i++) {
        border += Math.abs(nums[i]);
    }
    // 如果target 大于边界的话 不存在方案
    if (Math.abs(target) > border) {
        return 0;
    }
    // target的范围只可能在[-border, border]间
    int[][] dp = new int[n + 1][2 * border + 1];
    // 因为target可能存在负权值 为了能够计算负权值 我们将所有dp的索引都做一个border的右偏移
    dp[0][0 + border] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = -border; j <= border; j++) {
            // 两个if保证索引值不为负
            if ((j - nums[i - 1]) + border >= 0) {
                dp[i][j + border] += dp[i - 1][(j - nums[i - 1]) + border];
            }
            if ((j + nums[i - 1]) + border <= 2 * border) {
                dp[i][j + border] += dp[i - 1][(j + nums[i - 1]) + border];
            }
        }
    }
    return dp[n][target + border];
}
```



## 线性 DP



### 数字三角形

#### 题目描述

[AcWing898. 数字三角形](https://www.acwing.com/problem/content/description/900/)



#### 题解

![image-20220329162444629](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329162444629.png)

**自底向上**

```java
import java.util.Scanner;

public class Test {
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] triangle = new int[2 * n][2 * n];
        int[][] dp = new int[2 * n][2 * n];
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                triangle[i][j] = sc.nextInt();
            }
        }
        
        // 自底向上
        for (int i = n; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
            }
        }
        
        System.out.println(dp[1][1]);
    }
}
```



**空间优化**

```java
import java.util.Scanner;

public class Test {
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] triangle = new int[2 * n][2 * n];
        int[] dp = new int[2 * n];
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                triangle[i][j] = sc.nextInt();
            }
        }
        
        // 自底向上
        for (int i = n; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                dp[j] = Math.max(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        
        System.out.println(dp[1]);
    }
}
```



### 子序列系列





### 最短编辑距离

#### 题目描述

[AcWing902. 最短编辑距离](https://www.acwing.com/problem/content/description/902/)

给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

1. 删除–将字符串 A 中的某个字符删除。
2. 插入–在字符串 A 的某个位置插入某个字符。
3. 替换–将字符串 A 中的某个字符替换为另一个字符。

现在请你求出，将 A 变为 B 至少需要进行多少次操作。

**输入格式**

第一行包含整数 n，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大小写字母。

**输出格式**

输出一个整数，表示最少操作次数。

**数据范围**

1≤n,m≤1000

**输入样例：**

```
10 
AGTCTGACGC
11 
AGTAAGTAGGC
```

**输出样例：**

```
4
```



#### 题解

**状态定义：**

`dp[i][j]`：长度为`[0,i]`A的子串变为长度为`[0,j]`B的子串的最少操作数

**状态转移：**

A 转化为 B的前一步只有三种方式，就是A 增、删、改一个字符(如果不相等则改)

`dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1], dp[i - 1][j - 1] + 1)`



![image-20220331234056331](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220331234056331.png)

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int m = read.nextInt();
        String text1 = read.next();
        int n = read.nextInt();
        String text2 = read.next();
        int[][] dp = new int[m + 1][n + 1];

        // 初始化
        // text2长度为0 text2只能做i步增加
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        // text1长度为0 text1只能做j步增加
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = Math.min(1 + dp[i][j - 1], 1 + dp[i - 1][j]);
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 如果最后一个字符相等则不用操作
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i][j], 1 + dp[i - 1][j - 1]);
                }
            }
        }

        System.out.println(dp[m][n]);
    }
}
```



### 编辑距离

#### 题目描述

[AcWing899. 编辑距离](https://www.acwing.com/problem/content/description/899/)

给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。

对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。

每个对字符串进行的单个字符的插入、删除或替换算作一次操作。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含一个字符串，表示给定的字符串。

再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。

字符串中只包含小写字母，且长度均不超过 10。

**输出格式**

输出共 m 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。

**数据范围**

1≤n,m≤1000

**输入样例：**

```
3 2
abc
acd
bcd
ab 1
acbd 2
```

**输出样例：**

```
1
3
```



#### 题解

是最短编辑距离的一个应用，**对于每次询问，只需要枚举一下所有字符串的最短编辑距离是否小于给定的上限操作数**即可



```java
import java.util.Scanner;

/**
 * 编辑距离
 *
 * @author novo
 * @date 2022/4/2-15:34
 */
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int m = read.nextInt();
        String[] strings = new String[n];
        for (int i = 0; i < n; i++) {
            strings[i] = read.next();
        }

        // 处理m次询问
        while (m-- > 0) {
            String str = read.next();
            int limit = read.nextInt();
            int res = 0;
            for (int i = 0; i < n; i++) {
                if (minEdit(strings[i], str) <= limit) {
                    res++;
                }
            }
            System.out.println(res);
        }
    }

    // 最短编辑距离
    private static int minEdit(String text1, String text2) {
        int[][] dp = new int[11][11];
        int m = text1.length();
        int n = text2.length();
        // 处理边界初始化
        // text2长度为0 text2只能做i步增加
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        // text1长度为0 text1只能做j步增加
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1);
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 区间 DP

区间 DP 的一般都要先按区间长度枚举，按照区间长度从小到大来枚举，因为要保证在算`f(i,j)`时，它所需要用到的状态在此前已经被计算过





### 石子合并

#### 题目描述

[AcWing282. 石子合并](https://www.acwing.com/problem/content/description/284/)

设有 N 堆石子排成一排，其编号为 1，2，3，…，N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 4 堆石子分别为 1 3 5 2， 我们可以先合并 1、2 堆，代价为 4，得到 4 5 2， 又合并 1，2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；

如果第二步是先合并 2，3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。



#### 题解



**状态定义：**

`dp[i][j]`：考虑区间`[i, j]`合并成一堆石子的所有方式的最小代价

**状态转移：**

`dp[i][j] = min(dp[i][k] + dp[k + 1][j] + (preSum[j] - preSum[i - 1]))，枚举所有分界点k`



![image-20220331170500619](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220331170500619.png)

需要用到**前缀和**来计算合并石子的代价

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n + 1];
        int[] preSum = new int[n + 1];
        int[][] dp = new int[n + 1][n + 1];
        
        for (int i = 1; i <= n; i++) {
            nums[i] = read.nextInt();
            preSum[i] = preSum[i - 1] + nums[i];
        }
        // 要按区间长度枚举  可以从2开始 因为合并一堆石子代价为0 因为dp初始值就为0
        for (int len = 2; len <= n; len++) {
            // 枚举起点
            for (int i = 1; i + len - 1 <= n; i++) {
                int j = i + len - 1;
                // 注意这里 除了一堆石子的区间初始值为0，其他区间（len>=2）的初始值都要设一个最大值，不然都是0
                dp[i][j] = Integer.MAX_VALUE;
                // 枚举分界点
                for (int k = i; k < j; k++) { // k严格小于j 保证存在两堆
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + (preSum[j] - preSum[i - 1]));
                }
            }
        }
        
        System.out.println(dp[1][n]);
    }
}
```



## 计数 DP



### 整数划分

#### 题目描述

[AcWing900. 整数划分](https://www.acwing.com/problem/content/description/900/)

一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数n的一种划分。

现在给定一个正整数n，请你求出n共有多少种不同的划分方法。

**输入格式**
共一行，包含一个整数n。

**输出格式**
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对10^9+7取模。

**数据范围**
1≤n≤1000

**输入样例:**

```
5
```

**输出样例:**

```
7
```

#### 题解

**完全背包解法**

 O(n3)

可以看成完全背包

背包容量为n，物品的重量为1，2，3...n

每种物品可以选无数次

**状态定义：**

`dp[i][j]`：考虑从`[0, i]`的数字中选，恰好凑出`j`的方案数量

**状态转移：**

`f(i,j) = f(i-1,j) + f(i-1,j-i) + f(i-1, j-2i) + f(i-1, j-3i), ...+ f(i-1, j-k*i) `

对于每一个物品，在背包容量充足的情况下，可以分别选 1，2，3...k 次，分类计数使用加法

```java
import java.util.*;
public class Main {
	static final int M = (int) (1e9 + 7);

    // 完全背包朴素解
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] dp = new int[n + 1][n + 1];
        // 凑出0只有一种方案
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k * i <= j; k++) {
                    dp[i][j] = dp[i][j] + dp[i - 1][j - k * i];
                    dp[i][j] = dp[i][j] % M;
                }
            }
        }

        System.out.println(dp[n][n]);
    }
}
```



**空间优化**

二维：

```java
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt();
    int[][] dp = new int[n + 1][n + 1];
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = dp[i - 1][j];
            if (i <= j) {
                dp[i][j] = dp[i][j] + dp[i][j - i];
            }
            dp[i][j] = dp[i][j] % M;
        }
    }
    System.out.println(dp[n][n]);
}
```

一维：

```java
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            dp[j] = dp[j] + dp[j - i];
            dp[j] = dp[j] % M;
        }
    }
    System.out.println(dp[n]);
}
```



**另外一种转移方程**

**状态定义：**

`dp[i][j]`：一共选`j`个数，它们总和恰好凑出`i`的方案数量

**状态转移：**

![image-20220402203238006](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220402203238006.png)

- 使用j个数能够凑成`i`，这j个数中最小值为1的方案中，**去掉一个1**，则状态变为：`f(i,j)=f(i−1,j−1)`
- 使用j个数能够凑成`i`，这j个数中最小值不为1的方案中，**将这j个数都减去一个1**，则状态变为：`f(i,j)=f(i−j,j)`，此时状态表示为`j`个数能够凑成`i-j`的所有方案的数量。（因为最小值都严格大于1，都减去一个1后仍为`j`个数）

`dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j] `

最终答案就枚举一次第二维个数就行

```
res = dp[n][0] + dp[n][1] + dp[n][2] + ... + dp[n][n] 
```



```java
// 另一种转移方程
public static void main(String[] args) {
    Scanner read = new Scanner(System.in);
    int n = read.nextInt();
    int[][] dp = new int[n + 1][n + 1];
    int res = 0;
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        // 凑出n 个数最多的方案最多为 n个1 所以 j <= i
        for (int j = 1; j <= i; j++) {
            dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];
        }
    }

    for (int j = 0; j <= n; j++) {
        res += dp[n][j];
    }

    System.out.println(res);
}
```



## 数位 DP

分类讨论



### 计数问题

#### 题目描述

[AcWing338. 整数划分](https://www.acwing.com/problem/content/description/338/)

给定两个整数 $a$ 和 $b$，求 $a$ 和 $b$ 之间的所有数字中 $0∼9$ 的出现次数。

例如，$a=1024，b=1032$，则 $a$ 和 $b$ 之间共有 $9$ 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 1010 次，`1` 出现 1010 次，`2` 出现 77 次，`3` 出现 33 次等等…

**输入格式**

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 $a$ 和 $b$。

当读入一行为 `0 0` 时，表示输入终止，且该行不作处理。

**输出格式**

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

**数据范围**

$0<a,b<1000000000$

**输入样例：**

```
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

**输出样例：**

```
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```



#### 题解

**前缀和思想**

求区间 $[a, b]$ 内 $x$ 出现的次数，等价于区间 $[1, b]$ 上 $x$ 出现的次数 $-$ $[1, a - 1]$ 上 $x$ 出现的次数。

那么我们只需要实现一个可以求出$[1, n]$ 上 $x$ 出现的次数的方法即可。



**核心函数：**

用数学思维降低时间复杂度

n 用字符串形式来表示$n = abcdefg$ ($abcdefg$ 代表`n`每一位上的数字)，求出`x`在`[1, n]`这个区间的所有正整数每一位上出现的次数

**分类讨论：**

$???x\$\$\$$ 代表`[1, n]`这个区间上的某一个数字

$1 <= ???x\$\$\$ <= abcdefg$



1) 当 $??? \in [000, abc - 1]$ 时，那么 $\$\$\$$ 就可以取任意数$[000, 999]$，因为此时高位 $??? < abc$ ，所以无论低位取何数，$???x\$\$\$$ 都在`[1, n]`内。
2) 当 $??? = abc$ 时，分为三种情况：

- $x > d$ 时，此时高位 $abcx > abcd$，所以无论低位 $\$\$\$$ 取何数，这个数都不在区间内。

- $x = d$ 时，此时前面的高位都相等，只要 $\$\$\$ \in [000, efg]$，这个数就在`[1, n]`内。

- $x < d$ 时，此时高位 $abcx < abcd$，所以低位可以取任意数。 

3) 当 $??? > abc$ 时，此时高位已经大于 n 了，所以这个数不在区间内。



综上所述，我们只需要累加所有区间内数据的情况，就可以求出$[1, n]$内 $x$ 出现的次数 

1) $??? \in [000, abc - 1]$，可取的合法个数就为$abc * 1000$（这里000~999就是1000种，就是x所在位置的10的次方）


2) $??? = abc$
- $x = d$，可取的合法个数 $efg + 1$ (000~efg)
- $x < d$，可取的合法个数 $1000$（这里000~999就是1000种，就是x所在位置的10的次方）



**特殊判断**

1、$??? \in [001, abc - 1]$ 这种情况要 $abc \geq 1$，所以在枚举非最高位时才有这种情况，因为x在最高位置，前面就没有 $abc$ 了

2、当 $ x = 0$ 时，由于不能含有前导零所以 $???$ 要从1开始，$??? \in [001, abc - 1]$ 。可取的合法个数就为 $abc * 1000 - 1$

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @author novo
 * @date 2022/4/3-20:43
 */
public class Main {
    
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        while (read.hasNext()) {
            int a = read.nextInt();
            int b = read.nextInt();
            if (a == 0 && b == 0) {
                break;
            }
            // 确保a 小于 b
            if (a > b) {
                int temp = a;
                a = b;
                b = temp;
            }
            // 前缀和思想 [a, b]上x出现的次数 = [1, b]上x出现的次数 - [1, a - 1]上x出现的次数
            for (int i = 0; i < 10; i++) {
                System.out.print(count(b, i) - count(a - 1, i) + " ");
            }
            System.out.println();
        }
    }

    // 统计1~n这个区间 x出现的次数
    private static int count(int n, int x) {
        if (n == 0) {
            return 0;
        }
        // 存储每一位
        List<Integer> list = new ArrayList<>();
        while (n != 0) {
            list.add(n % 10);
            n /= 10;
        }
        // 对 x == 0 做特判，如果 x == 0 i从次高位开始枚举
        int bit = (x == 0 ? 1 : 0);
        int bitSize = list.size();
        int res = 0;
        // 从高位开始枚举
        for (int i = bitSize - 1 - bit; i >= 0; i--) {
            // base 1 x不为最高位时才有这种情况
            if (i < bitSize - 1) {
                res += (getNum(list, bitSize - 1, i + 1)) * Math.pow(10, i);
                if (x == 0) {
                    // x == 0 时 可取个数为(getNum(list, bitSize - 1, i + 1)) - 1) * Math.pow(10, i)，所以要减回去
                    res -= Math.pow(10, i);
                }
            }

            // base 2.2 x == d
            if (x == list.get(i)) {
                res += getNum(list, i - 1, 0) + 1;
            } else if (x < list.get(i)) {
                // base 2.3 x < d
                res += Math.pow(10, i);
            }
        }
        return res;
    }
    
	// 获取一个数 在l~r位上的数字
    private static int getNum(List<Integer> list, int l, int r) {
        int res = 0;
        for (int i = l; i >= r; i--) {
            res = res * 10 + list.get(i);
        }
        return res;
    }
}
```



**时间复杂度**

数据 $0<a,b<1000000000$ ，所以枚举位时，至多枚举10次，一个数的数位为`lgN`，需要枚举0~9 10个数字出现的次数，也就是一组样例的时间为`O(10 * 2 * lgN)`=`O(lgN)`

再看看如果用暴力枚举来求$[1, n]$ 上 $x$ 出现的次数，时间复杂度为`O(N * lgN)`

> 不得不说，暴力枚举是真的简单，暴力枚举是区间上的数一个一个枚举，而用数位 DP 是一次性算出一个区间上 x 出现的次数

```java
// 统计1~n 内 x出现的次数
private static int forceCount(int n, int x) {
    int res = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = i; j != 0; j /= 10) {
            if (j % 10 == x) {
                res++;
            }
        }
    }
    return res;
}
```



## 状态压缩 DP

一般n不会特别大 n <= 20



### 蒙德里安的梦想

#### 题目描述

[AcWing291. 蒙德里安的梦想](https://www.acwing.com/problem/content/description/293/)

求把 $N×M$ 的棋盘分割成若干个 $1×2$ 的长方形，有多少种方案。

例如当 $N=2，M=4$ 时，共有 55 种方案。当 $N=2，M=3$ 时，共有 $3$ 种方案。

如下图所示：

![2411_1.jpg](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/19_4dd1644c20-2411_1.jpg)

**输入格式**

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 $N$ 和 $M$。

当输入用例 $N=0，M=0$ 时，表示输入终止，且该用例无需处理。

**输出格式**

每个测试用例输出一个结果，每个结果占一行。

**数据范围**

$1≤N,M≤11$

**输入样例：**

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

**输出样例：**

```
1
0
1
2
3
5
144
51205
```

#### 题解



**朴素解**

只要确定了合法的横放的方案数，那么总的方案数就确定了



我们按列枚举，某列的各行用表示摆放状态。

如果某行是1，表示横放，并且向下一列伸出。

如果某行是0，表示竖放或者由前一列伸出。

例：

![image-20220404202720151](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220404202720151.png)



**状态定义：**

$F(i, j)$ ：表示摆放到第 $i$ 列，状态为 $j$ 的方案数

**状态转移：**

$F(i, j) \gets F(i - 1, k)$

例如：

第二列0011的状态可以从0000或1100分别转移过来，$F(2, 3) = 2$

![image-20220404203739695](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220404203739695.png)

将所有能够从$F(i - 1, k)$ 转移到 $F(i, j)$ 状态的方案数累加起来

$F(i, j) =\sum F(i - 1, k)$



**初值：**

$F(0, 0) = 1，其他为0$，表示第 $0$ 列不放矩形是一种合法的方案

**结果：**

$F(m, 0)$ 表示已摆放都 $m$ 列，且第 $m$ 列都没有出现横放，也就是没有向下一列伸出，那么就是刚刚好填充完毕。



**代码：**

预处理判断合并列的合法性

为什么会有不合法的情况呢，比如：

![image-20220404205635736](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220404205635736.png)

情况一，第一列的状态为$1100$ ，第二列的状态为 $0011$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1111$ 是合法的，因为前合并完成的前两列中没有任何空隙。

情况二，第一列的状态为$1100$ ，第二列的状态为 $0000$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1100$ 是合法的，因为前合并完成的前两列中没有任何空隙。

情况三，第一列的状态为$1100$ ，第二列的状态为 $0001$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1101$ 是非法的，因为前合并完成的前两列中有一个空隙。

情况四，第一列的状态为$1100$ ，第二列的状态为 $0010$ ，那么第一列和第二列进行或运算合并之后的状态就为 $1110$ 是非法的，因为前合并完成的前两列中有一个空隙。

从上面的规律我们可以看出，如果合并列的状态中出现连续奇数个 $0$ 那么就是非法的，因为只有偶数个 $0$ 才能被长度为 $1× 2$ 的长方体竖着填充，如果是被前一列伸出的填充的话，合并列的状态是 $1$ 而不是 $0$。所以我们需要先进行预处理，记录出合并列的非法状态。

```java
import java.util.Scanner;

/**
 * 291. 蒙德里安的梦想
 * @author novo
 * @date 2022/4/4-15:58
 */
public class Main {

    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        while (read.hasNext()) {
            int n = read.nextInt();
            int m = read.nextInt();
            if (n == 0 && m == 0) {
                break;
            }

            boolean[] isValid = new boolean[1 << n];
            long[][] dp = new long[m + 1][1 << n];
            dp[0][0] = 1;

            // 预处理 记录合并列中的非法状态
            // 枚举列中所有的状态 比如一共有四行 就要枚举 0000~1111共16个状态
            for (int i = 0; i < (1 << n); i++) {
                isValid[i] = true;
                int zeroNum = 0; // 记录连续0的个数
                // 枚举每一个状态里面的位
                for (int j = 0; j < n; j++) {
                    // 低位开始枚举
                    if ((i >> j & 1) == 1) { // 如果第j位为1
                        // 判断之前是否存在奇数个连续个零
                        if ((zeroNum & 1) == 1) {
                            // 位运算判断奇偶数
                            isValid[i] = false;
                            break;
                        }
                        zeroNum = 0; // 也可以不清零，因为没有break掉说明前面出现的都是偶数个0
                    } else {
                        zeroNum++;
                    }
                }
                // 因为内循环里遇到1时才会进行0的检查，循环如果以高位为0枚举退出时，会漏了高位为0的检查
                if ((zeroNum & 1) == 1) {
                    isValid[i] = false;
                }
            }

            // 状态转移
            // 枚举列
            for (int i = 1; i <= m; i++) {
                // 枚举当前列中的状态
                for (int j = 0; j < (1 << n); j++) {
                    // 枚举前一列的状态
                    for (int k = 0; k < (1 << n); k++) {
                        // 当前列和前一列不能有重叠，且合并列后状态合法，才允许转移
                        if ((j & k) == 0 && isValid[j | k]) {
                            dp[i][j] += dp[i - 1][k];
                            //System.out.println("dp[" + i +" "+ j+"]=" + dp[i][j] + " " + "dp[" + (i-1) +" "+ k+"]=" + dp[i - 1][k]);
                        }
                    }
                }
            }
        }
    }
}

```



### 最短Hamilton路径

#### 题目描述

[AcWing91. 最短Hamilton路径](https://www.acwing.com/problem/content/description/93/)

给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 $Hamilton$ 路径。

$Hamilton$ 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。

**输入格式**

第一行输入整数 $n$。

接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i, j]$）。

对于任意的 $x,y,z$ 数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。

**输出格式**

输出一个整数，表示最短 $Hamilton$ 路径的长度。

**数据范围**

$1≤n≤20$
$0≤a[i,j]≤10^7$

**输入样例：**

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

**输出样例：**

```
18
```



#### 题解

我们用二进制来压缩从结点 $0$ 到 终点 $n - 1$ 路径访问的情况，$1 $ 表示已访问，$0$ 表示未被访问

例如：

假设共有 $ 5 $ 个结点，结点从 $ 0 $ 开始，已访问过的结点集 $\left\{0, 2, 4\right\}$ ，用二进制来表示 $ 10101 $



在终点确定的情况下，我们要求从结点 $0$ 到 终点 $n - 1$ 的最短哈密顿路径，假设终点前一个访问的结点为 $k$ ，那么

$ 0 \rightarrow n - 1$ 这条路径就等价于 $0 \rightarrow k$ 这段路径再加上 $edges[k][n - 1]$ 这段距离即可，而 $edges[k][n - 1]$ 是已知的，那么我们只要枚举所有结点 $k$ 选出 $Min(0 \rightarrow k)$ 即可

**状态定义：**

$F(i, j)$ ：表示路径状态为 $i$ ，起点是 $0$ 终点为 $j$ 的最短哈密顿路径

**状态转移：**

$F(i, j) = Min(F(i - (1 << j), k) + edges[k][j])$



$i - (1 << j)$  的意思是 $i$ 状态除去 $j$ 被访问过的一个状态
例如：
在被访问过的结点集 $\left\{ 0, 3, 5, 6, 9 \right\}$, 假设终点为 $3$
那么从结点 $0$ 到终点 $3$ 这一条最短哈密顿路径只能由，除去终点结点 $ 3 $ 的一个已被访问结点集$\left\{0, 5, 6, 9 \right\}$ 中转化而来，因为在哈密顿路径中一个结点只能被访问一次

从结点 $0$ 到终点 $3$ 这一条最短哈密顿路径为下面路径和中最短的一条：

$0 \rightarrow 5\rightarrow 6\rightarrow 9\rightarrow 3$

$0 \rightarrow 5\rightarrow 9\rightarrow 6\rightarrow 3$

$0 \rightarrow 6\rightarrow 5\rightarrow 9\rightarrow 3$

$0 \rightarrow 6\rightarrow 9\rightarrow 5\rightarrow 3$

$0 \rightarrow 9\rightarrow 5\rightarrow 6\rightarrow 3$

$0 \rightarrow 9\rightarrow 6\rightarrow 5\rightarrow 3$

**代码**

注意枚举的顺序，因为路径状态的转移依赖于前一个路径状态，所以的先枚举路径状态，后枚举终点

```java
import java.util.Arrays;
import java.util.Scanner;

/**
 * 91. 最短Hamilton路径
 *
 * @author novo
 * @date 2022/4/5-14:14
 */
public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[][] edges = new int[n][n];
        // i 是压缩的状态
        int[][] dp = new int[1 << n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                edges[i][j] = read.nextInt();
            }
        }

        // 初始值INF
        for (int i = 0; i < (1 << n); i++) {
            for (int j = 0; j < n; j++) {
                // 只访问过自己结点且终点为自身的最短距离为0 dp[1][0] = dp[2][1] = dp[4][2] ... = 0
                if ((1 << j) == i) {
                    dp[i][j] = 0;
                } else {
                    // 不能取MAX 因为状态转移时有加法会溢出
                    dp[i][j] = (Integer.MAX_VALUE / 2);
                }
            }
        }
        // 因为这题只能从0点出发，所以只设置一个初始值其他设为INF也是可以的
        dp[1][0] = 0;

        // 枚举路径的所有状态
        for (int i = 0; i < (1 << n); i++) {
            // 枚举终点
            for (int j = 0; j < n; j++) {
                // 一种路径状态中的已访问的结点集必须包含终点 这条状态为i 终点为j的路径才合法
                if ((i >> j & 1) == 1) {
                    // 枚举走到j之前 以k为终点的最短距离 也就是前一个状态
                    for (int k = 0; k < n; k++) {
                        if ((i >> k & 1) == 1) {
                            // f(i, j) 由 f(i - {j}, k)转化而来 因为前一个状态要转移到f(i, j)，所以前一个状态j是不能被访问过的
                            dp[i][j] = Math.min(dp[i][j], dp[i - (1 << j)][k] + edges[k][j]);
                        }
                    }
                }
            }
        }
        // 结果 所有结点均被访问过一次 且终点为 n - 1
        System.out.println(dp[(1 << n) - 1][n - 1]);
    }
}
```



如果用暴力枚举来算，确定起点和终点，枚举所有路径排列，也就是$ O((n - 2)!)$ 的时间复杂度，计算每一条路径和为 $O(n)$ ，总时间复杂度就为 $O(n*(n - 2)!)$，这是不可取的。



## 树形 DP



### 打家劫舍 III

#### 题目描述

<span id="house-robber-iii">打家劫舍 III</span>

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)



#### 题解

**状态定义：**

`dp[node][j]` ：这里 `node` 表示一个结点，以 `node` 为根结点的树，并且规定了 `node` 是否偷取能够获得的最大价值。

- `j = 0` 表示 `node` 结点不偷取；
- `j = 1` 表示 `node` 结点偷取。

**状态转移：**

对于每个结点来说只有两个状态：偷与不偷

- 如果没有偷窃当前结点，说明可以选择左右子结点(也可以不选)，选最大者；
- 如果偷窃当前结点，左右子结点均不能偷。

```java
public int rob(TreeNode root) {
    int[] res = dfs(root);
    return Math.max(res[0],res[1]);
}
private int[] dfs(TreeNode root) {
    if (root == null) {
        return new int[]{0,0};
    }
    int[] leftInfo = dfs(root.left);
    int[] rightInfo = dfs(root.right);
    // 后序处理
    // 当前结点的状态只有两种，偷取或不偷 dp[0]代表不偷 dp[1]代表偷
    int[] dp = new int[2];
    // 当前结点不偷 说明可以选择偷窃左右子结点
    dp[0] = Math.max(leftInfo[0],leftInfo[1]) + Math.max(rightInfo[0],rightInfo[1]);
    // 当前结点选择偷 说明不能选择偷窃左右子结点
    dp[1] = root.val + leftInfo[0] + rightInfo[0];
    return dp;
}
```



## 股票问题

### 买卖股票的最佳时机

#### 题目描述

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)



#### 题解

**暴力枚举**

```java
// 暴力枚举 超时
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    // 利益为负不选择交易
    int res = 0;
    // 枚举所有交易差
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            res = Math.max(res, prices[j] - prices[i]);
        }
    }
    // 利益为负 都不交易
    return res;
}
```



**贪心**

因为全程只能**买卖一次**, 所以**贪心的思想很自然就是取最左最小值, 取最右最大值, 那么得到的差值就是最大利润**.



**动态规划**

**状态定义：**

对于每一天来说只有两种状态，持股与不持股

`dp[i]` ：

- `i= 0` 表示当天持股手上所持有的现金
- `i = 1` 表示当前不持股手上所持有的现金

**状态转移：**

- 当天不持股的情况：
  - 之前也不持股
  - 之前持股，当天卖出
- 当天持股的情况：
  - 之前就持股
  - 当天才买入

```java
// 动态规划
public int maxProfit1(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    // 滚动数组 因为只需要两种状态
    int[] dp = new int[2];
    // 初始化第一天的状态
    dp[0] = 0;
    dp[1] = -prices[0];
    // 从第二天开始遍历
    for (int i = 1; i < n; i++) {
        // 今天不持股的情况 之前也不持股或者今天卖出
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        // 今天持股的情况 之前就持股或者今天买入
        dp[1] = Math.max(dp[1], -prices[i]);
    }
    // 返回不持股时手上的现金
    return dp[0];
}
```





### 买卖股票的最佳时机 II

#### 题目描述

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

与第一个问题相比，可以进行多次买入和卖出



#### 题解

**DFS**

由于不限制交易次数，在每一天，就可以根据当前是否持有股票选择相应的操作。

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/3ede46d543e0fcd2ec1b4f9031637fd404b4bdf73505bb1233d870ac92ea8283-image.png)

```java
// dfs超时
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    return dfs(prices, 0, 0);
}

private int dfs(int[] prices, int index, int status) {
    if (index == prices.length) {
        return 0;
    }
    // 局部变量 因为每次dfs并没有回溯
    int stay = 0, buy = 0, sell = 0;
    // 保持状态不变
    stay = dfs(prices, index + 1, status);
    if (status == 1) {
        // 持股状态卖出
        sell = prices[index] + dfs(prices, index + 1, 0);
    } else {
        // 不持股状态买入
        buy = -prices[index] + dfs(prices, index + 1, 1);
    }
    // 取三种策略的收益最大值
    return Math.max(Math.max(stay,buy),sell);
}
```



**贪心**

由于不限制交易次数，每一天都做买卖 只要今天股价比昨天股价高，昨天就选择交易，即可获得所有收益，贪心算法仅可以用于计算，但 **计算的过程并不是真正交易的过程**

```java
// 贪心
public int maxProfit2(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    int res = 0;
    // 每一天都做买卖 只要今天股价比昨天股价高，昨天就选择交易
    for (int i = 1; i < n; i++) {
        res += Math.max(0, prices[i] - prices[i - 1]);
    }
    return res;
}
```



**动态规划**

**状态定义：**

对于每一天来说只有两种状态，持股与不持股

`dp[i][j]` ：

- `i`为天数

- `j = 0` 表示当天持股手上所持有的现金
- `j = 1` 表示当天不持股手上所持有的现金

**状态转移：**

- 当天不持股的情况：
  - 之前也不持股
  - 之前持股，当天卖出
  - 之前已经卖出
- 当天持股的情况：
  - 之前就持股
  - 当天才买入

其实跟问题一的状态转移都是一样的，代码也是一样的，虽然是可以多次交易，但是最终都是最每个状态的最值，对于当天不持股之前卖出过的情况是已经被dp[0]记录下来了

```java
// 动态规划
public int maxProfit3(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    int[] dp = new int[2];
    dp[0] = 0;
    dp[1] = -prices[0];
    int pre0 = dp[0];
    for (int i = 1; i < n; i++) {
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        dp[1] = Math.max(dp[1], pre0 - prices[i]);
        pre0 = dp[0];
    }
    return dp[0];
}
```



### 最佳买卖股票时机含冷冻期

#### 题目描述

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)



#### 题解

**动态规划**

虽然这题比之前的多了一个冷冻期，但每天的状态依然是只有持股和不持股两种，只不过不持股里分为两种情况，一种当天可以买入，另一个则处于冷冻期不能买入

**状态定义**

- `dp[i][j]` ：

  - `i`为天数

  - `j = 0` 表示当天持股手上所持有的现金
  - `j = 1` 表示当天不持股(非冷冻期)手上所持有的现金
  - `j = 2` 表示当天冷冻期手上所持的现金


**状态转移：**

- 当天不持股(非冷冻期)的情况：
  - 之前也不持股
  - 前一天为冷冻期
- 当天不持股(冷冻期)的情况：
  - 卖出的第二天

- 当天持股的情况：
  - 之前就持股
  - 当天才买入

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    int[][] dp = new int[n][3];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[0][2] = 0;
    for (int i = 1; i < n; i++) {
        // 注意dp[][0]非冷冻期不持股的状态只能 由 非冷冻期不持股或冷冻期转化而来 而不能由持股卖出转化
        dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][2]);
        // 持股状态
        dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
        // 冷冻期状态
        dp[i][2] = dp[i - 1][1] + prices[i];
    }
    // 返回不持股状况的最大值
    return Math.max(dp[n - 1][0],dp[n - 1][2]);
}
```



滚动数组空间优化

使用滚动数组时，需要注意状态转移时，参数是否为上一次的状态，这题有三个状态，所以需要用两个pre变量来记录上个状态，避免前个状态在一个转移方程后发生更改

```java
public int maxProfit2(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int n = prices.length;
    // 滚动数组 空间优化
    int[] dp = new int[3];
    dp[0] = 0;
    dp[1] = -prices[0];
    dp[2] = 0;
    int pre0 = dp[0];
    int pre1 = dp[1];
    for (int i = 1; i < n; i++) {
        // 注意dp[][0]非冷冻期不持股的状态只能 由 非冷冻期不持股或冷冻期转化而来 而不能由持股卖出转化
        dp[0] = Math.max(dp[0],dp[2]);
        // 持股状态
        dp[1] = Math.max(dp[1],pre0 - prices[i]);
        // 冷冻期状态
        dp[2] = pre1 + prices[i];
        pre0 = dp[0];
        pre1 = dp[1];
    }
    // 返回不持股状况的最大值
    return Math.max(dp[0],dp[2]);
}
```



## 子序列系列

### 最长递增子序列

#### 题目描述

[LeetCode300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)



#### 题解

**DFS**

```java
// dfs暴力
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int res = 1;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dfs(nums, i));
    }
    return res;
}

private int dfs(int[] nums, int index) {
    int res = 1;
    for (int j = 0; j < index; j++) {
        if (nums[j] < nums[index]) {
            res = Math.max(res, 1 + dfs(nums, j));
        }
    }
    return res;
}
```



**记忆化搜索**

**状态定义：**

`LIS(i)`：表示以第`i`个数字为结尾的最长递增子序列的长度

**状态转移：**

`LIS(i) = max(1 + LIS(j) if nums[j] < nums[i] && j < i)`



```java
// 记忆化搜索
private int[] memory;

public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    memory = new int[n];
    // res表示以第i个数字为结尾的最长递增子序列的长度
    int res = 1;
    for (int i = 0; i < n; i++) {
        memory[i] = -1;
    }
    // 枚举所有以第i个数字为结尾的最长递增子序列的长度 取最大值
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dfs(nums, i));
    }
    return res;
}

private int dfs(int[] nums, int index) {
    if (memory[index] == -1) {
        int res = 1;
        for (int j = 0; j < index; j++) {
            if (nums[j] < nums[index]) {
                res = Math.max(res, 1 + dfs(nums, j));
            }
        }
        memory[index] = res;
    }
    return memory[index];
}
```



**动态规划**

遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间，使用dp[n]

```java
// 动态规划
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    // 表示以第i个数字为结尾的最长递增子序列的长度
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
	// 得到所有LIS(i)后 取最大值
    int res = 1;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```



ACM模式：

题目链接https://www.nowcoder.com/questionTerminal/d83721575bd4418eae76c916483493de

```java
import java.util.Scanner;
import java.util.Arrays;

public class M {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        // 多组数据
        while (read.hasNext()) {
            int n = read.nextInt();
            int[] nums = new int[n];
            int[] dp = new int[n];
            int res = 1;

            for (int i = 0; i < n; i++) {
                nums[i] = read.nextInt();
            }
            Arrays.fill(dp, 1);

            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[j] < nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
                res = Math.max(res, dp[i]);
            }
            System.out.println(res);
        }
    }
}
```





<span id="longest-increasing-subsequence">**贪心 + 二分（最优解）**</span>

贪心思想：依然着眼于某个递增子序列的结尾的元素，如果已经得到的递增子序列的结尾的数越小，那么遍历的时候后面接上一个数，**会有更大的可能构成一个长度更长的上升子序列**。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，不断更新。



**定义：**

`dp[i]` 表示所有长度为`i`的 递增子序列结尾的最小值

并且`dp`数组是严格递增的

证明：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220301204317080.png)

因为只需要维护状态数组 `dp` 的定义，它的长度就是最长递增子序列的长度。因为`dp`已经是一个有序数组，所以我们使用二分来更新最小值

看下动画就懂了

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/Honeycam%202022-03-01%2020-47-36.gif)

时间复杂度`O(NlogN)`

```java
// 贪心 + 二分
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    // 表示长度为 i 的 所有递增子序列的结尾的最小值 用的不是动态规划数组名随便起的
    int[] dp = new int[n + 1];
    // 做一个位置的偏移
    dp[1] = nums[0];
    int len = 1;
    for (int i = 1; i < n; i++) {
        if (dp[len] < nums[i]) {
            dp[++len] = nums[i];
        } else {
            // 因为做了右一位偏移 所以二分初始值为 1 和 len
            int index = binarySearch(dp, 1, len, nums[i]);
            if (index != -1) {
                dp[index] = nums[i];
            }
        }
    }
    return len;
}

private int binarySearch(int[] sortedArr, int L, int R, int target) {
    if (sortedArr == null || sortedArr.length == 0) {
        return -1;
    }
    int left = L;
    int right = R;
    int mid = 1;
    // 循环条件至少有两个数
    while (left < right) {
        mid = left + ((right - left) >> 1);
        // 因为是严格递增 所以如果target等于dp里的数的话不更新
        if (sortedArr[mid] == target) {
            return -1;
        } else if (sortedArr[mid] < target) {
            left = mid + 1;
        } else if (sortedArr[mid] > target){
            // 为了保证找出的数一定是第一个大于target的，right指针赋值为mid而不是mid - 1
            // 如果世上mid - 1找出的数只是最邻近target的值，而不能确定这个数比target大还是小
            right = mid;
        }
    }
    return left;
}
```







### 最长递增子序列的个数

#### 题目描述

[673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)



#### 题解

不同于最长递增子序列问题，这题我们还需要多维护一个数组



**动态规划**



**状态定义：**

`LIS(i)`：表示以第`i`个数字为结尾的最长递增子序列的长度

`count(i)`：表示以第`i`个数字为结尾的最长递增子序列的个数

**状态转移：**

`LIS(i) = max(1 + LIS(j) if nums[j] < nums[i] && j < i)`



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220302235400607.png)

```java
public int findNumberOfLIS(int[] nums) {
    if (nums.length < 2) {
        return nums.length;
    }
    int n = nums.length;
    int[] dp = new int[n];
    int[] count = new int[n];
    Arrays.fill(dp, 1);
    Arrays.fill(count, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                if (dp[j] + 1 > dp[i]) {
                    // 说明找到了一个更长的递增子序列 还是只有一条最长的 以nums[i]结尾的长度就等于以nums[j]结尾的长度
                    count[i] = count[j];
                } else if (dp[j] + 1 == dp[i]) {
                    /* 说明在一次内循环寻找dp[i最大值中找到了两个相同长度的递增子序列 注意这里是累加而不是+1
                        因为这是有多种方案可以达到最长递增子序列 而count[i]的定义是以nums[i]结尾的最长递增子序列的数量
                     */
                    count[i] += count[j];
                }
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    int res = 0;
    int maxLen = 0;
    // 找出最大长度
    for (int x : dp) {
        maxLen = Math.max(maxLen, x);
    }
    // 将所有最大长度对应的count[i]累加就是结果
    for (int i = 0; i < n; i++) {
        if (dp[i] == maxLen) {
            res += count[i];
        }
    }
    return res;
}
```



**常数优化**

```java
public int findNumberOfLIS1(int[] nums) {
    if (nums.length < 2) {
        return nums.length;
    }
    int n = nums.length;
    int[] dp = new int[n];
    int[] count = new int[n];
    int maxLen = 1;
    int res = 1;
    Arrays.fill(dp, 1);
    Arrays.fill(count, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                if (dp[j] + 1 > dp[i]) {
                    // 把dp的更新写在dp[j] + 1 > dp[i]就不用额外判断内循环的最值了
                    dp[i] = dp[j] + 1;
                    count[i] = count[j];
                } else if (dp[j] + 1 == dp[i]) {
                    count[i] += count[j];
                }
            }
        }
        // 同时找出最大长度
        maxLen = Math.max(maxLen,dp[i]);
    }

    // 将所有最大长度对应的count[i]累加就是结果
    for (int i = 0; i < n; i++) {
        if (dp[i] == maxLen) {
            res += count[i];
        }
    }
    return res;
}
```



### 最长递增子序列的一个解

#### 题目描述

求一个具体的LIS序列



#### 题解

前面求`LIS`长度的分析中，我们知道LIS可能出现在任意一个以`nums[i]`结尾的子序列中，但是我们并不知道会出现在哪里。在求LIS长度的问题中，我们是求`dp[i]`中的最大值。那这里，在求具体的`LIS`中，对于每一个`dp[i]`，我们需要用一个列表`res`存下一个结束于`nums[i]`的`LIS`。这样，最后找到值最大的`dp[i]`时，对应的`res[i]`即为所求整个串的`LIS`。



动态规划求方案，就是将我们转移的过程记录下来即可



牛客网上有题类似的

https://www.nowcoder.com/questionTerminal/30fb9b3cab9742ecae9acda1c75bf927

不过他要求的解是如果有多个答案，请输出其中字典序最小的

下面代码只是求出一个解



**使用数组记录解**

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int[] nums = new int[n];
        int[] dp = new int[n];
        int[] memory = new int[n]; // 用于记录转移的过程
        int index = 0;
        int res = 1;

        for (int i = 0; i < n; i++) {
            nums[i] = read.nextInt();
        }
        Arrays.fill(dp, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    // 记录下每个状态从哪里来的
                    memory[i] = j;
                }
            }
            // 求出最大长度 和 该序列结尾的索引
            if (dp[i] > res) {
                res = dp[i];
                index = i;
            }
        }

        Deque<Integer> stack = new ArrayDeque<>();
        // 倒序输入栈
        for (int i = 0, len = dp[index]; i < len; i++) {
            stack.push(nums[index]);
            index = memory[index];
        }
        // 最后再输出栈即可
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + " ");
        }
    }
}
```



显然使用数组来存储解是不太方便的，我们使用list

```java
public List<Integer> getSeqOfLIS(int[] nums) {
    if (nums.length < 2) {
        if (nums.length == 0) {
            return new ArrayList<>();
        }
        else {
            return new ArrayList<>(nums[0]);
        }
    }

    int n = nums.length;
    // 表示以nums[i]为结尾的最长递增子序列的长度
    int[] dp = new int[n];
    int maxLen = 1;
    int maxId = 1;
    // res.get(i) 表示以nums[i]结尾的最长递增子序列
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    Arrays.fill(dp, 1);
    // 初始化索引为0的res
    path.add(nums[0]);
    res.add(path);
    for (int i = 1; i < n; i++) {
        path = new ArrayList<>();
        int index = -1;
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                dp[i] = dp[j] + 1;
                index = j;
            }
        }
        // 下面两步是将res.get(index)复制并挂到nums[i]作为以nums[i]结尾的最长递增子序列
        if (index > -1) {
            path.addAll(res.get(index));
        }
        path.add(nums[i]);

        res.add(path);
        // 同步更新最大长度和最大长度递增子序列尾元素的索引
        if (dp[i] > maxLen) {
            maxLen = dp[i];
            maxId = i;
        }
    }
    return res.get(maxId);
}
```



### 摆动序列

#### 题目描述

[LeetCode376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)



#### 题解

**动态规划**

**状态定义：**

摆动序列要么以降序结尾要么以升序结尾

`dp[i][0]`：考虑`[0, i - 1]`内**以降序结尾**的摆动数组的最长子序列的长度

`dp[i][1]`：考虑`[0, i - 1]`内**以升序结尾**的摆动数组的最长子序列的长度

**状态转移：**

`num[i] > nums[i - 1]`：

- `dp[i][1] = 1 + dp[i - 1][0]  `
- `dp[i][0] = dp[i - 1][0]  `

`num[i] < nums[i - 1]`：

- `dp[i][1] = dp[i - 1][1]  `
- `dp[i][0] = 1 + dp[i - 1][1]  `

`num[i] = nums[i - 1]`：

- `dp[i][1] = dp[i - 1][1]  `
- `dp[i][0] = dp[i - 1][0]  `



```java
public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 1;
    dp[0][1] = 1;
    for (int i = 1; i < n; i++) {
        // 如果下一数大于前一个数 则新升序结尾数组 = 旧降序结尾数组+1 新降序结尾数组不变 维护摆动
        if (nums[i] > nums[i - 1]) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = 1 + dp[i - 1][0];
        } else if (nums[i] < nums[i - 1]) {
            // 如果下一数小于于前一个数 则新降序结尾数组 = 旧升序结尾数组 + 1 维护摆动
            dp[i][0] = 1 + dp[i - 1][1];
            dp[i][1] = dp[i - 1][1];
        } else {
            // 相等都不变
            dp[i][1] = dp[i - 1][1];
            dp[i][0] = dp[i - 1][0];
        }
    }
    // 返回考虑[0, i - 1]内最长子序列的长度
    return Math.max(dp[n - 1][0], dp[n - 1][1]);
}
```

第一维度也可以优化掉，因为只与前一个状态有关，可以达到O1



**贪心**

画出折线图显而易见，我们只需要关注峰谷和封顶，峰谷和封顶的数量就是所求



![image-20220301233729694](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220301233729694.png)

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220301235214081.png)

```java
public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    int cur = 0;
    int pre = 0;
    // 声明一个res 注意边界 有一个峰值出现摆动序列长度就是2 所以初始化为1
    int res = 1;
    for (int i = 1; i < n; i++) {
        cur = nums[i] - nums[i - 1];
        // 当出现峰谷和峰顶时 res+1 并且pre将升序切换到降序或降序切换到升序
        if ((cur > 0 && pre <= 0) || (cur < 0 && pre >= 0)) {
            res++;
            pre = cur;
        }
    }
    return res;
}
```



### 最长公共子序列

#### 题目描述

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

可以应用在基因工程、基因相似度



#### 题解

**DFS**

递归树：

从A、B两个字符串的末尾的字符开始比对，如果字符相等，则说明存在一个公共字符，长度+1，

如果不相等，则分出两条分支，**A字符串指针往前移一位、B字符串指针不动继续比较** 和 **B字符串指针往前移一位、A字符串指针不动继续比较**，**两个分支取最大值**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220302204143508.png)

```java
// dfs超时
public int longestCommonSubsequence(String text1, String text2) {
    if (text1.length() == 0 || text2.length() == 0) {
        return 0;
    }
    return dfs(text1.toCharArray(), text2.toCharArray(), text1.length() - 1, text2.length() - 1);
}
private int dfs(char[] test1, char[] test2, int i, int j) {
    if (i == -1 || j == -1) {
        return 0;
    }
    if (test1[i] == test2[j]) {
        return 1 + dfs(test1, test2, i - 1, j - 1);
    }else {
        return Math.max(dfs(test1, test2, i - 1, j), dfs(test1, test2, i, j - 1));
    }
}
```



**记忆化搜索**

可以看到上面的递归树存在着重复子问题和最优子结构，所以可以用记忆化优化

因为是两个字符串，所以使用二维来定义A串`i`位置和B串`j`位置是否相等

```java
// 记忆化搜索
private int[][] memory;

public int longestCommonSubsequence(String text1, String text2) {
    if (text1.length() == 0 || text2.length() == 0) {
        return 0;
    }
    int m = text1.length();
    int n = text2.length();
    memory = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            memory[i][j] = -1;
        }
    }
    return dfs(text1.toCharArray(), text2.toCharArray(), m - 1, n - 1);
}

private int dfs(char[] text1, char[] text2, int i, int j) {
    if (i == -1 || j == -1) {
        return 0;
    }
    if (memory[i][j] == -1) {
        if (text1[i] == text2[j]) {
            memory[i][j] = 1 + dfs(text1, text2, i - 1, j - 1);
        } else {
            memory[i][j] = Math.max(dfs(text1, text2, i - 1, j), dfs(text1, text2, i, j - 1));
        }
    }
    return memory[i][j];
}
```



**动态规划**

**状态定义：**

`dp[i][j]`：长度为`i`的`text1`子串与长度为`j`的`text2`字串的公共子串长度（是指text1前i个字符构成的子串和text2前j个字符构成的子串的最长公共子序列长度）

**状态转移：**

`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), if text1[i] != text2[j]`

`dp[i][j] = 1 + dp[i - 1][j - 1], if text1[i] == text2[j] `



```java
// 动态规划 自底向上
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    // 初始化默认为0
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```



ACM模式

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        int m = read.nextInt();
        int n = read.nextInt();
        String text1 = read.next();
        String text2 = read.next();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        } 
        
        System.out.println(dp[m][n]);
    }
}
```



## 二维平面

### 滑雪

#### 题目描述

[AcWing901. 滑雪](https://www.acwing.com/problem/content/description/903/)

给定一个 $R$ 行 $C$ 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 $i$ 行第 $j$ 列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。

在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

**输入格式**

第一行包含两个整数 $R$ 和 $C$。

接下来 $R$ 行，每行包含 $C$ 个整数，表示完整的二维矩阵。

**输出格式**

输出一个整数，表示可完成的最长滑雪长度。

**数据范围**

$1≤R,C≤300$
$0≤矩阵中整数≤10000$

**输入样例：**

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**输出样例：**

```
25
```

#### 题解

**记忆化搜索**

四个方向深搜

![image-20220408224905007](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220408224905007.png)

```java
import java.util.Scanner;

/**
 * @author novo
 * @date 2022/4/8-21:38
 */
public class Main {
    static int[][] memory;
    static int[][] nums;
    static int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    static int m;
    static int n;

    public static void main(String[] args) {
        Scanner read = new Scanner(System.in);
        m = read.nextInt();
        n = read.nextInt();
        nums = new int[m][n];
        memory = new int[m][n];
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                nums[i][j] = read.nextInt();
                memory[i][j] = -1;
            }
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                res = Math.max(res, dfs(i, j));
            }
        }

        System.out.println(res);
    }

    private static int dfs(int x, int y) {
        if (memory[x][y] == -1) {
            // 注意赋初始值
            memory[x][y] = 1;
            for (int[] direct : directs) {
                int newX = x + direct[0];
                int newY = y + direct[1];
                if (inArea(newX, newY) && nums[x][y] > nums[newX][newY]) {
                    memory[x][y] = Math.max(memory[x][y], dfs(newX, newY) + 1);
                }
            }
        }
        return memory[x][y];
    }

    private static boolean inArea(int x, int y) {
        return x >= 0 && x < m && y >= 0 && y < n;
    }
}
```







逻辑图：树状

实际结构：压栈

时间复制度分析

master定理：

(只针对递归问题子规模一致的时候使用)

![image-20220126141702793](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220126141702793.png)

n/b 是递归子问题的规模，a是一次方法中调用递归的次数，f(n)是非递归的操作，用O(N^d)来表示非递归的时间复杂度
$$
当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(N^{\log_{b} {a}})\\
1) \log_{b} {a} < d ---> 复杂度为O(N^d)\\

2) \log_{b} {a} > d --> 复杂度为O(N^{\log_{b} {a}})\\

3) \log_{b} {a} = d ----> 复杂度为O(N^d*{\log_{}{N}})\\
$$



### 1、汉诺塔问题

```java
/**
 * 从最左到最右只需要三步：
 * 1.上面 N - 1 的挪去辅助柱
 * 2.剩余的一个挪去最右
 * 3.辅助柱的挪去最右
 */
public static void process(int N, String source, String target, String help) {
    if (N == 1) {
        System.out.println("move 1 from " + source + " to " + target);
    } else {
        // 1.上面 N - 1 的挪去辅助柱
        process(N - 1, source, help, target);
        // 2.剩余的一个挪去最右 打印的是 剩余的一个挪去最右
        System.out.println("move " + N + " from " + source + " to " + target);
        // 3.辅助柱的挪去最右
        process(N - 1, help, target, source);
    }

}

public static void hanoi(int N, String source, String target, String help) {
    process(N, source, target, help);
}
```









































![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220206001808032.png)





# 贪心

贪心选择性质

如果无法举出反例，如何证明贪心算法的正确性？

通过使用两种证明方法：数学归纳法(有一个变量在显然增加的情况)、反证法（假设不正确，推导出矛盾）

反证：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220312223321634.png)



### 字典序排列最小的等效字符串

正确的贪心策略：字典序 ab < ba,而不是a < b

```java
public static String smallestString(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    Arrays.sort(strs, (String str1, String str2) -> (str1 + str2).compareTo(str2 + str1));
    StringBuilder res = new StringBuilder();
    for (String str : strs) {
        res.append(str);
    }
    return res.toString();
}
```



### 最多可以参加的会议数目

```java
public int maxEvents(int[][] events) {
    //首先排序：开始时间小的在前。这样是方便我们顺序遍历，把开始时间一样的都放进堆
    Arrays.sort(events, (o1, o2) -> o1[0] - o2[0]);
    //小顶堆
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    //结果、开始时间、events下标、有多少组数据
    int res = 0, last = 1, i = 0, n = events.length;
    while (i < n || !pq.isEmpty()) {
        //将start相同的会议都放进堆里
        while (i < n && events[i][0] == last) {
            pq.offer(events[i++][1]);
        }
        //pop掉当前天数之前的
        while (!pq.isEmpty() && pq.peek() < last) {
            pq.poll();
        }
        //顶上的就是俺们要参加的
        if (!pq.isEmpty()) {
            pq.poll();
            res++;
        }
        last++;
    }
    return res;
}
```



### 金条分割问题

最优二叉树(哈夫曼树)基于贪心算法

（1）准备一个小根堆。将数组放到这个小根堆里。

（2）每次弹出堆顶的两个数求和为A，将A再放回小根堆里。

（3）一直执行第2步，直到堆只剩一个数。最后，每一次第二步A的累加和即是最后的结果。

例如给定的金条长度为150，要分成10、20、30、40、50的块，最后花费的铜板数量即是上图中蓝色圆圈的和，即150+60+90+30=330。

也就是我们代码求解的时候是从叶子往根求的，求完后再从根往叶子即是金条的切割顺序，最后所有的叶子即是需要切成的块的大小。

```java
public static int splitGold(int[] arr) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int i : arr) {
        heap.add(i);
    }
    int payMoney = 0;
    int sum = 0;
    while (heap.size() > 1){
        sum = heap.poll() + heap.poll();
        payMoney += sum;
        heap.add(sum);
    }
    return payMoney;
}
```



### IPO

#### 题目描述

[LeetCode502. IPO](https://leetcode-cn.com/problems/ipo/)

假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。

最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。

答案保证在 32 位有符号整数范围内。

**示例 1：**

```
输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
```

**示例 2：**

```
输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
输出：6
```



#### 题解

优先队列+贪心



注意一点，启动资金是可以收回来的，所以在本题中项目不会亏本，那么只要**依次选启动资金低于本金里收益最大的项目**，就可以将收益最大化

**这种贪心符合人的思维，就是在能够做的项目里选择利润最大的去做，并不需要证明**

所以准备一个小根堆存入所有项目，从小根堆里取出当前启动资金可以做的所有项目放入另一个大根堆，这个堆按收益排序，这个大根堆堆顶就是一个局部最优，**做完一个项目后，需要更新最大利益堆**，因为此时本金已改变，可以做更多的项目

```java
public static class Project {
    int cost;
    int profit;

    public Project(int cost, int profit) {
        this.cost = cost;
        this.profit = profit;
    }
}

public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    PriorityQueue<Project> minCostHeap = new PriorityQueue<>((o1, o2) -> o1.cost - o2.cost);
    PriorityQueue<Project> maxProfitHeap = new PriorityQueue<>((o1, o2) -> o2.profit - o1.profit);
    // 将项目都加入最小成本堆
    for (int i = 0; i < profits.length; i++) {
        minCostHeap.add(new Project(capital[i], profits[i]));
    }
    for (int i = 0; i < k; i++) {
        // 项目不为空且最小成本堆顶的启动资金小于本金时，加入最大收益堆
        while (!minCostHeap.isEmpty() && minCostHeap.peek().cost <= w) {
            maxProfitHeap.add(minCostHeap.poll());
        }
        // 最大收益堆为空 说明本金w可能小于成本或者项目已经都做完，直接返回w
        if (maxProfitHeap.isEmpty()) {
            return w;
        }
        w += maxProfitHeap.poll().profit;
    }
    return w;
}
```



### 点灯问题

#### 题目描述

给定一个字符串str，只由‘X’和‘.’两种字符构成。‘X’表示墙，不能放灯，也不需要点亮。‘.’表示居民点，可以放灯，需要点亮。如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮。返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。



#### 题解

分情况讨论位置情况

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220203214705835.png)

如果i位置为墙，不放灯，i跳到下一位置

如果i位置为居民点，则往下判断i+1位置的情况，如果i+1为墙，那么灯只能放在i位置，i跳到i+2，如果i+1为居民点，那么继续往下判断i+2位置的情况，如果i+2为墙，灯放在i和i+1位置都可以，i跳到i+3，如果i+2位居民点，那么灯放在i+1位置，i跳到i+3

```java
public static int light(String road) {
    char[] str = road.toCharArray();
    int i = 0;
    int light = 0;
    while (i < str.length) {
        if (str[i] == 'X') {
            i++;
        } else {
            // 无论是那种情况此时必须放灯
            light++;
            if (i + 1 == str.length) {
                break;
            }
            // 有i+1位置的情况
            if (str[i + 1] == 'X') {
                i = i + 2;
            } else {
                i = i + 3;
            }
        }
    }
    return light;
}
```



### 分发饼干

#### 题目描述

[LeetCode455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)



#### 题解

**贪心**

贪心思想1：尽量用大的饼干满足胃口大的小朋友

```java
public int findContentChildren(int[] g, int[] s) {
    // 贪心算法 尽量用大的饼干满足胃口大的小朋友
    Arrays.sort(g);
    Arrays.sort(s);

    int res = 0;
    int i = g.length - 1;
    int j = s.length - 1;

    while (i >= 0 && j >= 0) {
        // 如果最大的饼干能满足当前最大胃口的孩子 则res + 1
        if (s[j] >= g[i]) {
            res++;
            i--;
            j--;
        } else {
            // 否则当前最大胃口的孩子无法满足 跳过该孩子
            i--;
        }
    }
    return res;
}
```



贪心思想2：尽量用小的饼干满足胃口小的小朋友

```java
public int findContentChildren1(int[] g, int[] s) {
    // 贪心算法 尽量用小的饼干满足胃口小的小朋友
    Arrays.sort(g);
    Arrays.sort(s);

    int res = 0;
    int i = 0;
    int j = 0;

    while (i < g.length && j < s.length) {
        // 如果最小的饼干能满足当前最小胃口的孩子 则res + 1
        if (s[j] >= g[i]) {
            res++;
            i++;
        }
        // 无论是否满足 当前饼干索引都要加1
        j++;
    }
    return res;
}
```



### 判断子序列

#### 题目描述

[LeetCode392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)



#### 题解



**贪心 + 双指针** 

因为这题太简单了，可能都没有意识到使用到了贪心

贪心策略：对于s中的每个字符，按顺序在t中查找是否有相同的字符，找到一个相同的字符后就继续查找下一个字符，中间遍历的顺序一直是从前向后。

```java
// 贪心 双指针
public boolean isSubsequence(String s, String t) {
    int sLen = s.length();
    int tLen = t.length();
    int i = 0;
    int j = 0;
    while (i < tLen) {
        // 在长串找到匹配的字符j++
        if (s.charAt(j) == t.charAt(i)) {
            j++;
        }
        i++;
    }
    // 如果j为短串的长度 说明能在长串中找到短串所有的字符
    return j == sLen;
}
```



**动态规划**

思路一：求出最长公共子序列，判断最长公共子序列长度是否等于 s 串

思路二：编辑距离



### 判断子序列（大数据）

https://leetcode-cn.com/problems/is-subsequence/solution/javati-jie-he-hou-xu-tiao-zhan-by-lil-q/



### 最长递增子序列

[点击跳转](#longest-increasing-subsequence)





### 无重叠区间

#### 题目描述

[LeetCode435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

**提示:**

- `1 <= intervals.length <= 10^5`
- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 10^4`



#### 题解



**暴力解**

找出所有子区间的组合，之后判断它重不重叠。`O(2 ^ n) * n`，每个区间选或不选



**动态规划**



**最少移除多少区间 --> 最多保留多少区间**



这题是可以**转化成最长递增子序列问题**，但实际上还是有区别的。因为该题是要求移除区间的最小数量，使剩余区间互不重叠，**区间的位置是无关紧要的**，是可以移动的，而最长递增子序列中的元素是不能被移动的，所以我们要**先将区间排好序**，才能在动态规划过程中忽视掉区间的位置。比如下面这两个区间是互不重叠的，但对于区间元素来说并不是递增的，我们交换两个位置就可以当做递增子序列了

排好序就可以转化成最长递增子序列

```
[[11,22],[1,11]] --> [[1,11],[11,22]]
```

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    // 因为该题是要求移除区间的最小数量，使剩余区间互不重叠，区间的位置是无关紧要的，是可以移动的，而最长递增子序列中的元素是不能被移动的，所以我们要先将区间排好序
    Arrays.sort(intervals, (o1, o2) -> (o1[0] == o2[0] ? (o1[1] - o2[1]) : (o1[0] - o2[0])));
    int n = intervals.length;
    // dp[i] 表示考虑intervals[0...i]内能构成最长不重叠区间的长度
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            // 如果存在j < i 且intervals[j]的end 小于等于 intervals[i]的start 说明这两个区间不重叠
            if (intervals[j][1] <= intervals[i][0]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    // 找到dp最大值
    int res = 1;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    // 需要移除的最少区间 = 总区间长度 - 最长不重叠区间长度
    return n - res;
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220311225607929.png)

因为这题 LeetCode 给的数据量太大，动态规划还是会超时



**贪心**

从动态规划的核心代码中，我们得知每次选择中，**每个区间的结尾很重要**，**前面区间的 end 值越小，留给后面的区间空间越大**，越能容纳更多区间，我们基于这种思想，可以设计出贪心算法：

**每次选择结尾最早的，且和前一区间不重叠的区间。**

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    int n = intervals.length;
    // 注意这里排序规则是 按end值排序 end值越小 越靠前
    Arrays.sort(intervals, (o1, o2) -> (o1[1] == o2[1] ? (o1[0] - o2[0]) : (o1[1] - o2[1])));
    int res = 1;
    int pre = 0;
    for (int i = 1; i < n; i++) {
        // 如果区间i的起始值 大于等于 前一个区间的end值 则添加区间res++ 更新pre
        if (intervals[i][0] >= intervals[pre][1]) {
            // 这里可以体现出作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不作保留
            res++;
            pre = i;
        }
    }
    return n - res;
}
```



**证明**

贪心选择性质

贪心策略：按照区间的结尾排序，每次选择结尾最早的，且和前一个区间不重叠的区间

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220312221850900.png)

注意理解在某一步有**两种合法的选择**，一种是按照贪心算法算出的`[s(i), f(i)]`，另一种就是假设是最优解选择的`[s(j), f(j)] `且`f(i) < f(j)`，也就是最优解不是当前选择中 end 值最小的区间。

因为`f(i) < f(j)`，而且我们不需要考虑起始值`s(i)`和`s(j)`，因为我们假设的这两种选择都是合法的，说明这两个起始值都没有与之前选择区间的 end 值重叠，那么我们可以在这一步中将贪心算法选择的区间`[s(i), f(i)]`替换掉假设的最优解选择的区间`[s(j), f(j)]`，而不影响后续区间的选择。(因为 end 值变小了)

此时，我们选择`[s(i), f(i)]`也能构成一个大小为 k 的解，与原来的假设矛盾，所以可以证明出这个问题具有贪心选择性质



### 放养但没有完全放养

#### 题目描述

[AcWing3358. 放养但没有完全放养](https://www.acwing.com/problem/content/description/3361/)



#### 题解

```java
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char[] songArr = sc.nextLine().toCharArray();
        char[] listerArr = sc.nextLine().toCharArray();
        
        // 记录song中所有字符的位置 song是26个字母的排列，每个字母卫衣
        int[] index = new int[26];
        for (int i = 0; i < 26; i++) {
            index[songArr[i] - 'a'] = i;
        }
        
        int res = 1;
        for (int i = 1; i < listerArr.length; i++) {
            // 如果短串邻接的两个字符中位置出现逆序或相等，这两个字符必然不能出现在同一次中
            if ((index[listerArr[i] - 'a']) <= (index[listerArr[i - 1] - 'a'])) {
                res++;
            }
        }
        
        System.out.println(res);
    }
}
```



# 数学



### 你知道你的ABC吗

#### 题目描述

[AcWing3346. 你知道你的ABC吗](https://www.acwing.com/problem/content/description/3349/)



#### 题解

一道推理题，因为 A B C 都为正整数且有 (A≤B≤C），那么我们将7个所给的数进行升序排序，那么必有 A + B + C 排在最后（最大值），A 排在最前（A肯定是可以排在第一位的，即使 A == B，我们也可以确定第一位的数与 A 相等）。

第二位数只有两种可能（未推理）：

- B
- A + C

当 B == C 时，第二位也可以是 C，但此时不影响 B 可以在第二位

我们假设：第二位不能是 B，也就是说，7个数中存在 x 使得 `A <= x < B`，严格小于

根据题意 C、A+B、B+C、A+B+C 都大于等于 B，x 不可能为这些数，只剩下 A + C

A + C ？B

因为 C >= B，所以 A + C >= B，所以与假设矛盾，第二位是 B

```java
import java.util.Arrays;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] nums = new int[7];
        for (int i = 0; i < 7; i++) {
            nums[i] = sc.nextInt();
        }
        
        Arrays.sort(nums);
        int C = nums[6] - nums[0] - nums[1];
        System.out.println(nums[0] + " " + nums[1] + " " + C);
    }
}
```



# 图论

## 可转化成图论的问题

### 单词接龙

#### 题目描述

[LeetCode127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)



#### 题解



**BFS**

求解*从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。

显然是一个最短路径问题，这题不难想到使用 BFS 来求解

为什么 BFS 得到的路径最短？**可以把起点和终点所在的路径拉直来看，两点之间线段最短**

两个单词对应位置只有一个字符不同，例如 "hit" 与 "hot"，这种转换是**可以逆向**的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图。

![image.png](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/ec8f7e4f40134b932a9ff2e306d885e427bd8ee912801361849d92ddae6226f3-image.png)


正因为可逆向，我们还需要 visited 集合来记录下所访问的结点，避免重复访问

这题难的是对单词的处理

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    if (wordList.size() == 0) {
        return 0;
    }
    // 字典放到哈希表中，因为我们需要快速的判断某个单词是否在字典中
    Set<String> wordSet = new HashSet<>(wordList);

    // 因为这个是一个无向图 为了避免匹配重复单词 需要记录已访问的结点
    Set<String> visited = new HashSet<>();
    visited.add(beginWord);

    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    int depth = 0;
    while (!queue.isEmpty()) {
        int levelCount = queue.size();
        depth++;
        // O(26 * word.length())
        for (int i = 0; i < levelCount; i++) {
            String cur = queue.poll();
            char[] curWord = cur.toCharArray();
            // 枚举cur修改一个字符后的所有单词 26 * 单词长度 - 1种可能（所有单词长度相等）
            for (int j = 0; j < endWord.length(); j++) {
                // 因为每个单词只能修改一个字符，所以在更换前需要备份，之后需要恢复
                char originChar = curWord[j];
                for (char k = 'a'; k <= 'z'; k++) {
                    // 跳过本身的字符
                    if (j == originChar) {
                        continue;
                    }
                    // 修改一个字符
                    curWord[j] = k;
                    String next = String.valueOf(curWord);
                    // 判断修改一个字符后的单词是否在字典中
                    if (wordSet.contains(next)) {
                        // 判断是否新单词是否与end匹配
                        if (next.equals(endWord)) {
                            return depth + 1;
                        }
                        // 该结点未被访问过，则选择该结点当做路径 并标记
                        if (!visited.contains(next)) {
                            visited.add(next);
                            queue.add(next);
                        }
                    }
                }
                // 恢复该字符，进入下一个字符位枚举
                curWord[j] = originChar;
            }
        }
    }
    // 不存在这样的转换序列返回0
    return 0;
}
```



**双向 BFS**

TODO
