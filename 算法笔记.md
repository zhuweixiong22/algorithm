对数器





# 二分查找

- 在一个有序数组中，找到某个数是否存在
- 在一个有序(升序)数组中，找 >= 某个数最左侧的位置
- 在一个有序(升序)数组中，找 <= 某个数最右侧的位置
- 局部最小值问题



### 局部最小值问题

二分不一定要有序：数据状况特殊，问题特殊，只要能找出数据的排他性，有一半数据肯定有，另一半数据不确定，那就可以砍一半用二分。

给出一个无序且相邻两个数不相等的数组，找出一个局部最小数（找谷底）

给出局部最小定义：

[0]位置时，只要[0] < [1]，那么[0]就是局部最小

[N - 1]位置时，只要[N - 2] > [N - 1]，那么[N - 1]就是局部最小

[i]位置(不在0和N - 1)，需要[i - 1] > [i] < [i + 1]



先特判两个边界，若找到了其中一个就返回

若找不到，则说明左边界单调递减，右边界单调递增，所以1 ~ N - 2 间一定会有最小值

![image-20220123214403131](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123214403131.png)

二分找中间，如果此时找到了直接返回

![image-20220123214955679](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123214955679.png)

若找不到，则有三种情况单调递增、单调递减和i为局部最大，无论哪种情况都至少存在一个区域可以继续二分找出局部最小值。

![image-20220123215200995](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123215200995.png)

![image-20220123215328950](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123215328950.png)

![image-20220123215406873](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220123215406873.png)



# 位运算



异或定义：无进位相加

性质

- 0 ^ N == N
- N ^ N == 0
- 满足结合律和交换律，所以同一批数异或，无论是什么顺序，结果唯一



### 1、如何不用额外空间交换两个数

```java
a = a ^ b;
b = a ^ b; //证明：b = a ^ b ==> (a ^ b) ^ b ==> a ^ (b ^ b) ==> a ^ 0 ==> a
a = a ^ b; //证明：a = a ^ b ==> (a ^ b) ^ a ==> (a ^ a) ^ b ==> 0 ^ b ==> b
```

**注意前提是：a和b在内存中的位置不相等(即a和b有各自独立的内存区域,a和b的值可以一眼)，如果a和b指向同一块内存，执行三行代码后会变成0**

这两种方法只有当i 和 j指向不一样时才有用否则会变成0

```java
private void swap (int[] nums, int i, int j) {
    nums[i] = nums[i] + nums[j];
    nums[j] = nums[i] - nums[j];
    nums[i] = nums[i] - nums[j];
}
```



### 2、一个数组中有一个数出现了奇数次，其余数均出现偶数次，打印出出现奇数次的数

例：[4,3,4,2,4,3,1,2,1,1,1,3] 打印出4

普通方法：哈希表

异或运算：

只需要定义一个XOR初始值为0，XOR遍历数组异或每一个数，即`XOR = XOR ^ arr[i];或 XOR ^= arr[i] `或最终得到的结果就是所求值。

证明：同一批数异或，无论是什么顺序，结果唯一，

所以最终结果可以写成=XOR ^ (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (4 ^ 4 ^ 4)

因为偶数个本身异或为0，所以只剩下 4 ^ 4 ^ 4 ==> 0 ^ 4 ==> 4



### 3、怎么把一个int类型的数，提取出最右侧的1(二进制)

例：    1100100

得到：0000100

求补运算：找到最近的1，后面的全部取反

那我们将 **a**与**求补后的a** 做**与运算**，就能得到结果，因为a[原]和a[补]在最近1后面的数都相反，在最近1前面的数都为0。

注意：因为在计算机中的运算都是以补码进行运算，所以上面的参与运算的a实际上是a[补]，对a[补]求补就是[-a]补，所以在编程上求补运算就是求相反数也等于 ~a + 1

```java
//正数
12
原码：0000 1100
补码：0000 1100
补码再求补：
     1111 0100 
原码：1000 1100  (十进制：-12)
即 ~12=-12
//负数
-12
原码：1000 1100
补码：1111 0100
补码再求补：
     0000 1100 
原码：0000 1100  (十进制：12)
即 ~12=12
```



### 4、一个数组中有两种数出现了奇数次，其它数均出现偶数次，找到并打印出这两种数

假设两种数分别为a，b

1、定义XOR1 == 0，对这批数连续异或赋值给XOR1，最后结果为XOR1 == a ^ b

又因为a != b (两种数) ，所以XOR1 != 0，==> XOR1的二进制数中肯定有1

2、我们随便取出XOR其中一个位置的1(比如取最右侧的1)定义为onlyOne

用该位置(onlyOne)是否为1**划分出两组数**，**目的是将a、b分离**，a、b必然不在同一组(因为在该位置异或为1)

```java
//用与运算判断，因为onlyOne只有一个1，所以与运算结果要么为0，要么不为0(具体值不确定)
if ((arr[i] & onlyOne) != 0)// 说明该位置有1
if ((arr[i] & onlyOne) == 0)// 说明该位置无1
```

3、再定义一个XOR2  == 0，对其中一组数连续异或赋值给XOR2，最终结果就为a或b

因为无论在哪一组数中除了a或b其余数都为偶数个

4、知道a或b其中一个了，XOR1 ^ XOR2 就是另一个数，如XOR2 == a,XOR1 ^ XOR2 == a ^ b ^ a == b  



### 5、一个数组中有一种数出现K次，其余数均出现M次且M > 1,K < M,找出出现K次的数

要求，空间复制度O(1)，时间复杂度O(N)

假设是int型的数(二进制32位)

1、开辟一个大小为32的count数组去存储该数组所有数二进制每一位的状态

即将所有数的二进制进行算术运算相加（例1+1=2），最终count每一位都记录着数组二进制和中对应位为1的次数

```java
arr：[18,10,10,11,11] K == 1,M == 2
10		00...001100
10		00...001100
11		00...001101
11		00...001101
18		00...010010
count  [00...014412]
```

就会发现count[i]%M == 0的位置18的二进制数必为0,因为是M的倍数，又K<M

所以只要count[i]%M != 0的位置18二进制数为1,我们把这些位置全找出来，所求数就确定了

2、如何存储

```java
//二重循环，将arr中每一个num的每一位依次累加到count数组
//虽然是两个for，但是内循环次数确定(32)，所以是O(N)
for (int num : arr) {
    for (int i = 0; i < 32; i++) {
	  /*if (((num >> i) & 1) != 0) { // 与1(00...001)进行与运算不等于0说明比较的第i位为1,就累加
              count[i]++;
		}*/
        // 优化版本 (count[i] >> i)为0的时候再与1 相当于+0 等于不累加
        count[i] += ((num >> i) & 1);
    }
}
```

3、把count数组还原为对应的值

就是将符合条件的位置上填1的过程

```java
int res = 0;
for (int i = 0; i < 32; i++) {
	if ((count[i] % m) != 0) { // 说明i位上 出现k次那个数的二进制数不为0(即为1)
		res |= (1 << i); // 0依次或上第i位上的1 从右至左在符合条件的位置上填1
	}
}
```



### 整数除法

#### 题目描述

[剑指 Offer II 001. 整数除法](https://leetcode.cn/problems/xoh6Oh/)

给定两个整数 `a` 和 `b` ，求它们的除法的商 `a/b` ，要求不得使用乘号 `'*'`、除号 `'/'` 以及求余符号 `'%'` 。

**注意：**

- 整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8` 以及 `truncate(-2.7335) = -2`
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 `[−2^31, 2^31−1]`。本题中，如果除法结果溢出，则返回 `2^31 − 1`



#### 题解

题目限制环境只能存储 32 位有符号整数，所以不能使用 long类型。

先对一些特殊情况进行处理。除法结果溢出只有一种可能：-2147483648 / -1，所以要进行特殊处理。



```java
public int divide(int a, int b) {
    if (b == 1) {
        return a;
    }
    if (b == -1) {
        // 溢出返回int正整数最大值 -2147483648 / -1 = 2147483647
        return a == Integer.MIN_VALUE ? Integer.MAX_VALUE : -a;
    }
    if (b == 0) {
        return 0;
    }

    // 结果符号 如果除数与被除数同符号 则为正 否则为负
    boolean isPlus = (a ^ b) >= 0; // 如果补码符号位不同异或为1 所以（a ^ b）为负数

    // 不能转化为正数运算，因为负最大数转成整数会溢出 例： -2147483648 / 2
    // 都转成负数运算
    a = a < 0 ? a : -a;
    b = b < 0 ? b : -b;
    int count = 0;
    // 负数运算所以a要小于等于b继续
    while (a <= b) {
        a -= b;
        count++;
    }
    return isPlus ? count : -count;
}
```

上面的代码虽然能通过，但是效率不是很高，因为如果被除数非常大，除数非常小，那就要进行很多次减法运算，有没有更简便的方法呢？效率不高是因为我们减法的步长太小，每次只能用1倍的除数去减被除数，所以速度比较慢。那能不能增大步长呢？如果能，应该怎么增大步长呢？

我们将步长改为 2的次方，一次性计算出能被减的最大值step

```java
public int divide(int a, int b) {
    if (b == 1) {
        return a;
    }
    if (b == -1) {
        return a == Integer.MIN_VALUE ? Integer.MAX_VALUE : -a;
    }
    if (b == 0) {
        return 0;
    }

    boolean isPlus = (a ^ b) >= 0; // 如果补码符号位不同异或为1 所以（a ^ b）为负数

    // 都转成负数运算
    a = a < 0 ? a : -a;
    b = b < 0 ? b : -b;
    int count = 0;
    while (a <= b) {
        int base = 1;
        int step = b;
        // 将步长改为 2的次方，一次性计算出能被减的最大值step
        // a <= 2 * step 转成减法 避免两个负数相加溢出
        while (a - step <= step) {
            step <<= 1; // 倍数增长 题目限制不能用乘法
            base <<= 1;
        }
        a -= step;
        count += base;
    }
    return isPlus ? count : -count;
}
```



### 二进制加法

#### 题目描述

[剑指 Offer II 002. 二进制加法](https://leetcode.cn/problems/JFETK5/)

给定两个 01 字符串 `a` 和 `b` ，请计算它们的和，并以二进制字符串的形式输出。

输入为 **非空** 字符串且只包含数字 `1` 和 `0`。

**示例 1:**

```
输入: a = "11", b = "10"
输出: "101"
```

**示例 2:**

```
输入: a = "1010", b = "1011"
输出: "10101"
```



#### 题解

```java
public String addBinary(String a, String b) {
    char[] charA = a.toCharArray();
    char[] charB = b.toCharArray();
    int carry = 0;
    StringBuilder str = new StringBuilder();
    for (int i = charA.length - 1, j = charB.length - 1; i >= 0 || j >= 0; ) {
        int numA = (i >= 0) ? charA[i--] - '0' : 0;
        int numB = (j >= 0) ? charB[j--] - '0' : 0;
        int sum = (numA + numB + carry) % 2;
        carry = (numA + numB + carry) / 2;
        str.insert(0, sum);
    }
    // 检查最后的进位
    if (carry == 1) {
        str.insert(0, 1);
    }
    return str.toString();
}
```



# 排序

## 快速排序

```
* 什么时候快排会退化：
* 单路快排：
1、完全有序：每次选的pivot都为最小值，递归深度为O(n)，引入随机化
2、所有元素相等 : 只分两个区间的问题 >= < ，优化为双路快排
3、对于双路排序，所有元素相等仍要对两边进行递归排序，这是没有必要的，再优化为三路快排
对于所有元素相等，三路快排时间优化为O
```

### 单路 partition

![image-20220419210057643](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419210057643.png)

![image-20220419160833639](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419160833639.png)

![image-20220419160856169](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419160856169.png)

![image-20220419160914168](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419160914168.png)

![image-20220419160949207](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419160949207.png)

![image-20220419161022328](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419161022328.png)



![image-20220419161124144](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419161124144.png)

**i 遍历完所有元素后，最后一步将 pivot 和 j 交换即完成一次 partition** 

![image-20220419161147470](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419161147470.png)



### 双路 partition

![image-20220419172212048](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419172212048.png)













### 时间复杂度分析

![image-20220419154657170](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419154657170.png)





![image-20220419154918400](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419154918400.png)



算法导论快排复杂度期望值有推导

![image-20220419155011683](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419155011683.png)





![image-20220419155304933](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419155304933.png)

### 三路 partition

![image-20220419162813984](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419162813984.png)



最后交换，区间定义有所改变

![image-20220419163000523](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419163000523.png)

![image-20220419162639513](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220419162639513.png)





## 比较器

实现Comparator< T>接口，调用系统一些容器的sort的函数时，把比较器传进去

```java
public static class IdAscendingComparator implements Comparator<Student> {
    // 返回负数的时候，第一个参数排在前面
    // 返回正数的时候，第二个参数排在前面
    // 返回0的时候，两个参数等级相等
    @Override
    public int compare(Student o1, Student o2) {
        //return o1.getId() - o2.getId();
        //return o2.getAge() -o1.getAge();
        // id升 如果id相等 比较age 降序
        return !o1.getId().equals(o2.getId()) ? o1.getId() - o2.getId() : o2.getAge() - o1.getAge();
    }
}
//
list.sort(new IdAscendingComparator());
Arrays.sort(students, new IdAscendingComparator());
```



## 归并排序

**平均时间复杂度： O(NLogN) **

**最好情况时间复杂度： O(NLogN)**

**最差情况时间复杂度： O(NLogN)**

**所需要额外空间： 递归：O(N + LogN)， 非递归：O（N）**

**稳定性： 稳定**

归并排序基于**分治**（快排也是）

归并排序其实要做两件事：

（1）“分解”——将序列每次折半划分。

（2）“合并”——将划分后的序列段两两合并后排序。



### 1、数组小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子
[1,3,4,2,5]
1左边比1小的数：0
3左边比3小的数：1
4左边比4小的数：1,3
2左边比2小的数：1
5左边比5小的数：1,3,4,2
所以小和为1+1+3+1+1+3+4+2=16

**转换思想：每一个数左边比当前数小的数累加-->如果a右边的数有多少个数比a大，就产生多少个a**

![image-20220126214210314](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220126214210314.png)

例 原数组[3,2,4,1,5,6,3,0]的归并过程：

我们从2这一个数的视角，来感受求该数小和的过程

- 步长为1：

  3,2是作为准备merge后的大组，而2作为里面的右组，是不会产生小和的，但2作为左组例[2,3]和[1,4]merge的时候才会去跟右组[1,4]比较产生小和

- 步长为2：

  [2,3]和[1,4]merge，此时2作为左组，与右组的数比较，有一个4比2大，产生一个2

- 步长为4：

  [1,2,3,4]和[0,3,5,6]merge，2作为左组，与右组的数比较，3、5、6都比2大，产生三个2

- 步长为8：归并结束，上述过程一共产生四个2，所以2右边一共是有四个数比2大的，需要累加四次2

**merge过程中p2移动的方向，如果是升序，p2就从左往右移动，比较一次的前提下才能知道有多少个数比a大**




### 2、数组中逆序对个数

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

同上面一道题，转换为**-->如果a右边的数有多少个数比a小，就产生多少个a**

不同的是p2移动的方向，如果是升序，p2就从右往左移动，比较一次的前提下才能知道有多少个数比a小

315（和本题一样）,327,493,



### 3、数组中x右边有多少个数*2后小于该元素的个数

求总个数

> 注意:这题看似和第二题没有什么区别，但是有个坑，第二题是直接比x小的个数，所以p1、p2指针是从右往左移动的，但是这题不可以，比如

![image-20220127160712721](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127160712721.png)



此时arr[p2] * 2  > arr[p1],我们希望p2继续像左检索寻找符合条件的数，但是又因为arr[p2]已经大于arr[p1]了，arr[p2]是要合并到mergeArr中的并且p1--，这种情况显然从右往左是不行的。

![image-20220127161006163](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127161006163.png)

解决方法一：从右往左

把记录题解的代码和merge的代码分离开，复制p1、p2指针，不要写在同一块里

```java
public static int merge(int[] arr, int L, int M, int R) {
    int[] mergeArr = new int[R - L + 1];
    int i = mergeArr.length - 1;
    int p1 = M;
    int p2 = R;
    int res = 0;
    int p3 = p1;
    int p4 = p2;
    // 记录题解
    while (p3 >= L && p4 > M) {
        if (arr[p3] > arr[p4] * 2) {
            res += p4 - M;
            p3--;
        } else {
            p4--;
        }
    }
    // 正常merge
    while (p1 >= L && p2 > M) {
        mergeArr[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
    }
    while (p1 >= L) {
        mergeArr[i--] = arr[p1--];
    }
    while (p2 > M) {
        mergeArr[i--] = arr[p2--];
    }
    for (i = 0; i < mergeArr.length; i++) {
        arr[L + i] = mergeArr[i];
    }
    return res;
}
```

解决方法二：从左往右

![image-20220127163807301](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127163807301.png)



从左往右，此时右边没有数 * 2 < arr[p1], 数量为0，p1右移至4，p2右移至arr[p2] * 2 不小于arr[p1]的地方，则满足条件的元素有p2 - M个

> p2是不用后退的，因为是升序，既然arr[p1] > arr[p2] * 2，所以有arr[p1 + n] > arr[p2] * 2 (n > 0)

![image-20220127164125900](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220127164125900.png)



### 总结

**指针不回退的本质就是单调性**

本质就是mergeSort过程把比较信息变成了有序的，从而加快我们求解

归并升序的情况：

数组中求x右边的情况：相等的时候merge过程就先拷贝右边的，因为我们是想知道x右边数的状况，所以我们需要先移动右组的指针

求右边多少个数比x小，就从右往左merge

求右边多少个数比x大，就从左往右merge



### 4、区间和的个数

[区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

前缀和+归并排序



> 注意：
>
> 前缀和头部插入值为 0 的元素，可简化边界处理
>
> 前缀和数组不是递增的，因为可能有负数

设区间和表示为Aij, 前缀和表示为Si

假设Sj已知

求以j位置结尾的子数组区间和有多少个落在[lower,uppper]上

==> lower <= Aij <= upper

==> lower <= Sj - Si-1 <= upper

==> Sj - upper <= Si-1 <= Sj - lower

因为i <= j （区间长度可以为1）

也就是说我们只需要求在j之前有多少个前缀和落在这个区间上

所以现在我们只需要用到前缀和数组，原数组已经没有用了



## 快速排序

注意边界问题

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    process(arr, 0, arr.length - 1);
}
public static void process(int[] arr, int L, int R) {
    // 注意边界i 有可能跨过去右边
    if (L >= R) {
        return;
    }
    int i = L - 1;
    int j = R + 1;
    int pivot = arr[L + ((R - L) >> 1)];
    while (i < j) {
        do i++; while (arr[i] < pivot);
        do j--; while (arr[j] > pivot);
        if (i < j) {
            swap(arr, i, j);
        }
    }
    // 因为i可能先跨过去,因为do是i操作先 所以跨过去的i位置是没有验证的
    // 而j++是后do的 退出while时j的位置一定是被验证过的
    // 左递归只能穿[L i-1] 或者[L   j]
    // 右递归只能传[i   R] 或者[j+1 R]
    process(arr, L, j);
    process(arr, j+1, R);
}
```



## 堆排序

**堆（优先队列）：**

大根堆：满足根结点>子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

小根堆：满足根结点<子结点，总是最大的(**并且在堆的每一个局部都是如此**)的完全二叉树

完全二叉树：

> **i 结点的左孩子：2 * i + 1，i 结点的右孩子2 * i+2 ，i 结点的父结点 (i - 1)/2 下取整**



**建堆**

如果数据是一次传进来的，可以从下往上建堆，建堆的时间复杂度是可以达到O(N)的

> 分析一下复杂度，因为堆的叶子结点有N / 2个，叶子结点的下沉成本距离为1,只会进行一次while判断,
>
> 叶子结点的上一层有N / 4 个，下沉成本为2，以此类推，下沉成本和深度有关,设有4层
>
> 总下沉成本T(N) = N/2 * 1 + N/4 * 2 + N/8 * 3 + N/16 * 4
>
> ​          2T(N) = N + N/2 * 2 + N/4 * 3 + N/8 * 4
>
> 相减=>T(N) = N + N/2  + N/4  ...  - N/16 显然时间复杂度为O(N)

```java
for (int i = arr.length - 1; i >= 0; i--) {
    // 从下往上建堆 不断调用heapify调整下沉
	heapify(arr, i, arr.length);
}
```



如果数据是一个一个传进来的，只能从上往下建堆，时间复制度O(N*logN)

```java
for (int i = 0; i < arr.length; i++) {
    // 从上往下建堆 不断调用heapInsert调整上浮
	heapInsert(arr, i);
}
```



**维护堆**

堆排序

堆排序额外空间复杂度O(1)

排序过程O(N*logN)

```java
public static void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 建堆的过程
    /*// 从上往下建堆 逐个读入O(logN)
    for (int i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }*/
    // 从下往上建堆 一次读入 O(N)
    for (int i = arr.length - 1; i >= 0; i--) {
        heapify(arr, i, arr.length);
    }
    int heapSize = arr.length;
    
    // 堆排序的过程 靠首尾交换取得最大值从而手动打乱堆 再调用heapify来不断维护 不断获得最值
    swap(arr, 0, --heapSize);
    while (heapSize > 0) {
        heapify(arr, 0, heapSize);
        // 交换后堆大小减一 是逻辑删除该值
        swap(arr, 0, --heapSize);
    }
}
```



### 1、对一个几乎有序的数组进行排序

几乎有序是指，如果把数组排好序，每个元素师移动的距离一定不超过k，并且k大小相对数组长度是较小的，设置合适的排序策略。

使用长度为k + 1的堆来维护存放每个位置上可能出现的元素

例如设k = 5，排序后索引为0的位置的元素只可能是原数组中索引为[0-5]的位置

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
    if (k == 0) {
        return;
    }
    // 默认小根堆
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    int index = 0;
    // k如果大于数组长度，则都放进堆里
    // 先放k + 1个数进入堆
    for (; index < Math.min(arr.length, k); index++) {
        heap.add(arr[index]);
    }
    int i = 0;
    // 弹出堆顶 放入一个 直到数组中所以元素都进入到堆中
    for (; index < arr.length; i++, index++) {
        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    // 弹出堆中所有元素
    while (!heap.isEmpty()) {
        arr[i++] = heap.poll();
    }
}
```



### 2、最大线段重合问题

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

类似[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)



定义：一条线段尾坐标 == 另一条线段头坐标不算有交集(只有一个点重合)

两条不同线段，如果一条线段尾坐标  > 另一条线段头坐标，说明这两条线段有交集

1、将所有线段按头坐标从小到大排序

**借助小根堆存储线段的尾坐标**

2、从小到大遍历每条线段，比较**遍历到的线段**和**小根堆内的尾坐标**，**将小根堆中 <= 该线段的头坐标移除**(说明当前线段与移除的掉的线段没有交集)，**小根堆剩下的尾坐标个数就为与该线段有交集的个数（除去本身）**，**切换到下一线段前，将自身尾坐标加入小根堆**

> 如果求的是有多少条线段重合，则先把自身加入，小根堆的当前的个数就是有多少条线段重合



# 数组

关于循环不变量

- 循环不变量即：在循环开始之前、循环的过程中、循环结束以后，变量的定义保持不变；
- 也可以简单地理解为：**保持定义不变**；
- 这是一条非常基本的编程准则，是我们「心中有，口中无」的东西。





```java
public int binarySearch(int[] arr, int target) {
    // 定义在[l, r]里寻找target
	int l = 0;
	int r = arr.lenght - 1;
	while (l <= r) { // 至少有一个数 如果是l < r 至少有两个数，最后还有判断一下arr[l]或arr[r] == target
		int mid = l + ((r - l) >> 1);
		if (arr[mid] == target) {
			return mid;
		} else if (arr[mid] > target) {
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}
	return -1;
}
```



```java
public int binarySearch(int[] arr, int target) {
    // 定义在[l, r)里寻找target
	int l = 0;
	int r = arr.lenght;
	while (l < r) { // 此时只能是小于号 因为取等的话这个区间是没有意义的 比如 [10, 10)这个区间
		int mid = l + ((r - l) >> 1);
		if (arr[mid] == target) {
			return mid;
		} else if (arr[mid] > target) {
			r = mid; // 这里不用-1  因为[l, mid) 已经不会选到mid这个数
		} else {
			l = mid + 1;
		}
	}
	return -1;
}
```



### 移动零

#### 题目描述

[LeetCode283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 **提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

**进阶：**你能尽量减少完成的操作次数吗？

#### 题解

**双指针**

解法一：

```java
// 双指针交换 循环不变量k来维护一个不为零的区间[0, k)
public void moveZeroes(int[] nums) {
    int k = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            // 判断 i 是否大于 k 可以减少无用的交换
            if (i > k) {
                nums[k++] = nums[i];
                nums[i] = 0;
            } else {
                k++;
            }
        }
    }
}
```



解法二：

```java
// 双指针覆盖
public void moveZeroes(int[] nums) {
    int k = 0;
    // 覆盖前面的值
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            nums[k++] = nums[i];
        }
    }
    // 把后面的0补上
    for (int i = k; i < nums.length; i++) {
        nums[i] = 0;
    }
}
```



### 移除元素

#### 题目描述

[LeetCode27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



#### 题解

**双指针**

```java
public int removeElement(int[] nums, int val) {
    int k = 0;
    // 定义：维护一个不含val的区间[0, k) 
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != val) {
            if (i > k) { // 减少无效操作
                nums[k++] = nums[i];  
            } else {
                k++;
            }
        }
    }
    return k;
}
```



### 删除有序数组中的重复项

#### 题目描述

[LeetCode26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。



#### 题解

```java
public int removeDuplicates(int[] nums) {
    // 定义：维护一个[0, k) 每个元素 最多出现两次的升序数组
    // 那么nums[k - 2]就是前两个元素，只需要判断枚举nums[i]是否和nums[k - 2]是否相等即可
    int k = 0;
    for (int i = 0; i < nums.length; i++) {
        if (k < 2 || nums[i] != nums[k - 2]) {
            nums[k++] = nums[i];
        }
    }
    return k;
}
```



### 删除有序数组中的重复项 II

#### 题目描述

[LeetCode80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。



#### 题解

从前面几道题可以看出，明确变量的定义很重要

```java
public int removeDuplicates(int[] nums) {
    // 定义：维护一个[0, k) 每个元素 最多出现两次的升序数组
    // 那么nums[k - 2]就是前两个元素，只需要判断枚举nums[i]是否和nums[k - 2]是否相等即可
    int k = 0;
    for (int i = 0; i < nums.length; i++) {
        // 但元素个数小于等于2个不用考虑
        if (k < 2 || nums[i] != nums[k - 2]) {
            nums[k++] = nums[i];
        }
    }
    return k;
}
```

**通解：「最多保留 1 位」修改为「最多保留 n 位」**

```java
public int removeDuplicates(int[] nums, int n) {
    // 定义：维护一个[0, k) 每个元素 最多出现n次的升序数组
    // 那么nums[k - n]就是前两个元素，只需要判断枚举nums[i]是否和nums[k - n]是否相等即可
    int k = 0;
    for (int i = 0; i < nums.length; i++) {
        // 但元素个数小于等于2个不用考虑
        if (k < n || nums[i] != nums[k - n]) {
            nums[k++] = nums[i];
        }
    }
    return k;
}
```



### 颜色分类

#### 题目描述

[LeetCode75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。



必须在不使用库的sort函数的情况下解决这个问题。

#### 题解

**计数排序**

对于元素个数非常有限的情况，扫描一遍数组，记录下元素对应的元素个数，最后从新赋值就好了





**三路快排**

![image-20220417220214749](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220417220214749.png)

重点是设计循环不变量

维护好区间的定义，开区间或者闭区间都无所谓，重点是正确维护

枚举每一个 $e$

当 $e$ 为 $1$ 时，直接 $i++$

当 $e$ 为 $2$ 时，交换 $++two$ 和 $i$ 的值，交换后 $i$ 不能更改，因为交换后 $i$ 处的值不确定

当 $e$ 为 $1$ 时，交换 $++zero$ 和 $i$ 的值，交换后 $i++$，因为区间 $[zero + 1, i - 1]$ 值都为 $1$，这是确定的

```java
public void sortColors2(int[] nums) {
    // 维护区间[0, zero]都为0
    int zero = -1;
    // 维护区间[two, n - 1]都为2
    int two = nums.length;

    for (int i = 0; i < two; ) {
        if (nums[i] == 1) {
            i++;
        } else if (nums[i] == 2) {
            swap(nums, --two, i);
        } else if (nums[i] == 0) {
            swap(nums, ++zero, i++);
        }
    }
}

private void swap (int[] nums, int i, int j) {
    nums[i] = nums[i] + nums[j];
    nums[j] = nums[i] - nums[j];
    nums[i] = nums[i] - nums[j];
}
```



### Select K 问题

#### 题目描述

求解整个数组的第 $k$ 小元素并返回。

不使用排序完成。

#### 题解

利用快排 $partition$ 的思想，每一次 $partition$ 后返回的索引值 $p$ 就为 $nums[p]$ 在数组的位置，我们借助这一思想可以降低时间复杂度快速求出一个数组中第 $K$ 大 / 小的数。

由于 $partition$ 是一个随机算法，分析其期望，第一次 $partition$ 会扫描整个数组长度 $n$，$partition$ 之后分出来的两个区间长度从数学期望的角度上看的是相等的。

所以所有的 partition 所扫描的范围是：$ n + \frac{n}{2} + \frac{n}{4} + ...+\frac{n}{+\infty}$

时间复制度为：$O(2n) = O(n)$



有了 `partition`，我们的 `selectK` 的逻辑非常简单。

首先，进行 `partition`，假设结果是 `p`。我们只需要将 `k` 和 `p` 做比较。

- 如果 `k == p`，直接返回 `arr[p]` 即可；
- 如果 `k < p`，在 `nums[l, p - 1]` 的范围继续找，即调用 `selectK(nums, l, p - 1, k)`；
- 如果 `k > p`，在 `nums[p + 1, r]` 的范围继续找，即调用 `selectK(nums, p + 1, r, k)`；



```java
public int selectK(int[] nums, int l, int r, int k) {
    int p = partition(nums, l, r);
    if (k == p) return nums[p];
    return (k > p) ? selectK(nums, l, p - 1, k) : selectK(nums, p + 1, r, k);
}

private Random random = new Random();

private int partition(int[] nums, int l, int r) {
    int p = l + random.nextInt(r - l + 1);
    swap(nums, l, p);
    int pivot = nums[l];
    int i = l, j = r + 1;
    while (i < j) {
        do i++; while (i < r && nums[i] < pivot);
        do j--; while (j > l && nums[i] > pivot);
        if (i < j) swap(nums, i, j);
    }

    swap(nums, l, j);
    return j;
}
```

下面，我们用我们写的 `selectK`，先来解决 Leetcode 上第 215 号问题：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/



### 数组中的第 K 个最大元素

#### 题目描述

[LeetCode215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

 

#### 题解

这个问题是求第 `k` 大元素，但是我们的 `selectK` 求得是第 `k` 小元素。怎么办？

非常简单，我们只需要在调用 `selectK` 之前，将求第 `k` 大元素的这个 `k`，转换成对应求的是第几小元素对应的索引就好了。

按照题目描述，如果 `k` 是 `1`，对应就是要找最大元素，那么相应的我们的 `selectK` 的索引，就是 `nums.length - 1`。

如果 `k` 是 `nums.length`，其实就是求最小元素，那么那么相应的我们的 `selectK` 的索引，就是 `0`。

他们之间的转换关系是 `nums.length - k`。

所以，对于这个问题，我们的代码是这样的：

```java
public int findKthLargest(int[] nums, int k) {
    return selectK(nums, 0, nums.length - 1, nums.length - k);
}
```

只有两行，其他的内容全部复用我们上面实现的 `selectK`。

完整代码：

```java
public int findKthLargest(int[] nums, int k) {
    return selectK(nums, 0, nums.length - 1, nums.length - k);
}

public int selectK(int[] nums, int l, int r, int k) {
    int p = partition(nums, l, r);
    if (k == p) return nums[p];
    return (p > k) ? selectK(nums, l, p - 1, k) : selectK(nums, p + 1, r, k);
}

private Random random = new Random();

private int partition(int[] nums, int l, int r) {
    int p = l + random.nextInt(r - l + 1);
    swap(nums, l, p);
    int pivot = nums[l];
    int i = l, j = r + 1;
    while (i < j) {
        do i++; while (i < r && nums[i] < pivot);
        do j--; while (j > l && nums[j] > pivot);
        if (i < j) swap(nums, i, j);
    }

    swap(nums, l, j);
    return j;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

下面，我们解决《剑指 Offer》上的 40 号问题，最小的k个数：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/

### 最小的k个数

#### 题目描述

[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。



#### 题解

对于这个问题，我们只要使用上面的 `selectK`，找到第 `k` 小的数。然后，`selectK` 的过程由于调用了 `partiton`，所以会调整整个数组的内容。此时，这个第 `k` 小的数的前面所有元素，就是整个数组最小的 `k` 个数字了。

这里要注意，我们求的第 `k` 小的数字，对应的索引是 `k - 1`，所以我们调用 `selectK` 的时候，需要传入的索引参数是 `k - 1`。

另外，对于这个问题，`k` 可能取 `0`，此时，我们不需要执行 `selectK`，直接返回一个含有 `0` 个元素的 `int[]` 就好了。

具体过程如下：

```java
public int[] getLeastNumbers(int[] arr, int k) {
    // 注意合法数据
    if (k == 0 || k > arr.length) {
        return new int[0]; 
    }
    return selectK(arr, 0, arr.length - 1, k - 1);
}

public int[] selectK(int[] nums, int l, int r, int k) {
    int p = partition(nums, l, r);
    if (k == p) return Arrays.copyOf(nums, k + 1); // k为索引 返回前个k + 1个元素
    return (p > k) ? selectK(nums, l, p - 1, k) : selectK(nums, p + 1, r, k);
}
private Random random = new Random();

private int partition(int[] nums, int l, int r) {
    int p = l + random.nextInt(r - l + 1);
    swap(nums, l, p);
    int pivot = nums[l];
    int i = l, j = r + 1;
    while (i < j) {
        do i++; while (i < r && nums[i] < pivot);
        do j--; while (j > l && nums[j] > pivot);
        if (i < j) swap(nums, i, j);
    }

    swap(nums, l, j);
    return j;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```



### 合并两个有序数组

#### 题目描述

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。



#### 题解

**常规归并**

```java
// 传统归并 从前往后合并
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int[] mergeArr = new int[m];
    int i = 0;
    int p1 = 0;
    int p2 = 0;
    while (p1 < m && p2 < n) {
        mergeArr[i++] = (nums1[p1] <= nums2[p2] ? nums1[p1++] : nums2[p2++]);
    }
    while (p1 < m) {
        mergeArr[i++] = nums1[p1++];
    }
    while (p2 < n) {
        mergeArr[i++] = nums2[p2++];
    }
    // 将合并后的数组复制回nums1
    System.arraycopy(mergeArr, 0, nums1, 0, m);
}
```



**逆序归并**

```java
// 因为题目给的nums1的特殊性，我们可以从后往前合并 就不用额外的空间 直接在num1上进行合并
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = m - 1;
    int p2 = n - 1;
    int tail = m + n - 1; // nums1数组的尾指针
    while (p1 >= 0 && p2 >= 0) {
        nums1[tail--] = (nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--]);
    }
    while (p1 >= 0) {
        nums1[tail--] = nums1[p1--];
    }
    while (p2 >= 0) {
        nums1[tail--] = nums2[p2--];
    }
}
```



# 哈希表

### 两个数组的交集 II

#### 题目描述

[LeetCode350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

 **提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

 **进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
- 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？



#### 题解

**纯List**

自己实现List的删除给定元素

总时间复杂度`O(n^2)`

```java
public int[] intersect(int[] nums1, int[] nums2) {
    List<Integer> list = new ArrayList<>();
    List<Integer> res = new ArrayList<>();
    for (int x : nums1) {
        list.add(x);
    }
    for (int x : nums2) {
        if (list.contains(x)) {
            remove(list, x);
            res.add(x);
        }
    }

    return res.stream().mapToInt(Integer::intValue).toArray();
}

// list删除指定元素 注意要逆序遍历 避免删除后长度发生变化引起越界
private void remove(List<Integer> list, int val) {
    for (int i = list.size() - 1; i >= 0; i--) {
        if (list.get(i) == val) {
            list.remove(i);
            // 题目要求 一次删除一个
            break;
        }
    }
}
```



**哈希表**

时间复杂度`O(m + n)`

```java
public int[] intersect2(int[] nums1, int[] nums2) {
    // nums中元素可以重复 所以次数有意义 可以用map
    Map<Integer, Integer> map = new HashMap<>();
    List<Integer> list = new ArrayList<>();
    for (int x : nums1) {
        map.put(x, map.getOrDefault(x, 0) + 1);
    }
    for (int x : nums2) {
        if (map.containsKey(x) && map.get(x) > 0) {
            // 用掉一次，减一
            map.put(x, map.get(x) - 1);
            list.add(x);
        }
    }
    return list.stream().mapToInt(Integer::intValue).toArray();
}
```



**排序+双指针**

如果给定数组已经有序，则可以使用双指针来优化

哪个指针所指向的值小，则指针++，若相等则加入结果集

```java
public int[] intersect(int[] nums1, int[] nums2) {
    // 假定已经排好序
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int i = 0;
    int j = 0;
    List<Integer> res = new ArrayList<>();
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] == nums2[j]) {
            res.add(nums1[i]);
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    
    return res.stream().mapToInt(Integer::intValue).toArray();
}
```



**归并外排**

对于大量数据来说，数据太大而无法全部都将数据加载到内存中，这时候就需要外排序。



### 有效的字母异位词

#### 题目描述

[LeetCode242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

 **示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

 

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？



#### 题解

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    // 给定字符串会有重复，与次数有关，使用map
    Map<Character, Integer> map = new HashMap<>();
    char[] arr1 = s.toCharArray();
    char[] arr2 = t.toCharArray();
    boolean flag = true;
    for (char c : arr1) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    for (char c : arr2) {
        if (map.containsKey(c) && map.get(c) > 0) {
            // 用掉一次比较 减一
            map.put(c, map.get(c) - 1);
        } else {
            flag = false;
            break;
        }
    }
    return flag;
}
```



### 快乐数

#### 题目描述

[LeetCode202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```



#### 题解

为什么出现重复的数就说明循环，这里证明了https://leetcode-cn.com/problems/happy-number/solution/kuai-le-de-zhi-shi-dian-zeng-jia-liao-by-sweetiee/

```java
public boolean isHappy(int n) {
    boolean isHappy = true;
    Set<Integer> set = new HashSet<>();

    while (n != 1) {
        if (set.contains(n)) {
            isHappy = false;
            break;
        }
        set.add(n);
        int nextN = 0;
        // 经典取每一个位置上的数字
        while (n != 0) {
            // 取个位数
            int one = n % 10;
            nextN += (one * one);
            n /= 10;
        }
        n = nextN;
    }

    return isHappy;
}
```



### 单词规律

#### 题目描述

[LeetCode290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
```

 

#### 题解

这题关键在与pattern和words是双向映射的，键和值是共存亡并且一一对应的，如果没有这种关系则不符合规律

```java
public boolean wordPattern(String pattern, String s) {
    String[] words = s.split(" ");
    if (words.length != pattern.length()) {
        return false;
    }
    char[] keys = pattern.toCharArray();
    Map<Character, String> map = new HashMap<>();
    Set<String> set = new HashSet<>();
    // 这题关键在与pattern和words是双向映射的，键和值是共存亡并且一一对应的
    for (int i = 0; i < keys.length; i++) {
        if (map.containsKey(keys[i])) {
            // 判断一一对应关系
            if (!map.get(keys[i]).equals(words[i])) {
                return false;
            }
        } else {
            // 判断共存亡关系 不可能出现 没有键却set中已经出现这个键对应的值 这种情况
            if (set.contains(words[i])) {
                return false;
            }
            map.put(keys[i], words[i]);
            set.add(words[i]);
        }
    }
    return true;
}
```



### 同构字符串

#### 题目描述

[LeetCode205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

**示例 3：**

```
输入：s = "paper", t = "title"
输出：true
```



#### 题解

```java
// 这题解法和202单词规律一样
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    char[] keys = s.toCharArray();
    char[] values = t.toCharArray();
    Map<Character, Character> map = new HashMap<>();
    Set<Character> set = new HashSet<>();
    for (int i = 0; i < keys.length; i++) {
        if (map.containsKey(keys[i])) {
            if (map.get(keys[i]) != values[i]) {
                return false;
            }
        } else {
            if (set.contains(values[i])) {
                return false;
            }
            set.add(values[i]);
            map.put(keys[i], values[i]);
        }
    }
    return true;
}
```



### 根据字符出现频率排序

#### 题目描述



#### 题解

**模拟**

```java
public String frequencySort(String s) {
    char[] c = s.toCharArray();
    int[][] count = new int[128][2];
    StringBuilder str = new StringBuilder();
    // 第一维记录下原来的索引，因为后面排序会导致位置发生变化
    for (int i = 0; i < 128; i++) {
        count[i][0] = i;
    }
    // 第二维记录数量
    for (int i = 0; i < c.length; i++) {
        count[c[i]][1]++;
    }
    Arrays.sort(count, (o1, o2)-> o2[1] - o1[1]);
    for (int i = 0; i < 128; i++) {
        // 每一个字符的数量
        int n = count[i][1];
        while (n-- > 0) {
            str.append((char)count[i][0]);
        }
    }
    return str.toString();
}
```



**哈希表+优先队列**

```java
class Node {
    char c;
    int num;
    Node(char c, int num) {
        this.c = c;
        this.num = num;
    }
}
public String frequencySort2(String s) {
    char[] chars = s.toCharArray();
    Map<Character, Integer> map = new HashMap<>();
    StringBuilder str = new StringBuilder();
    PriorityQueue<Node> maxHeap = new PriorityQueue<>(((o1, o2) -> {
        if (o1.num == o2.num) {
            // 如果添加条件 数量一致按字典序
            return o2.c - o1.c;
        } else {
            return o2.num - o1.num;
        }
    }));
    for (int i = 0; i < chars.length; i++) {
        map.put(chars[i], map.getOrDefault(chars[i], 0) + 1);
    }
    for (char c : map.keySet()) {
        maxHeap.add(new Node(c, map.get(c)));
    }

    while (!maxHeap.isEmpty()) {
        Node node = maxHeap.poll();
        int n = node.num;
        while (n-- > 0) {
            str.append(node.c);
        }
    }

    return str.toString();
}
```



### 字母异位词分组

#### 题目描述

[LeetCode49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

 **提示：**

- `1 <= strs.length <= 104`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母



#### 题解

技巧：异位词排序后一定相等，按这个分组

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        char[] chars = str.toCharArray();
        // 字母异位词排序后字符位置必然相等 所以当key
        Arrays.sort(chars);
        String key = new String(chars);
        // 如果有该key对应的list 则将str加入list中
        List<String> list = map.getOrDefault(key, new ArrayList<>());
        list.add(str);
        map.put(key, list);
    }
    return new ArrayList<>(map.values());
}
```



### 回旋镖的数量

#### 题目描述

[LeetCode447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)

给定平面上 `n` 对 **互不相同** 的点 `points` ，其中 `points[i] = [xi, yi]` 。**回旋镖** 是由点 `(i, j, k)` 表示的元组 ，其中 `i` 和 `j` 之间的距离和 `i` 和 `k` 之间的欧式距离相等（**需要考虑元组的顺序**）。

返回平面上所有回旋镖的数量。

**示例 1：**

```
输入：points = [[0,0],[1,0],[2,0]]
输出：2
解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
```

**示例 2：**

```
输入：points = [[1,1],[2,2],[3,3]]
输出：2
```

**示例 3：**

```
输入：points = [[1,1]]
输出：0
```

 

#### 题解

**暴力枚举**

```java
public int numberOfBoomerangs(int[][] points) {
    int res = 0;
    for (int i = 0; i < points.length; i++) {
        for (int j = 0; j < points.length; j++) {
            if (j == i) continue;
            for (int k = 0; k < points.length; k++) {
                if (k == j || k == i) continue;
                double x = Math.pow(points[j][0] - points[i][0], 2) + Math.pow(points[j][1] - points[i][1], 2);
                double y = Math.pow(points[k][0] - points[i][0], 2) + Math.pow(points[k][1] - points[i][1], 2);
                if (x == y) {
                    res++;
                }
            }
        }
    }
    return res;
}
```



**哈希表**

```java
public int numberOfBoomerangs2(int[][] points) {
    int res = 0;
    // 对于每一个点point[i] 枚举其他点到point[i]的距离，将距离放入哈希表中 key=距离 value为与point[i]相距distance的点的个数
    for (int i = 0; i < points.length; i++) {
        // 注意对于每个点都是新的map
        Map<Integer, Integer> map = new HashMap<>();
        // 存入数据
        for (int j = 0; j < points.length; j++) {
            if (j != i) {
                int distance = (int) getDistance(points[i], points[j]);
                map.put(distance, map.getOrDefault(distance, 0) + 1);
            }
        }

        // 查表
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int count = entry.getValue();
            // 能否找到至少有两个点与point[i]有相同的距离，才能构成回旋镖
            if (count >= 2) {
                // 考虑顺序所以是排列 An2 从count中选两个点出来排列
                res += count * (count - 1);
            }
        }
    }

    return res;
}
```



# 双指针

### 两数之和

#### 题目描述

[LeetCode1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 **提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？



#### 题解

**暴力枚举**

```java
public int[] twoSum(int[] nums, int target) {
	int[] res = new int[2];
	for (int i = 0; i < nums.length; i++) {
		for (int j = i + 1; j < nums.length; j++) {
			if (target == nums[i] + nums[j]) {
				res[0] = i;
				res[1] = j;
			}
		}
	}
	return res;
}
```



**排序+双指针**

时间复杂度：$O(nlogn) + O(n)$

```java
// 指针对撞
public int[] twoSum(int[] nums, int target) {
    // 第二维记录原始位置
    int[][] arr = new int[nums.length][2];
    for (int i = 0; i < nums.length; i++) {
        arr[i][0] = nums[i];
        arr[i][1] = i;
    }
    // 排序后使用双指针
    Arrays.sort(arr, (o1, o2) -> o1[0] - o2[0]);
    int left = 0;
    int right = arr.length - 1;
    int[] res = new int[2];
    while (left < right) {
        if (arr[left][0] + arr[right][0] == target) {
            res[0] = left;
            res[1] = right;
            break;
        } else if (arr[left][0] + arr[right][0] > target) {
            right--;
        } else {
            left++;
        }
    }
    return res;
}
```



**哈希表**

时间复杂度：$ O(n) $

将所有元素都存入哈希表，之后对于每一个元素 $ num[i] $ ，查找表中是否存在 $ target - nums[i]$ 即可，若存在则记录索引。

所以使用 Map 结构。

但是这样做有一个问题，若所给数组中存在重复数字，而 $target$ 恰好能由这两个重复的数字组合成，但是由于哈希表中不能存在重复的 $ key $ 值，所以没有办法求到答案。所以不能将数组一次性都放入哈希表中再查找，而是边放入表中边查找，这样就能避免查找不到重复的数字。

```java
// 哈希表
public int[] twoSum2(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    int[] res = new int[2];
    // 注意为什么不能一次先将数都放入哈希表中 因为所给数组可能会有重复的数字会被覆盖
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            res[0] = i;
            res[1] = map.get(complement);
            break;
        }
        map.put(nums[i], i);
    }
    return res;
}
```

 

### 三数之和

#### 题目描述

[LeetCode15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

 **提示：**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



#### 题解

**回溯**

经典组合问题

dfs 超时

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> threeSum(int[] nums) {
    used = new boolean[nums.length];
    Arrays.sort(nums);
    dfs(0, nums, 0);
    return res;
}

private void dfs(int target, int[] nums, int index) {
    if (path.size() == 3) {
        if (target == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }

    for (int i = index; i < nums.length; i++) {
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }

        path.add(nums[i]);
        used[i] = true;
        dfs(target - nums[i], nums, i + 1);
        path.remove(path.size() - 1);
        used[i] = false;
    }
}
```



**暴力枚举**

超时

```java
public List<List<Integer>> threeSum2(int[] nums) {
    Set<List<Integer>> set = new HashSet<>();
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            for (int k = j + 1; k < nums.length; k++) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    List<Integer> path = new ArrayList<>();
                    path.add(nums[i]);
                    path.add(nums[j]);
                    path.add(nums[k]);
                    set.add(new ArrayList<>(path));
                }
            }
        }
    }
    return new ArrayList<>(set);
}
```



**排序+双指针**

时间复杂度：$ O(n ^ 2) $

```java
// 排序+双指针
public List<List<Integer>> threeSum3(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    // 将问题转化为twoSum
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            // 因为已升序，nums[i] > 0 而后面的数是大于等于nums[i]的 所以加起来必然大于零
            break;
        }
        // 去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        // 退化为求两数之和
        int target = 0 - nums[i];
        int left = i + 1;
        int right = nums.length - 1;
        while (left < right) {
            if (nums[left] + nums[right] == target) {
                res.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                // 关键：去重 找到指向值不等的指针
                // 比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, left = 1, right = 6
                // [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3
                left++;
                right--;
                while (left < right && nums[left] == nums[left - 1]) left++;
                while (left < right && nums[right] == nums[right + 1]) right--;
            } else if (nums[left] + nums[right] > target) {
                right--;
            } else {
                left++;
            }
        }
    }
    return res;
}
```



**哈希表**

用哈希表去重比较复杂

```java
// 哈希表
public List<List<Integer>> threeSum4(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            break;
        }
        // a去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        Set<Integer> set = new HashSet<>();
        for (int j = i + 1; j < nums.length; j++) {
            if (j > i + 2 && nums[j] == nums[j - 1] && nums[j - 1] == nums[j - 2]) {
                //b去重，发生重复是第一个nums[j-2]已经insert到set中了，nums[j-1]用于判断c是否等于0（此时可能已经push到结果中了），而nums[i]我们已经用不到了，所以跳过
                continue;
            }
            int target = 0 - (nums[i] + nums[j]);
            if (set.contains(target)) {
                res.add(new ArrayList<>(Arrays.asList(nums[i], nums[j], target)));
                // c去重
                set.remove(target);
            } else {
                set.add(nums[j]);
            }
        }
    }
    return res;
}
```



### 四数之和

#### 题目描述

[LeetCode18. 四数之和](https://leetcode-cn.com/problems/4sum/)

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

 

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

 **提示：**

- `1 <= nums.length <= 200`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`



#### 题解

**回溯**

数据量比较少，可以过

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> fourSum(int[] nums, int target) {
    used = new boolean[nums.length];
    Arrays.sort(nums);
    dfs(target, nums, 0);
    return res;
}

private void dfs(int target, int[] nums, int index) {
    if (path.size() == 4) {
        if (target == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }

    for (int i = index; i < nums.length; i++) {
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }

        path.add(nums[i]);
        used[i] = true;
        dfs(target - nums[i], nums, i + 1);
        path.remove(path.size() - 1);
        used[i] = false;
    }
}
```



**排序+双指针**

剪枝不是必要的

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 3; i++) {
        // a去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.length - 2; j++) {
            // b去重
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }
            // 可以进行剪枝
            // 获取当前最小值,如果最小值比目标值大 直接break
            // nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target
            if (nums[i] + nums[i + 1] > target - nums[i + 2] - nums[i + 3]) {
                break;
            }
            // 获取当前最大值,如果最大值比目标值小，该次循环必然找不到
            // nums[i] + nums[nums.length - 3] + nums[nums.length - 2] + nums[nums.length - 1] < target
            if (nums[i] + nums[nums.length - 3] < target - nums[nums.length - 2] - nums[nums.length - 1]) {
                continue; // 跳过该次循环，更换更大的nums[i]
            }

            // 退化为twoSum
            int left = j + 1;
            int right = nums.length - 1;
            while (left < right) {
                // 减法避免溢出 或者使用long
                if (nums[i] + nums[j] == target - nums[left] - nums[right]) {
                    res.add(new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[left], nums[right])));
                    // c、d去重
                    left++;
                    right--;
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (nums[i] + nums[j] > target - nums[left] - nums[right]) {
                    right--;
                } else {
                    left++;
                }
            }
        }
    }
    return res;
}
```



### 最接近的三数之和

#### 题目描述

[LeetCode16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

 

**示例 1：**

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**示例 2：**

```
输入：nums = [0,0,0], target = 1
输出：0
```

 **提示：**

- `3 <= nums.length <= 1000`
- `-1000 <= nums[i] <= 1000`
- `-104 <= target <= 104`

#### 题解

```java
public int threeSumClosest(int[] nums, int target) {
    int res = nums[0] + nums[1] + nums[2]; // 题目保证至少有三个数据
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        int left = i + 1;
        int right = nums.length - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (Math.abs(sum - target) < Math.abs(res - target)) {
                res = sum; // 如果有比res更接近的则覆盖
                if (sum == target) break;
            }
            // 注意去重为什么要写在下面而不是上面，因为上面的if执行完不一定是相等，还可能会执行下面的if，不像之前是else if
            // 所以要先判断大小关系，再移动指针，之前的是已经确定是相等，所以直接移动指针
            if (sum > target) {
                right--;
                while (left < right && nums[right] == nums[right + 1]) right--;
            } else {
                left++;
                while (left < right && nums[left] == nums[left - 1]) left++;
            }
        }
    }
    return res;
}
```



### 四数相加 II

#### 题目描述

[LeetCode454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

 

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

 

 **提示：**

- `n == nums1.length`
- `n == nums2.length`
- `n == nums3.length`
- `n == nums4.length`
- `1 <= n <= 200`
- `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`



#### 题解

之前的题目求和都是一维的数组, 同时它们都要求找到 不重复 的元组, 这就限制了我们不能简单的使用哈希表进行去重操作, 最终只能将数组排序后使用双指针的方法。但是本题是 四个独立的数组, 相当于是 四个维度, **想在四个维度上使用双指针的方法显然是不现实的**。

所以本题求的是个数，使用哈希表是比较方便的

时间复杂度：$ O(n^2) $

空间复杂度：$ O(n^2) $

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    // 将c和d的组合存入哈希表中，因为与个数有关，选用map
    // 将时间复杂度O(n^4) 降低为O(n^2)
    Map<Integer, Integer> map = new HashMap<>();
    int res = 0;
    for (int c : nums3) {
        for (int d : nums4) {
            map.put(c + d, map.getOrDefault(c + d, 0) + 1);
        }
    }
    for (int a : nums1) {
        for (int b : nums2) {
            int target = 0 - a - b;
            if (map.containsKey(target)) {
                // 这里虽然map里已经记录的不同的组合，但是a和b的和也可能相同，所以是叠加
                res += map.get(target);
            }
        }
    }
    return res;
}
```

还有另一种就是将 A + B 和 C + D 的每一种可能分别放入两个查找表中，如果两个表中的 key 和为 target ，则组合数为 两个key对应的value值相乘



### 两数之和 II - 输入有序数组

#### 题目描述

[LeetCode167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。



#### 题解

**暴力枚举**

超时

```java
// 暴力枚举
public int[] twoSum(int[] numbers, int target) {
    for (int i = 0; i < numbers.length; i++) {
        for (int j = 0; j < numbers.length; j++) {
            if (i != j && numbers[i] + numbers[j] == target) {
                return new int[]{i + 1, j + 1};
            }
        }
    }
    return new int[0];
}
```

时间复杂度：$O(n ^ 2)$



**二分搜索**

因为数组是有序的，所以我们可以使用二分来枚举

```java
// 枚举另一个数使用二分 时间复制度O(n * lgN)
public int[] twoSum(int[] numbers, int target) {
    for (int i = 0; i < numbers.length; i++) {
        int value = target - numbers[i];
        int res = binarySearch(numbers, value, i);
        if (res != -1) {
            return new int[]{i + 1, res + 1};
        }
    }
    return new int[0];
}

private int binarySearch(int[] nums, int target, int other) {
    int l = 0;
    int r = nums.length - 1;
    int mid;
    while (l <= r) {
        mid = l + ((r - l) >> 1);
        if (nums[mid] == target && mid != other) return mid;
        else if (nums[mid] > target) r = mid - 1;
        else l = mid + 1;
    }
    return -1;
}
```

时间复杂度：$O(nlogn)$



**双指针**

由于数组有序，我们可以很容易的控制指针移动来确定 $target$ 的位置

```java
// 双指针
public int[] twoSum(int[] numbers, int target) {
    int left = 0;
    int right = numbers.length - 1;
    while (left < right) {
        if (numbers[left] + numbers[right] == target) return new int[]{left + 1, right + 1};
        else if (numbers[left] + numbers[right] > target) right--;
        else left++;
    }
    return new int[0];
}
```

时间复杂度：$O(n)$



### 验证回文串

#### 题目描述

[LeetCode125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

 

**示例 1:**

```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

**示例 2:**

```
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
```



#### 题解

**双指针**

解法一：借助正则表达式匹配

```java
public boolean isPalindrome(String s) {
    if (s.length() == 0) return true;
    char[] str = s.toCharArray();
    int l = 0;
    int r = str.length - 1;
    while (l < r) {
        // 先匹配到有效的字符
        while (l < r && !(str[l] + "").matches("[0-9A-Za-z]")) l++;
        while (l < r && !(str[r] + "").matches("[0-9A-Za-z]")) r--;
        String lstr = str[l] + "";
        String rstr = str[r] + "";
        // 转换成String再忽略大小写进行比较
        if (!lstr.equalsIgnoreCase(rstr)) {
            return false;
        } else {
            l++;
            r--;
        }
    }
    return true;
}
```

解法二：

使用`Character.isLetterOrDigit()`：判断一个字符是否为数字或字母 比正则表达式快几百倍，因为正则表达式原理使用的是回溯，`Character.isLetterOrDigit()`只是做简单的判断。

```java
public boolean isPalindrome(String s) {
    if (s.length() == 0) return true;
    char[] str = s.toCharArray();
    int l = 0;
    int r = str.length - 1;
    while (l < r) {
        // 先匹配到有效的字符
        while (l < r && !Character.isLetterOrDigit(str[l])) l++;
        while (l < r && !Character.isLetterOrDigit(str[r])) r--;
        String lstr = str[l] + "";
        String rstr = str[r] + "";
        // 转换成String再忽略大小写进行比较
        if (!lstr.equalsIgnoreCase(rstr)) {
            return false;
        } else {
            l++;
            r--;
        }
    }
    return true;
}
```



### 反转字符串中的元音字母

#### 题目描述

[LeetCode345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

难度简单245收藏分享切换为英文接收动态反馈

给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

 

**示例 1：**

```
输入：s = "hello"
输出："holle"
```

**示例 2：**

```
输入：s = "leetcode"
输出："leotcede"
```



#### 题解

```java
public String reverseVowels(String s) {
    char[] str = s.toCharArray();
    int l = 0;
    int r = str.length - 1;
    while (l < r) {
        while (l < r && !isVowels(str[l])) l++;
        while (l < r && !isVowels(str[r])) r--;
        if (l < r) { // 也可以不判断 因为 l == r 时原地交换一次就结束
            char temp = str[l];
            str[l] = str[r];
            str[r] = temp;
            l++;
            r--;
        }
    }
    return new String(str);
}

private boolean isVowels(char c) {
    char lowerChar = Character.toLowerCase(c);
    return lowerChar == 'a' || lowerChar == 'e' || lowerChar == 'i'
            || lowerChar == 'o' || lowerChar == 'u';
}
```



# 滑动窗口

### 存在重复元素 II

#### 题目描述

[LeetCode219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3
输出：true
```

**示例 2：**

```
输入：nums = [1,0,1,1], k = 1
输出：true
```

**示例 3：**

```
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
```



#### 题解

**哈希表+滑动窗口**

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Set<Integer> set = new HashSet<>();
    // 滑动窗口
    for (int i = 0; i < nums.length; i++) {
        // 窗口可容纳k+1 索引从0开始 i > k 即越过窗口
        if (i > k) {
            // 越过窗口一位 索引相差（k+1）= 窗口
            set.remove(i - k - 1);
        }
        if (set.contains(nums[i])) {
            return true;
        }
        set.add(nums[i]);
    }
    return false;
}
```



### 存在重复元素 III

#### 题目描述

[LeetCode220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)

给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。

如果存在则返回 `true`，不存在返回 `false`。

 

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```

**示例 2：**

```
输入：nums = [1,0,1,1], k = 1, t = 2
输出：true
```

**示例 3：**

```
输入：nums = [1,5,9,1,5,9], k = 2, t = 3
输出：false
```



#### 题解

**二分搜索树+滑动窗口**

比上一题多了一个条件 $∣nums[i]−nums[j]∣ \leq t $

我们只需要枚举其中一个数 $ nums[i] $，对于长度为 $k$ 的一个窗口中是否存在一个 $nums[j]$ 满足 $∣nums[i]−nums[j]∣ \leq t $

等价于一个经典的问题：在窗口内(或一个集合里)寻找与 $nums[i]$ 最接近的一个数，也就是**大于等于 $nums[i]$ 的最小数**和**小于等于 $nums[i]$ 的最大数**，从这两个中选一个最接近的。

 $∣nums[i]−nums[j]∣ \leq t $ ==> $ nums[i] - nums[j] \leq t$ 并且 $ nums[i] - nums[j] \geq t$

由此我们可以得到：如果在滑动窗口中能够找到一个元素 $nums[j]$，它的值大于等于 $nums[i]−t$（条件 1），并且还要小于等于 $nums[i]+t$（条件 2）。

滑动窗口中可以有很多个元素的值满足「条件 1」，为了能够找同时满足两个条件的合适的 $nums[j]$，由于「条件 2」中 $nums[i]+t$ 的值是固定的，为了让「条件 2」有更多的可能性成立，「条件 1」找到的 $nums[j]$ 需要尽可能小，这件事情等价于找到大于等于 $nums[i]−t$ 的最小的值，即找到 $nums[i]−t$ 的**最小上界**。



```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    TreeSet<Long> treeSet = new TreeSet<>();
    for (int i = 0; i < nums.length; i++) {
        // 维护长度为K+1的窗口
        if (i > k) {
            treeSet.remove((long) nums[i - k - 1]);
        }
        // 取最小上界
        Long x = treeSet.ceiling((long) nums[i] - (long) t);
        if (x != null && x <= (long) nums[i] + (long) t) {
            return true;
        }
        treeSet.add((long) nums[i]);
    }
    return false;
}
```



### 长度最小的子数组

#### 题目描述

[LeetCode209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

 

#### 题解

**暴力枚举**

```java
public int minSubArrayLen(int target, int[] nums) {
    int sum = 0;
    int res = nums.length + 1;
    for (int i = 0; i < nums.length; i++) {
        for (int j = i; j < nums.length; j++) {
            if (sum < target) sum += nums[j];
            if (sum >= target) {
                res = Math.min(res, j - i + 1);
                break; // 剪枝
            }
        }
        sum = 0;
    }
    return (res == nums.length + 1 ? 0 : res);
}
```

时间复杂度：$O(n^2)$



**滑动窗口**

维护区间[l, r] 为子数组

代码一：

```java
public int minSubArrayLen(int target, int[] nums) {
    int sum = 0;
    int res = nums.length + 1;
    for (int l = 0, r = -1; l < nums.length; ) {
        if (r + 1 < nums.length && sum < target) { // 因为使用的是++r 所以要判断是否越界
            sum += nums[++r];
        } else if (sum >= target) {
            res = Math.min(res, r - l + 1);
            sum -= nums[l++];
        } else { // 结束条件
            break;
        }
    }
    return (res == nums.length + 1 ? 0 : res);
}
```

代码二：

```java
public int minSubArrayLen(int target, int[] nums) {
    int sum = 0;
    int res = nums.length + 1;
    int l = 0, r = -1;
    while (l < nums.length) {
        if (r + 1 < nums.length && sum < target) {
            sum += nums[++r];
        } else { // 不满足上诉条件就移动左边界，不管窗口内总值是否大于等于target
            sum -= nums[l++];
        }
        // 另外判断，就不用break
        if (sum >= target) res = Math.min(res, r - l + 1);
    }
    return (res == nums.length + 1 ? 0 : res);
}
```

时间复杂度：$O(n)$



**前缀和+二分搜索**

区间和都可以用前缀和的解法

额外创建一个前缀和数组 $preSum$ 用于存储数组 $nums$ 的前缀和，其中 $preSum[i]$ 表示从 $nums[1]$ 到 $nums[i]$ 的元素和。

目的就是寻找一个最小长度区间和使得该区间和大于等于 $target$，我们枚举区间的左边界 $i$，去寻找右边界 $bound$ ，使得 $preSum[bound] - preSum[i - 1] \geq target$ （如果 $nums$ 从 $0$ 开始存储且 $preSum$ 从 $1$ 开始，那么区间 $[i, j]$ 的和为 $preSum[j + 1] - preSum[i]$） ，那么对于每个 $preSum[i]$，我们只需要取搜索是否存在大于等于 $preSum[i] + target$ 的 $preSum[bound + 1]$ 即可，因为 $nums$ 为正整数，所以我们保证 $PreSum$ 是单调递增的，所以我们可以使用二分搜索来加快搜索速度。

```java
// 前缀和+二分
public int minSubArrayLen3(int target, int[] nums) {
    int res = nums.length + 1;
    int[] preSum = new int[nums.length + 1];
    for (int i = 1; i <= nums.length; i++) {
        preSum[i] = preSum[i - 1] + nums[i - 1];
    }
    for (int i = 0; i < nums.length; i++) {
        int preSumBoundAddOne = target + preSum[i];
        int boundAddOne = binarySearch(preSum, preSumBoundAddOne);
        if (boundAddOne < nums.length + 1) {
            res = Math.min(res, boundAddOne - i);
        }
    }
    return (res == nums.length + 1 ? 0 : res);
}

// 返回大于等于target的最小索引
private int binarySearch(int[] nums, int target) {
    int l = 0;
    int r = nums.length - 1;
    int mid;
    int minGt = Integer.MAX_VALUE;
    while (l <= r) {
        mid = l + ((r - l) >> 1);
        if (nums[mid] == target) return mid;
        else if (nums[mid] > target) {
            minGt = Math.min(minGt, mid);
            r = mid - 1;
        } else l = mid + 1;
    }
    return minGt;
}
```



### 找到字符串中所有字母异位词

#### 题目描述

[LeetCode438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

 

#### 题解

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> res = new ArrayList<>();
    if (s.length() < p.length()) { // 可以提前判断
        return res;
    }
    int[] pCount = new int[26];
    int[] sCount = new int[26];
    char[] pStr = p.toCharArray();
    char[] sStr = s.toCharArray();
    for (char c : pStr) {
        pCount[c - 'a']++;
    }
    int l = 0, r = -1;
    // 维护窗口[l, r]
    while (r + 1 < s.length()) { // 窗口右边界到边界，循环就可以结束了
        sCount[sStr[++r] - 'a']++;
        // 维护窗口长度
        if (r - l + 1 > pStr.length) {
            sCount[sStr[l++] - 'a']--;
        }
        // 窗口长度等于p长度时判断是否为p的异位词
        if (r - l + 1 == pStr.length && isAnagrams(pCount, sCount)) {
            res.add(l); // 添加窗口的左边界
        }
    }
    return res;
}

// 判断窗口内的字符是否为p的异位词
private boolean isAnagrams(int[] pCount, int[] sCount) {
    for (int i = 0; i < 26; i++) {
        if (pCount[i] != sCount[i]) {
            return false;
        }
    }
    return true;
}
```



### 最小覆盖子串

#### 题目描述

[LeetCode76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**进阶：**你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

#### 题解

这题关键在于左边界移动的时机

```java
public String minWindow(String s, String t) {
    // t为匹配字串
    if (s.length() < t.length()) {
        return "";
    }

    int begin = 0; // 记录最小覆盖子串的起始位置 末位置即为窗口的右边界
    int minSize = Integer.MAX_VALUE; // 记录当前最小覆盖子串的长度
    int[] sCount = new int[256];
    int[] tCount = new int[256];
    char[] sStr = s.toCharArray();
    char[] tStr = t.toCharArray();

    // 记录匹配串的字符数
    for (char c : tStr) {
        tCount[c - 'A']++;
    }

    // 编辑距离，指窗口内子串覆盖匹配字符的一个编辑距离，若编辑距离等于匹配字符的长度，说明窗口已经覆盖匹配子串
    // 通俗的来讲就是窗口内已经还差 tLen - distance 个字符能覆盖匹配子串
    int distance = 0;
    int l = 0, r = -1; // 维护窗口[l]
    while (r + 1 < sStr.length) {
        // 注意这里sStr[r + 1]字符严格小于所需要的字符时纳入窗口后编辑距离才+1，否则说明窗口内该字符的数量已经大于需求量，纳入后编辑距离不变
        if (sCount[sStr[r + 1] - 'A'] < tCount[sStr[r + 1] - 'A']) {
            distance++;
        }
        // 移动右边界将新字符纳入窗口并记录窗口内字符的个数
        sCount[sStr[++r] - 'A']++;

        // 窗口已经覆盖匹配串时移动左边界来缩小窗口 （进行缩小窗口的时机很重要）
        while (distance == tStr.length) {
            // 维护最小覆盖子串的长度
            if (r - l + 1 < minSize) {
                minSize = r - l + 1;
                begin = l;
            }
            // 注意等于的时候减去这个字符后，窗口内才会缺少这个字符，大于的时候减去一个仍然不缺
            if (sCount[sStr[l] - 'A'] == tCount[sStr[l] - 'A']) {
                distance--;
            }
            sCount[sStr[l++] - 'A']--;
        }
    }
    // 找不到则返回空否则返回结果子串
    return (minSize == Integer.MAX_VALUE ? "" : s.substring(begin, begin + minSize));
}
```



# 链表

##  常见问题





### 反转链表

#### 题目描述

[LeetCode206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)



#### 题解

```java
ListNode<T> pre = null;
ListNode<T> cur = head;
ListNode<T> next = null;
while (cur != null) {
    next = cur.next; //记录next
    cur.next = pre; // 当前next指向pre
    pre = cur; // 将当前节点设置为pre
    cur = next;// cur后移
}
return pre;
```



**进阶反转双链表**

```java
DoubleListNode<T> pre = null;
DoubleListNode<T> cur = head;
DoubleListNode<T> next = null;
while (cur != null) {
    next = cur.next; // 记录next
    cur.next = pre; // 修改cur的pre和next 顺序无所谓
    cur.pre = next; // 因为将cur.next保存给next了 所以先反转pre还是next的顺序无所谓
    pre = cur; // 将当前节点设置为pre
    cur = next; // cur后移 等价于cur = cur.pre 反转前的next值
}
return pre;
```







### 删除排序链表中的重复元素

#### 题目描述

[LeetCode83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)



#### 题解

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while (cur != null && cur.next != null) {
        if (cur.val == cur.next.val) {
            cur.next = cur.next.next;
        } else {
            // 如果有重复值被删除后 cur.next已经被更改，所以next值的正确的值
            cur = cur.next;
        }
    }
    return head;
}
```



### 分隔链表

#### 题目描述

[LeetCode86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```



#### 题解

链表版的荷兰国旗，但是题目要求要保留两个分区中每个结点的初始相对位置。所以其实用快排思想的话，其实不是那么好做。

```java
public ListNode partition(ListNode head, int x) {
    // 分割链表再合并
    ListNode leftCur = new ListNode(-1);
    ListNode rightCur = new ListNode(-1);
    // 记录两个链表头
    ListNode leftHead = leftCur;
    ListNode rightHead = rightCur;
    while (head != null) {
        if (head.val < x) {
            leftCur.next = head;
            leftCur = leftCur.next;
        } else {
            rightCur.next = head;
            rightCur = rightCur.next;
        }
        head = head.next;
    }
    // 左链表接上右链表的第二个结点
    leftCur.next = rightHead.next;
    // 右链表最后记得要置空 否则会出现循环链表
    rightCur.next = null;
    // 返回左链表的第二个结点
    return leftHead.next;
}
```

会出现循环链表的原因是，while 循环结束后，rightCur 的尾结点为 5，leftCur 的尾结点为 2，并且 right 链表要接到 left 的后面，这时如果 right 尾结点的next值没有置空，会仍然指向 2 这个结点，造成一个循环链表

![image-20220322225453548](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220322225453548.png)



### 奇偶链表

#### 题目描述

[LeetCode328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)



#### 题解

解法和分隔链表一样

```java
public ListNode oddEvenList(ListNode head) {
    ListNode oddCur = new ListNode(-1);
    ListNode evenCur = new ListNode(-1);
    ListNode oddHead = oddCur;
    ListNode evenHead = evenCur;
    int count = 1;
    while (head != null) {
        if (count % 2 == 1) {
            oddCur.next = head;
            oddCur = oddCur.next;
        } else {
            evenCur.next = head;
            evenCur = evenCur.next;
        }
        head = head.next;
        count++;
    }
    oddCur.next = evenHead.next;
    evenCur.next = null;
    return oddHead.next;
}
```



### 两数相加

#### 题目描述

[LeetCode2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)



#### 题解

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode sumHead = new ListNode(-1);
    ListNode cur = sumHead;
    int carry = 0;
    while (l1 != null || l2 != null) {
        if (l1 != null) {
            carry += l1.val;
            l1 = l1.next;
        }
        if (l2 != null) {
            carry += l2.val;
            l2 = l2.next;
        }
        // new Node 取余数
        cur.next = new ListNode(carry % 10);
        cur = cur.next;
        // 保留进位
        carry /= 10;
    }
    // 注意最后一个case 是否还有一个进位，有则新增一个node
    if (carry == 1) {
        cur.next = new ListNode(1);
    }
    return sumHead.next;
}
```



### 合并两个有序链表

#### 题目描述

[LeetCode21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```



#### 题解

经典归并，不过是链表的归并排序，只是有一点细节需要注意

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode dummyHead = new ListNode(-1);
    ListNode cur = dummyHead;
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    // 注意剩余不为空的链表结点直接挂上去就行，不需要更改list的next，否则会缺失结点
    cur.next = list1 != null ? list1 : list2;
    return dummyHead.next;
}
```



### 删除排序链表中的重复元素

#### 题目描述

[LeetCode83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

#### 题解

因为是已经排好序的链表，只需要判断当前结点和下一结点是否相等即可

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while (cur != null && cur.next != null) {
        if (cur.val == cur.next.val) {
            cur.next = cur.next.next;
        } else {
            // 如果有重复值被删除后 cur.next已经被更改，所以next值的正确的值
            cur = cur.next;
        }
    }
    return head;
}
```



### 删除排序链表中的重复元素 II

#### 题目描述

[LeetCode82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)



#### 题解

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode dummyHead = new ListNode(-1);
    // 设立虚拟头结点，统一处理
    dummyHead.next = head;
    ListNode cur = dummyHead;
    while (cur.next != null) {
        if ((cur.next.next != null && cur.next.val == cur.next.next.val)) {
            // 记录下被删结点的值
            int memory = cur.next.val;
            cur.next = cur.next.next.next;
            // 如果后面还有非空且值等于memory的结点，继续删
            while (cur.next != null && cur.next.val == memory) {
                cur.next = cur.next.next;
            }
        } else {
            cur = cur.next;
        }
    }
    return dummyHead.next;
}
```



### 移除链表元素

#### 题目描述

[LeetCode203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```
输入：head = [7,7,7,7], val = 7
输出：[]
```



#### 题解

**对头结点特殊判断**

```java
public ListNode removeElements(ListNode head, int val) {
    // 需要对头结点特殊判断 找到一个值不为val的头结点
    while (head != null) {
        if (head.val != val) {
            break;
        }
        head = head.next;
    }
    // 运行到这head是可能为null的
    ListNode cur = head;
    ListNode pre = head;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            // cur值不为val pre紧跟cur
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
```



**设立虚拟头结点**

![image-20220326223331422](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220326223331422.png)

```java
// 不对头结点特殊处理 我们在头结点前新增一个虚拟结点，使得所有结点都统一处理
public ListNode removeElements2(ListNode head, int val) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    // 保证了cur必不为空
    ListNode cur = dummyHead;
    while(cur.next != null) {
        if (cur.next.val == val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return dummyHead.next;
}
```





### 两两交换链表中的节点

#### 题目描述

[LeetCode24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```



#### 题解

![image-20220327111516368](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327111516368.png)

交换后

![image-20220327111533890](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327111533890.png)

![image-20220327111637298](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220327111637298.png)

```java
public ListNode swapPairs(ListNode head) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode cur = dummyHead;
    ListNode node1 = null;
    ListNode node2 = null;
    ListNode next = null;
    while (cur.next != null && cur.next.next != null) {
        // 为什么不在循环外面先初始值是因为如果cur.next为null 给node2赋值会空指针异常
        node1 = cur.next;
        node2 = cur.next.next;
        next = node2.next;
        // 交换
        node2.next = node1;
        node1.next = next;
        cur.next = node2;
        // 修改下一次循环的cur指针
        cur = node1;
    }
    return dummyHead.next;
}
```

其实 next 指针并不是必需的，使用next 指针是为了让逻辑更清晰，如果不用 next 指针，就不能先对 node2 的指针进行修改，要先对 node1 的指针指向 node2.next 后再做修改



### K 个一组翻转链表

#### 题目描述

[LeetCode25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**示例 3：**

```
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
```

**示例 4：**

```
输入：head = [1], k = 1
输出：[1]
```



#### 题解

![K 个一组翻转链表.drawio (1)](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.drawio%20(1).png)



```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode node1 = null;
    ListNode node2 = dummyHead;
    ListNode cur = dummyHead;
    // next初始值为head用于判断head是否为null
    ListNode next = dummyHead.next;

    while (next != null) {
        // node1指向上次的next node2指向上次处理的片段链表末尾
        node1 = next;
        for (int i = 0; i < k && node2 != null; i++) {
            node2 = node2.next;
        }
        if (node2 == null) {
            break;
        }
        next = node2.next;
        // cur.next 指向翻转后的头结点 翻转后node1为该片段链表的末尾节点
        cur.next = reverse(node1, next);
        node1.next = next;
        // 更新cur,node2 指向上个片段链表的末尾
        cur = node1;
        node2 = cur;
    }
    return dummyHead.next;
}

// 与普通的翻转链表差不多，只是循环条件由cur != null 改为 cur != end
// end值为整个链表的next指针
private ListNode reverse(ListNode node1, ListNode end) {
    ListNode pre = null;
    ListNode cur = node1;
    ListNode next = null;
    while (cur != end) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



还有一种解法是使用递归，但是使用递归就需要额外的系统栈空间



### 排序链表

#### 题目描述

[LeetCode148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/sort_list_2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

 **提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

 **进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？



#### 题解



**归并递归**

```java
// O(n log n) 时间复杂度 常规解法使用归并递归
public ListNode sortList(ListNode head) {
    // 空 或者元素个数为1 返回
    if (head == null || head.next == null) {
        return head;
    }
    // 经典快慢指针寻找中点
    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null) {
        faster = faster.next.next;
        slower = slower.next;
    }
    // 此时慢指针指向第一个中点，也就是数组排序中M的位置
    ListNode midNext = slower.next;
    // 断开链表
    slower.next = null;
    ListNode left = sortList(head);
    ListNode right = sortList(midNext);
    return merge(left, right);
}

// 合并两个有序链表经典算法
private ListNode merge(ListNode left, ListNode right) {
    ListNode dummyHead = new ListNode(-1);
    ListNode cur = dummyHead;
    while (left != null && right != null) {
        if (left.val < right.val) {
            cur.next = left;
            left = left.next;
        } else {
            cur.next = right;
            right = right.next;
        }
        cur = cur.next;
    }
    cur.next = (left != null) ? left : right;
    return dummyHead.next;
}
```



### 删除链表的倒数第 N 个结点

#### 题目描述

[LeetCode19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 **提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

 **进阶：**你能尝试使用一趟扫描实现吗？



#### 题解



**朴素做法**

遍历两遍，第一遍算出链表长度

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    int count = 0;
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode cur = dummyHead;
    while (cur.next != null) {
        count++;
        cur = cur.next;
    }
    cur = dummyHead;
    for (int i = 0; i < count - n; i++) {
        cur = cur.next;
    }
    cur.next = cur.next.next;
    return dummyHead.next;
}
```





**双指针**



如果要删除倒数第n个结点，那么我们需要站在倒数第n + 1个结点，也就是被删结点的前一个位置 p，再让另一个指针q指向末尾的null，而p和q之前的距离是固定的就是n，那么我们只需要固定住 p 和 q 的**相对位置**，让 p 起始值指向虚拟结点，保持 p 和 q 的**相对位置**往后移动，直到 q 指向 null，p 就是我们想找的位置

![image-20220329210054845](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329210054845.png)

![image-20220329210324294](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329210324294.png)

![image-20220329210544455](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220329210544455.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode p = dummyHead;
    ListNode q = dummyHead;
    // q从dummyHead移动n + 1
    for (int i = 0; i <= n; i++) {
        q = q.next;
    }
    // 寻找被删除结点的前一个位置
    while (q != null) {
        p = p.next;
        q = q.next;
    }
    // 删除
    p.next = p.next.next;
    return dummyHead.next;
}
```



### 旋转链表

#### 题目描述

[LeetCode61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 **示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 **提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`



#### 题解

```java
public ListNode rotateRight(ListNode head, int k) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode cur = dummyHead;
    // 记录最后一个结点
    ListNode last = null;
    // 确定链表长度
    int n = 0;
    while (cur.next != null) {
        n++;
        cur = cur.next;
        if (cur.next == null) {
            last = cur;
        }
    }
    cur = dummyHead;
    k = k % n;
    // 不移动
    if (k == 0) {
        return head;
    }
    for (int i = 0; i < (n - k); i++) {
        cur = cur.next;
    }
    // right为倒数第k+1个结点，在此处断开链表 重新连接
    ListNode right = cur.next;
    cur.next = null;
    last.next = dummyHead.next;

    return right;
}
```



### 重排链表

#### 题目描述

[LeetCode143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1626420311-PkUiGI-image.png)

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1626420320-YUiulT-image.png)

```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

 

#### 题解

```java
public void reorderList(ListNode head) {
    ListNode slower = head;
    ListNode faster = head.next;
    while (faster != null && faster.next != null) {
        slower = slower.next;
        faster = faster.next.next;
    }
    // 找到第一个中点的下一个位置 先断开再翻转
    ListNode right = slower.next;
    slower.next = null;
    right = reverse(right);
    
    ListNode left = head;
    // 这里左链表一定大于等于右链表，且至多大一个单位
    // 在原链表上进行连接 注意细节
    while (right != null) {
        ListNode nextL = left.next;
        ListNode nextR = right.next;
        left.next = right;
        left = nextL;

        right.next = left;
        right = nextR;
    }
}
// 翻转
private ListNode reverse(ListNode head) {
    ListNode cur = head;
    ListNode next = null;
    ListNode pre = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 回文链表

#### 题目描述

[LeetCode234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

 **进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？



#### 题解

**不使用额外空间，经典做法是翻转链表**

```java
public boolean isPalindrome(ListNode head) {
    // 所给数据个数大于等于1
    boolean flag = true;

    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null) {
        slower = slower.next;
        faster = faster.next.next;
    }
    ListNode right = reverse(slower.next);
    while(right != null) {
        if (head.val != right.val) {
            flag = false;
            break; 
        }
        right = right.next;
        head = head.next;
    }
    // 最后最好把右链表再翻转一遍 还原回来
    return flag;    
}

private ListNode reverse(ListNode head) {
    ListNode cur = head;
    ListNode pre = null;
    ListNode next = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 双链表实现双端队列、队列、栈



## 常见问题

### 回文链表

[剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

一般解法借助容器类如栈

最优解：

**快慢指针+反转链表**



注意的点：

1、是不用判断奇偶的，因为右链表总是小于等于左链表，while以数量小的那个判空停下就行，因为如果是奇数，中间那个数是不用比较的。

2、判断快慢指针越界的时候，不仅仅要判faster.next.next,  faster.next也要判空 否则会空指针

3、如果要还原链表，需要复制一个指针，不能直接用reverse 会被改变

```java
// 快慢指针
public static boolean isPal2(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    // 1 快慢指针找中点
    ListNode faster = head.next; //简化边界问题
    ListNode slower = head;
    // 快慢指针 快2倍 如果奇数个 while停下 慢指针指向中点
    // 如果偶数个 慢指针指向第一个中点
    // 这里注意faster.next也要判空 否则会空指针 只需要判快指针
    while (faster != null && faster.next!= null ) {
        faster = faster.next.next;
        slower = slower.next;
    }
    boolean res = true;
    // 2 反转右链表对比
    ListNode reverse = reverse(slower.next);
    // 如果要还原链表的话不能直接用reverse 会被改变
    ListNode temp = reverse;
    while (temp != null) {
        if (temp.data != head.data) {
            res = false;
            break;
        }
        temp = temp.next;
        head = head.next;
    }
    // 3 还原链表
    slower.next = reverse(reverse);
    return res;
}

public static ListNode reverse(ListNode head) {
    ListNode next = null;
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 复杂链表的复制

[剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

一般解：哈希表

最优解：

使用哈希表能解决的原因是，我们可以得到原结点和副本的一一对应结构，只要我们人为去构造这种对应的结构就不需要哈希表。

1、在每个原结点后复制出一个新的

2、一对一对（origin + copy）的遍历 添加副本结点的random指针

3、分离原结点和副本

```java
public Node copyRandomList(Node head) {
    // 这个是有必要的 否则下面的Node copyHead = head.next可能会空指针
    if (head == null) {
        return null;
    }
    Node cur = head;
    Node next = null;
    // 1 在每个原结点后复制出一个新的
    while (cur != null) {
        next = cur.next;
        // copy = cur.next; copy.next = next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }
    // 一对一对（origin + copy）的遍历 添加副本结点的random指针
    cur = head;
    Node curCopy = null;
    // 这里为什么不用判cur.next != null 是因为cur.next是cur的副本 只用判cur就可以了
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        // cur.random是原结点的random 我们通过它获取cur.random的副本 而副本是接在原结点后面的
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node copyHead = head.next;
    // 分离原结点和副本
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = curCopy.next;
        // 要特殊处理一下最后一个结点next为空 next.next会报错
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return copyHead;
}
```

对最后一个结点进行操作的时候需要特判一下next为不为空

![image-20220129231741596](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220129231741596.png)

### 相交链表(有环无环)

#### 题目描述

给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 

【要求】 如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。



#### 题解

这应该是链表里最难的题目之一了，一道题里组合了环形链表和普通相交链表

分析一下题目的可能性：

一共有五种可能性：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220202221828729.png)

```java
// 主方法
public static ListNode isIntersection(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode loopA = findLoopNode(headA);
    ListNode loopB = findLoopNode(headB);
    // 两个无环链表相交问题
    if (loopA == null && loopB == null) {
        return getIntersectionNoLoop(headA, headB);
    }
    // 两个有环链表相交问题
    if (loopA != null && loopB != null) {
        return getIntersectionAllLoop(headA, loopA, headB, loopB);
    }
    // 一个有环 一个无环 必不相交
    return null;
}

// 判断链表是否有环，有则返回入环点，无则返回null
public static ListNode findLoopNode(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    ListNode faster = head.next;
    ListNode slower = head;
    while (faster != null && faster.next != null && faster != slower) {
        faster = faster.next.next;
        slower = slower.next;
    }
    if (faster == null || faster.next == null) {
        return null;
    }
    slower = slower.next;
    faster = head;
    while (faster != slower) {
        faster = faster.next;
        slower = slower.next;
    }
    return faster;
}

// 求两个有环链表相交问题 如果相交求出交点
public static ListNode getIntersectionAllLoop(ListNode headA, ListNode loopA, ListNode headB, ListNode loopB) {
    ListNode curA = headA;
    ListNode curB = headB;
    // 入环点一样 那么入环点之前的情况跟无环链表一样
    if (loopA == loopB) {
        while (curA != curB) {
            // 不让指针走入环内
            curA = (curA != loopA) ? curA.next : headB;
            curB = (curB != loopA) ? curB.next : headA;
        }
        return curA;
    }
    // 入环点不一样 即相交点就等于入环点 随便返回一个
    return loopA;

}

// 求两个无环链表相交问题 如果相交求出交点
public static ListNode getIntersectionNoLoop(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode curA = headA;
    ListNode curB = headB;
    while (curA != curB) {
        curA = (curA != null) ? curA.next : headB;
        curB = (curB != null) ? curB.next : headA;
    }
    return curA;
}

// 测试样例 for test
public static void main(String[] args) {
    // 1->2->3->4->5->6->7->null
    ListNode head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);

    // 0->9->8->6->7->null
    ListNode head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

    // 1->2->3->4->5->6->7->4...
    head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = new ListNode(5);
    head1.next.next.next.next.next = new ListNode(6);
    head1.next.next.next.next.next.next = new ListNode(7);
    head1.next.next.next.next.next.next = head1.next.next.next; // 7->4

    // 0->9->8->2...
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next; // 8->2
    System.out.println(isIntersection(head1, head2).val);

    // 0->9->8->6->4->5->6..
    head2 = new ListNode(0);
    head2.next = new ListNode(9);
    head2.next.next = new ListNode(8);
    head2.next.next.next = head1.next.next.next.next.next; // 8->6
    System.out.println(isIntersection(head1, head2).val);

}
```





### 链表排序



# 队列和栈

## 设计题

![image-20220313234930488](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220313234930488.png)

### 数组实现队列和栈

### 最小栈设计

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

1、创建两个栈，一个数据栈，一个最小栈，最小栈的栈顶为最小值

2、怎么维护最小栈的栈顶为元素最小值

- 第一种方法：

  入栈情况：

  - 当最小栈为空，第一个进入的元素就进最小栈（数据栈正常入栈）
  - 当最小栈不为空，且入栈的元素**小于等于**最小栈栈顶，才进入最小栈（数据栈正常入栈）

  出栈情况：

  - 当数据栈出栈的元素等于最小栈栈顶时，最小栈同时出栈，否则只有数据栈出栈

- 第二种方法：

  入栈情况：

  - 数据栈和最小栈同步入栈，但是只有入栈元素小于最小栈栈顶时，才将该元素入最小栈，否则将最小栈栈顶入最小栈

  出栈情况：

  - 同步出栈

> 注意第一种方法，等于的时候也要入最小栈的，因为数据栈肯定是要正常入栈的，当这个元素出栈时最小栈也要出栈，而此时数据栈有重复的元素，最小栈只有一个，会出错。



### 用队列实现栈

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

两个队列实现：

1、将原队列的元素导入另一个辅助队列直到只剩下一个元素，输出

2、将两队列地址互换，改变输入的队列

3、重复上述过程

![image-20220125183527993](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220125183527993.png)



一个队列实现：

只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

![image-20220125184034130](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220125184034130.png)





### 用栈实现队列

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 必须是popStack为空才能倒数据
- 如果导数据，必须从pushStack一次性倒完

只要满足上面两个要求，导数据的时机什么时候都可以，可以在每次push操作后，也可以在每次pop或peek的时候导，或者push和pop操作都导。



### 递归实现栈的逆序



## 常见问题

### 有效的括号

#### 题目描述

[LeetCode20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

#### 题解

逻辑不难，使用栈作为存储结构，注意需要将所有的情况都要考虑到

```java
public boolean isValid(String s) {
    // 字符长度为奇数肯定不有效
    if (s.length() % 2 == 1) {
        return false;
    }
    Deque<Character> stack = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '{' || c == '[' || c == '(') {
            stack.push(s.charAt(i));
        } else {
            // 只有右符号的情况
            if (stack.isEmpty()) {
                return false;
            }
            char pop = stack.pop();
            if ((pop == '{' && s.charAt(i) == '}') || (pop == '[' && s.charAt(i) == ']') || ((pop == '(' && s.charAt(i) == ')'))) {
            } else {
                // 不匹配返回false
                return false;
            }
        }
    }
    // 注意还要判断只有左符号的情况
    return stack.isEmpty();
}
```



### 逆波兰表达式求值

#### 题目描述

[LeetCode150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)



#### 题解

```java
public int evalRPN(String[] tokens) {
    if (tokens.length == 0) {
        return 0;
    }
    int n = tokens.length;
    int res = 0;
    Deque<String> stack = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        if (isOperator(tokens[i])) {
            int num1 = Integer.parseInt(stack.pop());
            int num2 = Integer.parseInt(stack.pop());
            switch (tokens[i]) {
                case "+":
                    res = num2 + num1;
                    break;
                case "-":
                    res = num2 - num1;
                    break;
                case "*":
                    res = num2 * num1;
                    break;
                case "/":
                    res = num2 / num1;
                    break;
            }
            stack.push(res + "");
        }
        if (isNum(tokens[i])) {
            stack.push(tokens[i]);
        }
    }
    // 操作完栈中只有一个元素 注意返回的是栈中的元素 而不是res 因为表达式只有一个数时["18"] 返回res会不正确
    return Integer.parseInt(stack.peek());
}
// 虽然题目给的都是合法数据 最好还是校验一下
private boolean isNum(String c) {
    try {
        Integer.parseInt(c);
    } catch (Exception e) {
        return false;
    }
    return true;
}
private boolean isOperator(String c) {
    return "+".equals(c) || "-".equals(c) || "*".equals(c) || "/".equals(c);
}
```



**进阶版**

TODO

思考一下，如果数据给的操作符范围更广，数据不仅有整数，还可能会有浮点数



### 简化路径

#### 题目描述

[LeetCode71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)



#### 题解

```java
public String simplifyPath(String path) {
    assert path.length() > 0;
    // 选用切割"/"的方案 这样就可以将完整的每个文件夹分开 ".."也是一个完整的字符串 不需要记录前一个的"."
    String[] paths = path.split("/");
    if (paths.length == 0) {
        return "/";
    }
    Deque<String> stack = new ArrayDeque<>();
    for (String s : paths) {
        // 注意split出来的可能还会有空字符串
        if ("".equals(s) || ".".equals(s)) {
            continue;
        }
        // ".."且栈不为空 弹出一个文件夹
        if ("..".equals(s)) {
            if (!stack.isEmpty()) {
                stack.pop();
            }
            continue;
        }
        // 如果是文件夹 入栈
        stack.push(s);
    }
    // 到这里 栈中已经有正确路径的文件夹了，只需要逆序出来补上"/"即可
    if (stack.isEmpty()) {
        return "/";
    }
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
        // 头插法
        sb.insert(0, stack.pop());
        sb.insert(0, "/");
    }
    return sb.toString();
}
```

注意一下`split()`的切割用法

```java
System.out.println(Arrays.toString("/".split("/")));
System.out.println(Arrays.toString("//".split("/")));
System.out.println(Arrays.toString("///".split("/")));
System.out.println(Arrays.toString("8///".split("/")));
System.out.println(Arrays.toString("/8///".split("/")));
System.out.println(Arrays.toString("/8////8".split("/")));
System.out.println(Arrays.toString("/8////8/".split("/")));
//-----------------分别打印出------------------------------
[]
[]
[]
[8]
[, 8]
[, 8, , , , 8]
[, 8, , , , 8]
```

如果不熟悉 StringBuilder 的 api 的话，对于结果的处理可以再开一个栈进行倒数就行，这题如果是笔试，直接使用双端队列会更方便



### 扁平化嵌套列表迭代器

#### 题目描述

[LeetCode341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

#### 题解

**栈**

这题相当于是对广义表的遍历，不过广义表的的一些方法题目已经给我们提供了

![扁平化嵌套列表迭代器.drawio (1)](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8.drawio%20(1).png)

```java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 		// 该广义表对象是否是一个整数
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 		// 如果该广义表对象是一个整数类型 那么返回这个整数
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return empty list if this NestedInteger holds a single integer
 		// 如果该广义表对象不是一个整数 那么返回这个广义表的子广义表列表
 *     public List<NestedInteger> getList();
 * }
 */
public class NestedIterator implements Iterator<Integer> {

    private Deque<NestedInteger> stack = new ArrayDeque<>();

    public NestedIterator(List<NestedInteger> nestedList) {
        // 对一层逆序压栈
        toStack(nestedList);
    }

    @Override
    public Integer next() {
        // 因为测试代码迭代器是有下一个元素才会调用next 没有就不会调用 所以这里的否定写什么都行
        return hasNext() ? stack.pollLast().getInteger() : Integer.MAX_VALUE;
    }

    @Override
    public boolean hasNext() {
        if (stack.isEmpty()) {
            return false;
        } else {
            if (stack.peekLast().isInteger()) {
                return true;
            } else {
                List<NestedInteger> nestedList = stack.pollLast().getList();
                // 不是数字 说明是列表 有层级继续调用 对一层逆序压栈
                toStack(nestedList);
                // 处理完一层后 递归调用hasNext()直至栈顶出现数字类型
                return hasNext();
            }
        }
    }
    // 对一层逆序压栈
    private void toStack(List<NestedInteger> nestedList) {
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.addLast(nestedList.get(i));
        }
    }
}
```



**DFS**

TODO



### 二叉树的层序遍历

#### 题目描述

[LeetCode102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

#### 题解

对于普通的层序遍历，多记录一个每一层的信息

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> levelList;
    if (root == null) {
        return res; 
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    int levelCount = 0;
    while (!queue.isEmpty()) {
        levelList = new ArrayList<>();
        levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 记录每一层的信息
        res.add(levelList);
    }
    return res;
}
```



### 二叉树的层序遍历 II

#### 题目描述

[LeetCode107二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

#### 题解



```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode cur = root;
    queue.offer(cur);

    while (!queue.isEmpty()) {
        int levelCount = queue.size();
        List<Integer> levelList = new ArrayList<>();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 每一层的数据采用头插法即可，忘记这个api可以在最后翻转一下res即可
        res.add(0, levelList);
    }
    return res;
}
```



### 二叉树的锯齿形层序遍历

#### 题目描述

[LeetCode103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)



#### 题解

**BFS**

如果担心使用插入效率不高，可以用 LinkedList 实现，或者 用 ArrayList，每一层最后 reverse 就好了

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new ArrayDeque<>();
    int index = 1;
    queue.offer(cur);
    while (!queue.isEmpty()) {
        List<Integer> levelList = new LinkedList<>();
        int levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            if (index % 2 == 1) {
                // 奇数层 左到右接收
                levelList.add(cur.val);
            } else {
                // 偶数层 右到左接收
                levelList.add(0, cur.val);
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        res.add(levelList);
        index++;
    }
    return res;
}
```



### 二叉树的右视图

#### 题目描述

[LeetCode199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)



#### 题解

**BFS**

存入每一层中最右侧的结点，即可获取右视图

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new ArrayDeque<>(); 
    queue.offer(cur);
    while(!queue.isEmpty()) {
        int levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
            // 如果是一层中的最右侧的一个节点 加入值
            if (i == levelCount - 1) {
                res.add(cur.val);
            }
        }
    }
    return res;
}
```



**DFS**

```java
// dfs
private List<Integer> res = new ArrayList<>();

public List<Integer> rightSideView1(TreeNode root) {
    dfs(root, 0);
    return res;
}

private void dfs(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    // 这里depth指的是上一层的depth 也就是说当前res的大小仍然等于上一层的深度，说明当前节点是该层出现的第一个结点
    // 我们先访问右子树 在右子树不为空的情况下控制每层出现的第一个结点为最右侧的结点
    if (depth == res.size()) {
        res.add(root.val);
    }
    dfs(root.right, depth + 1);
    dfs(root.left, depth + 1);
}
```



## 优先队列

关键词：前k个最值



### 数据流中的第 K 大元素

#### 题目描述

[LeetCode703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

#### 题解

```java
public static class KthLargest {
    // 默认小根堆
    private PriorityQueue<Integer> heap;
    private int k;
    public KthLargest(int k, int[] nums) {
        this.k = k;
        heap = new PriorityQueue<>();
        for (int x : nums) {
            // 调用自己写的add
            this.add(x);
        }
    }

    public int add(int val) {
        heap.offer(val);
        // 维护容量为k的小根堆 则堆顶的元素即为第k大的元素
        if (heap.size() > k) {
            heap.poll();
        }
        assert heap.size() > 0;
        return heap.peek();
    }
}
```



### 前 K 个高频元素

#### 题目描述

[LeetCode347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)



#### 题解

面试时最好先问下面试官 k 与 n 到底是什么样的关系，如果 k 是远小于 n 的，那么我们是可以维护大小为 k 的小根堆从而达到一个`O(n * logk)`的复杂度的。但是如果 k 非常接近 n 的话我们就可以维护一个大小为 m - k （m为不同元素的数量）的大根堆，不在堆中的元素就是我们的res

```java
public int[] topKFrequent(int[] nums, int k) {
    int[] res = new int[k];
    // key：元素的值 value：元素出现的频率
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        // getOrDefault如果找不到key返回defaultValue
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());
    // 维护大小为k的小根堆（频率）O(n * logK)
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        heap.offer(entry);
        if (heap.size() > k) {
            heap.poll();
        }
    }

    // 返回堆中的元素的值
    for (int i = k - 1; i >= 0; i--) {
        res[i] = heap.poll().getKey();
    }
    return res;
}
```



```java
public int[] topKFrequent(int[] nums, int k) {
    int[] res = new int[k];
    // key：元素的值 value：元素出现的频率
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        // getOrDefault如果找不到key返回defaultValue
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>((o1, o2) -> o2.getValue() - o1.getValue());
    int m = map.size();
    // 维护大小为m - k的大根堆（频率）
    int index = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        heap.offer(entry);
        if (heap.size() > (m - k)) {
            res[index] = heap.poll().getKey();
            index++;
        }
    }
    return res;
}
```



## 哈希表

增删改查复杂度都认为是O(1)，但是这个常数级别有点大

哈希表存入非基础数据类型占用内存非常小，只会记录引用值，不会复制值

```java
Integer a = 1111111111;
Integer b = 1111111111;
Student student1 = new Student(2);
Student student2 = new Student(2);
HashMap<Student,String> map1 = new HashMap<>();
HashMap<Integer,String> map = new HashMap<>();

// 基础数据类型的包装类且范围不在常量池，存放在哈希表中时，根据值匹配，属同一对象。
map.put(a,"我是a");
System.out.println(map.containsKey(b));

// 非包装类的引用类型，存放在哈希表中时，根据引用值匹配，不属同一对象。
map1.put(student2,"student2");
System.out.println(map1.containsKey(student1));
```



## 有序表

TreeMap 有序表 只是一个接口

能实现有序表的：红黑树、AVL树、SBT(Size Balanced tree)、跳表

增删改查时间复杂度都是O(logN),功能比有序表强大

Java中TreeMap是用红黑树实现的



非数值类型和String类型传入TreeMap需要自己定义比较器，否则会报错

当排序规则比较简单时，可以使用lambda表达式实现比较器

```java
//
TreeMap<Student, String> treeMap = new TreeMap<>(
                (stu1, stu2) -> !stu1.getId().equals(stu2.getId()) ? 
                        stu1.getId() - stu2.getId() : stu2.getAge() - stu1.getAge());
//
TreeMap<Student, String> treeMap = new TreeMap<>((stu1, stu2) -> stu1.getId() - stu2.getId());
// IDEA推荐写成这样
TreeMap<Student, String> treeMap = new TreeMap<>(Comparator.comparingInt(Student::getAge));
```

> 注意TreeMap一般情况下是不允许存放重复元素的，所以当传进来的比较器只比较id的话，treemap会认为相同age的student是同一个元素（即使两个student对象不一样），只会存进去一个student

解决方法，如果age相等的话，再比较内存地址（hashCode也可能重复），就能保证age相等的不同样本都留下来

# 二叉树

## 经典问题

### 遍历



### 序列化与反序列化



### 二叉树最大深度

#### 题目描述

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)



#### 题解

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(1 + maxDepth(root.left), 1 + maxDepth(root.right));
}
```



### 二叉树最小深度

#### 题目描述

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。



#### 题解

注意是通向叶子结点的路径我们才需要记录并取最小值，通向null的就不需要记录

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 子树如果为空说明不是通向叶子结点 不需要记录
    int leftInfo = minDepth(root.left);
    int rightInfo = minDepth(root.right);
    // 返回不为空子树的信息 如果都为空只有root一个结点 直接返回1
    if (leftInfo == 0 || rightInfo == 0) {
        return 1 + leftInfo + rightInfo;
    }
    // 两个子树不为空存在叶子结点 取最短路径
    return Math.min(leftInfo, rightInfo) + 1;
}
```



### 翻转二叉树

#### 题目描述





#### 题解

**DFS**

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    // 后序翻转 也可以先对左右子树交换 再dfs 
    invertTree(root.left);
    invertTree(root.right);

    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;

    return root;
}
```



**BFS**

也就是层序遍历，借用辅助队列

![bfs](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/bfs.gif)

```java
// 层序遍历
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    TreeNode temp = null;
    TreeNode cur = null;
    while(!queue.isEmpty()) {
        cur = queue.poll();
        temp = cur.right;
        cur.right = cur.left;
        cur.left = temp;
        
        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right); 
        }
    }
    return root;
}
```



**迭代遍历**

前序后序都可以，但是前序迭代比较简单

```java
// 迭代
public TreeNode invertTree(TreeNode root) {
    TreeNode cur = root;
    Deque<TreeNode> stack = new LinkedList<>();
    while(cur != null || !stack.isEmpty()) {
        if (cur != null) {
            // 前序交换
            TreeNode temp = cur.left;
            cur.left = cur.right;
            cur.right = temp;
            
            stack.offer(cur);
            cur = cur.left;
        } else {
            cur = stack.poll();
            cur = cur.right;
        }
    }
    return root;
}
```



### 对称二叉树

#### 题目描述

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```



#### 题解

**DFS**

如果没有考虑镜像对称，可能一开始会有这题不是递归结构的想法，因为一看可能觉得子树并没有递归结构，因为是镜像对称，我们考虑递归结构要放到对应的镜像上去

在这道题里，根节点没什么用，把根节点拿掉来看，就是两棵子树，我们需要的就是比较两颗子树是否镜像

既然是**镜像比较**，那么就是**左子树的左子树和右子树的右子树进行比较、左子树的右子树和右子树的左子树进行比较**

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return dfs(root.left, root.right);
}

private boolean dfs(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    // 仅有一颗子树为null
    if (left == null || right == null) {
        return false;
    }
    // left和right不为空且值不相等
    if (left.val != right.val) {
        return false;
    }
    // 镜像递归两组： 左子树的左子树和右子树的右子树、左子树的右子树和右子树的左子树
    return dfs(left.left, right.right) && dfs(left.right, right.left);
}
```



**层序遍历**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/45a663b08efaa14193d63ef63ae3d1d130807467d13707f584906ad3af4adc36-1.gif)

```java
// 层序遍历 队列 使用栈也是可以的
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root.left);
    queue.add(root.right);
    while(!queue.isEmpty()) {
        // 确认取出的两个是一组镜像
        TreeNode left = queue.remove();
        TreeNode right = queue.remove();
        // 都为null
        if (left == null && right == null) {
            continue;
        }
        // 仅有一个为null
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        // 两组放入顺序可以变 但是要保证依次放入的是一组镜像
        queue.add(left.left);
        queue.add(right.right);

        queue.add(left.right);
        queue.add(right.left);
    }
    return true;
}
```



### 相同的树

#### 题目描述

[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)



#### 题解

这题和对称二叉树的思想一模一样



**DFS**

```java
// dfs
public boolean isSameTree(TreeNode p, TreeNode q) {
    // 都为null
    if (p == null && q == null) {
        return true;
    }
    // 仅有一个为null
    if (p == null || q == null) {
        return false;
    }
    // 都不为null且值不相等
    if (p.val != q.val) {
        return false;
    }
    // 递归子树是否相等
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```



**层序遍历**

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(p);
    queue.offer(q);
    while(!queue.isEmpty()) {
        TreeNode temp1 = queue.poll();
        TreeNode temp2 = queue.poll();
        // 都为null
        if (temp1 == null && temp2 == null) {
            // return true; 不能直接return true 可能出现p:[1] q:[1,null,2]这种情况
            continue;
        }
        // 仅有一个为null
        if (temp1 == null || temp2 == null) {
            return false;
        }
        // 都不为null且值不等
        if (temp1.val != temp2.val) {
            return false;
        }
        queue.offer(temp1.left);
        queue.offer(temp2.left);

        queue.offer(temp1.right);
        queue.offer(temp2.right);
    }
    return true;
}
```



### 完全二叉树的节点个数

#### 题目描述





#### 题解



普通做法遍历整颗树：

```java
// 递归遍历
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}

// 迭代遍历
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int res = 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()) {
        int n = queue.size();
        for (int i = 0; i < n; i++) {
            TreeNode cur = queue.poll();
            res++;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
    }
    return res;
}
```



**完全二叉树做法**

完全二叉树只有两种情况，**情况一：就是满二叉树，情况二：最后一层叶子节点没有满。**

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

完全二叉树（一）如图：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631803818-YYYuSS-file_1631803818211)

完全二叉树（二）如图：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631803818-tpJmfp-file_1631803818273)


可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

**所以我们只要求子树的深度即可**

比较难想的点

- 对于完全二叉树来说如果左子树深度等于右子树深度 说明左子树是满二叉树
- 如果左右子树深度不等于 对于完全二叉树来说只能是左子树深度比右子树深度大1 说明右子树是满二叉树

```java
// O(logN*logN)比O(N)快
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = getDepth(root.left);
    int rightDepth = getDepth(root.right);
    // 如果左子树深度等于右子树深度 说明左子树是满二叉树
    if (leftDepth == rightDepth) {
        return (1 << leftDepth) - 1 + countNodes(root.right) + 1;
    } else {
        // 如果不等于 对于完全二叉树来说只能是左子树深度比右子树深度大1 说明右子树是满二叉树
        return (1 << rightDepth) - 1 + countNodes(root.left) + 1;
    }
}
// 计算完全二叉树的深度
private int getDepth(TreeNode root) {
    // 一直往左下遍历即可
    int depth = 0;
    while(root != null) {
        depth++;
        root = root.left;
    }
    return depth;
}
```





### 二叉树的最大宽度



### 路径总和

#### 题目描述

[LeetCode112. 路径总和](https://leetcode-cn.com/problems/path-sum/)



#### 题解

就是一道路径和类的问题，如果学过回溯这道题就很简单，用dfs就是回溯思想

注意的是题目要求的是**根结点到叶子结点的路径**，而不是任一路径

**DFS**

先贴一段错误代码：

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return dfs(root, targetSum);
}
private boolean dfs(TreeNode root, int targetSum) {
    if (root == null) {
        return targetSum == 0;
    }
    return dfs(root.left, targetSum - root.val) || dfs(root.right, targetSum - root.val);
}
```

上诉代码为什么错误？因为`root == null`的时候，我们忽视了上级结点是否为叶子结点，即使`targetSum == 0`，但它不是一条从根结点到叶子结点的路径，所以逻辑不对。

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220307235213797.png)



这题和**二叉树最小深度**的递归的终止条件差不多，**只有叶子结点才是有效信息**

正确代码：

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return dfs(root, targetSum);
}
private boolean dfs(TreeNode root, int targetSum) {
    // 为空直接返回false
    if (root == null) {
        return false;
    }
    // 如果是叶子结点判断当前这个叶子结点是否能凑够targetSum
    if (root.left == null && root.right == null) {
        return targetSum == root.val;
    }
    return dfs(root.left, targetSum - root.val) || dfs(root.right, targetSum - root.val);

}
```



**其他解法**

TODO



### 路径总和 II

#### 题目描述

[LeetCode113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)



#### 题解



**回溯**

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return res;
    }
    dfs(root, targetSum);
    return res;
}

private void dfs(TreeNode root, int targetSum) {
    // 递归终止1
    if (root == null) {
        return;
    }
    // 递归终止2 叶子结点只能在上一结点判断
    if (root.left == null && root.right == null) {
        if (targetSum == root.val) {
            // 当前结点的值还没添加到列表中，所以要先添加，然后再移除
            path.add(root.val);               
            res.add(new ArrayList<>(path));
            path.remove(path.size() - 1);
        }
        return;
    }
    // 下面就是经典的回溯 状态重置 其实可以再简洁一点 因为进入左右分支的 path 是一样的 所以可以省略掉左递归之后的remove 和 右递归之前的add 
    path.add(root.val);
    dfs(root.left, targetSum - root.val);
    path.remove(path.size() - 1);

    path.add(root.val);
    dfs(root.right, targetSum - root.val);
    path.remove(path.size() - 1);
}
```



也可以这样写，但是个人觉得上面那种比较容易理解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return res;
    }
    dfs(root, targetSum);
    return res;
}

private void dfs(TreeNode root, int targetSum) {
    // 递归终止1
    if (root == null) {
        return;
    }
    path.add(root.val); // 也可以把add写在if外面 注意add和remove一定可以在同一条件两个都能执行，否则就会状态重置出现问题
    // 递归终止2 叶子结点只能在上一结点判断
    if (root.left == null && root.right == null) {
        if (targetSum == root.val) {         
            res.add(new ArrayList<>(path));    
        }
        path.remove(path.size() - 1);
        return;
    }
    // 下面就是经典的回溯 状态重置 其实可以再简洁一点 因为进入左右分支的 path 是一样的 所以可以省略掉左递归之后的remove 和 右递归之前的add 
    dfs(root.left, targetSum - root.val);
    path.remove(path.size() - 1);

    path.add(root.val);
    dfs(root.right, targetSum - root.val);
    path.remove(path.size() - 1);
}
```





### 路径总和

#### 题目描述



#### 题解



**DFS**

在路径总和、路径总和 II中，我们设计了以下的递归，按这种思路一直递归下去，其实默认了一个条件：`root`这个结点一定在路径中，因为在调用`dfs`时，`tarSum`已经减去了`root.val`的一部分，相当于root已经充当了路径的一部分。

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.drawio.png)

但是对于这题而言，root不一定要在路径上，此时我们应该分类情况讨论

- root在路径上
- root不在路径上



![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E5%9B%BE.drawio.png)



```java
private int res = 0;
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return 0;
    }
    dfs(root, targetSum);
    return res;
}

// 只有在确定路径起点结点这一步中 每个结点才有选与不选两种选择
// 一旦路径起点被确定 后面的结点就一定要选上
private void dfs(TreeNode root, int targetSum) {
    if (root == null) {
        return;
    }
    // 选择root当路径
    dfsHasRoot(root, targetSum);
    // 不选root当路径
    dfs(root.left, targetSum);
    dfs(root.right, targetSum);
}

private void dfsHasRoot(TreeNode root, int targetSum) {
    // 注意因为结点值可能有负值，后面的路径可能还会满足res 所以不能直接return
    if (targetSum == root.val) {
        res += 1;
    }
    // 一旦root被选上当路径，也就是路径起点 root的子树一定要选，因为路径是连续的
    if (root.left != null) {
        dfsHasRoot(root.left, targetSum - root.val);
    }
    if (root.right != null) {
        dfsHasRoot(root.right, targetSum - root.val);
    }
}
```



**前缀和**



### 左子树之和

#### 题目描述

[LeetCode404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)



#### 题解

注意判断当前节点是不是左叶子是无法判断的，**必须要通过节点的父节点来判断其左孩子是不是左叶子**，条件是左孩子不为空且左孩子的孩子都为空，则该左孩子是叶子结点

**递归DFS**

```java
// 递归
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // curInfo表示当前root结点能获取到左叶子结点的信息
    int curInfo = 0;
    // Info表示root的孩子结点能获取到左叶子结点的信息
    int leftInfo = sumOfLeftLeaves(root.left);
    int rightInfo = sumOfLeftLeaves(root.right);
    // 判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子
    // 左孩子不为空且左孩子是叶子结点
    if (root.left != null && root.left.left == null && root.left.right == null) {
        curInfo = root.left.val;
    }
    // 返回信息和
    return curInfo + leftInfo + rightInfo;
}
```



**迭代DFS**

```java
// 迭代 前中都可以 
public int sumOfLeftLeaves(TreeNode root) {
    TreeNode cur = root;
    Deque<TreeNode> stack = new LinkedList<>();
    int res = 0;
    while(cur != null || !stack.isEmpty()) {
        if (cur != null) {
            if (cur.left != null && cur.left.left == null && cur.left.right == null) {
                res += cur.left.val;
            }
            stack.offer(cur);
            cur = cur.left;
        } else {
            cur = stack.poll();
            cur = cur.right;
        }
    }
    return res;
}
```



**层序遍历**

```java
// 层序遍历
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode cur = root;
    queue.offer(cur);
    int res = 0;
    while (!queue.isEmpty()) {
        cur = queue.poll();
        if (cur.left != null) {
            if (cur.left.left == null && cur.left.right == null) {
                res += cur.left.val;
            }
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }
    }
    return res;
}
```



### 二叉树的所有路径和

#### 题目描述

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)



#### 题解

**递归DFS**

```java
private List<String> res = new ArrayList<>();

public List<String> binaryTreePaths(TreeNode root) {
    if (root == null) {
        return res;
    }
    dfs(root, "");
    return res;
}

// path用的字符串 隐式回溯
private void dfs(TreeNode root, String path) {
    if (root == null) {
        return;
    }
    dfs(root.left, path + root.val + "->");
    dfs(root.right, path + root.val + "->");
    // 前序处理也是可以的
    if (root.left == null && root.right == null) {
        // 注意到了叶子结点就不需要加 -> 了
        res.add(path + root.val);
    }
}
```



**迭代DFS**

回溯其实用迭代的方法是不太好写

可以利用同一个栈，同时作为结点栈和路径栈

这里前序迭代跟我平时写的习惯不太一样

```java
// 迭代
public List<String> binaryTreePaths2(TreeNode root) {
    if (root == null) return res;
    Deque<Object> stack = new LinkedList<>();
    stack.push(root);
    stack.push(String.valueOf(root.val)); // 节点，当前路径
    while (!stack.isEmpty()) {
        // 注意pop的顺序要对应上
        String path = (String) stack.pop();
        TreeNode cur = (TreeNode) stack.pop();
        if (cur.left == null && cur.right == null) {
            res.add(path);
        }
        // 因为root的值先加了 所以 -> 后拼上
        if (cur.right != null) {
            stack.push(cur.right);
            stack.push(path + "->" + cur.right.val);
        }
        if (cur.left != null) {
            stack.push(cur.left);
            stack.push(path + "->" + cur.left.val);
        }
    }
    return res;
}
```



**BFS**

同理

```java
// bfs
public List<String> binaryTreePaths3(TreeNode root) {
    List<String> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Queue<Object> queue = new LinkedList<>();
    queue.offer(root);
    queue.offer(root.val + "");
    while (!queue.isEmpty()) {
        TreeNode cur = (TreeNode) queue.poll();
        String path = (String) queue.poll();
        //如果到叶子节点，说明找到了一条完整路径
        if (cur.left == null && cur.right == null) {
            res.add(path);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
            queue.offer(path + "->" + cur.right.val);
        }
        if (cur.left != null) {
            queue.offer(cur.left);
            queue.offer(path + "->" + cur.left.val);
        }
    }
    return res;
}
```



### 求根节点到叶节点数字之和

#### 题目描述

[LeetCode129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)



#### 题解



**回溯**

代码1：

最容易理解的做法

```java
public int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    dfs(root);
    return res;
}

// 回溯
private void dfs(TreeNode root) {
    // 递归终止1
    if (root == null) {
        return;
    }
    // 递归终止2
    if (root.left == null && root.right == null) {
        path.add(root.val);
        res += getValue(path);
        path.remove(path.size() - 1);
        return;
    }
    // 经典回溯
    path.add(root.val);
    dfs(root.left);
    path.remove(path.size() - 1);

    path.add(root.val);
    dfs(root.right);
    path.remove(path.size() - 1);
}

// 转化成正确的值
private int getValue(List<Integer> path) {
    int n = path.size();
    int value = 0;
    for (int i = 0; i < n; i++) {
        // 10的n - 1 - i 次方 乘上 i位的值
        value += Math.pow(10, n - 1 - i) * path.get(i);
    }
    return value;
}

// 对于转化成数值还可以 只不过一个是一次性扩大次方，一个是逐步扩大
/*
private int getValue2(List<Integer> path) {
    int value = 0;
    for (int i : path) {
        value += i * 10 + path.get(i);
    }
    return value;
}
*/
```



代码2：

对于路径变量可以选择字符串，并当做方法参数，可以做隐式回溯，自动做一个状态重置，并且字符串做path的话转换成数值也会简单很多。

```java
private int res = 0;
public int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    dfs(root, "");
    return res;
}

// 回溯
private void dfs(TreeNode root,String path) {
    // 递归终止1
    if (root == null) {
        return;
    }
    path += root.val;
    // 递归终止2
    if (root.left == null && root.right == null) {
        res += Integer.parseInt(path);
        return;
    }
    // 经典回溯
    dfs(root.left, path);
    dfs(root.right, path);
}
```



代码3：

别的题解，直接将累加和当做参数传递，不是很常规的做法

```java
public int sumNumbers(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return sumNumbers(root, 0);
}

private int sumNumbers(TreeNode root, int cumsum) {
    if (root == null) {
        return 0;
    }
    cumsum = 10 * cumsum + root.val;
    if (root.left == null && root.right == null) {
        return cumsum;
    }
    return sumNumbers(root.left, cumsum) + sumNumbers(root.right, cumsum);
}
```



### 二叉树层序遍历进阶

#### 问题描述

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```



#### 题解

层序遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> levelList;
    if (root == null) {
        return res; 
    }
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    int levelCount = 0;
    while (!queue.isEmpty()) {
        levelList = new ArrayList<>();
        levelCount = queue.size();
        for (int i = 0; i < levelCount; i++) {
            cur = queue.poll();
            // 记录一层的信息
            levelList.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        // 记录每一层的信息
        res.add(levelList);
    }
    return res;
}
```



总结：最大宽度和该题都是**层次划分**的套路，每次while循环记录一下levelCount，按levelCount在里面for循环遍历即可

### 树与二叉树的转化

### 折痕问题

#### 题目描述

```java
* 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。
* 此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。
* 如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，
* 从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，
* 请从上到下打印所有折痕的方向。 例如：
* N=1时，
* 打印： down
* N=2时，
* 打印： down down up
```



#### 题解

```java
/**
 * 实际上就是一颗二叉树 折痕当做结点
 * 该树的特点 树的根节点是凹 左孩子结点为凹 右孩子结点为凸
 * 用 i 表示层数 如果是纸条从上往下打印 就是中序遍历
 * @param N
 */
public static void printAllFolding(int N) {
    inOrder(1, N, true);
}

public static void inOrder(int i, int N, boolean isDown) {
    if (i > N) {
        return;
    }
    inOrder(i + 1, N, true);
    System.out.print(isDown ? "第" + i + "次凹 " : "第" + i + "次凸 ");
    inOrder(i + 1, N, false);
}
```



### 二叉树完全性检验

#### 题目描述

[958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

给定一个二叉树的 `root` ，确定它是否是一个 *完全二叉树* 。

在一个 **[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)** 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 `1` 到 `2h` 节点之间的最后一级 `h` 。

 

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/complete-binary-tree-1.png)

```
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
```

**示例 2：**

**![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/complete-binary-tree-2.png)**

```
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
```

 

#### 题解

层序遍历框架改写加两个原则：

- 有右孩子但是没有左孩子，必不为完全二叉树
- 某一层中若出现某结点的子树不全(只有一个孩子或者没有孩子)，则剩下结点若不都是叶子结点，必不为完全二叉树

层序遍历完全，若不违反上面两个原则，则为完全二叉树

```java
public static boolean isCompleteBTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    // 是否有孩子不全的结点
    boolean isNotFullChild = false;
    TreeNode cur = root;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(cur);
    while (!queue.isEmpty()) {
        cur = queue.poll();

        // 第一种情况：有孩子不全的结点出现且后面结点不都为叶子结点
        // 第二种情况：右子树为空且左子树不为空
        if ((isNotFullChild && (cur.left != null || cur.right != null))
                || (cur.right != null && cur.left == null)) {
            return false;
        }

        if (cur.left != null) {
            queue.offer(cur.left);
        }
        if (cur.right != null) {
            queue.offer(cur.right);
        }

        // 第一次出现孩子不全的结点，进行标记
        // 标记一定要在最后进行，因为我们判断的是之后的结点是否都为叶子结点，
        // 如果if放在前面会出现把自己标记，又拿自己参与判断的情况
        if (cur.left == null || cur.right == null) {
            isNotFullChild = true;
        }

    }
    return true;
}
```



### 平衡二叉树

#### 题目描述

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```



#### 题解

虽然不是最优解，但是是比较容易理解的自顶向下递归方式

1. **找整个递归的终止条件：递归应该在什么时候结束？**
2. **找返回值：应该给上一级返回什么信息？**
3. **本级递归应该做什么：在这一级递归中，应该完成什么任务？**

我们只需要关心最顶层的递归需要做什么才能得到答案

判断一颗二叉树是否为平衡二叉树的条件：

- 左子树为平衡二叉树
- 右子树为平衡二叉树
- 左右子树的高度差不大于1

上面三个条件只要满足了，整颗二叉树就是平衡二叉树

那我们只需要每次递归中返回子树的两个信息：是否为平衡二叉树和最深深度

将这两个信息进行处理就能得到答案

```java
public static class Info{
    public boolean isBalanced;
    public int depth;
    public Info(boolean isBalanced,int depth) {
        this.isBalanced = isBalanced;
        // 深度
        this.depth = depth;
    }
}
public static boolean isBalanced(TreeNode root) {
    return process(root).isBalanced;
}
public static Info process(TreeNode root) {
    // 为空 递归结束 返回信息
    if (root == null) {
        return new Info(true,0);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean isBalanced = true;
    // 子树中最深的一条路径 + 1 就是root的最深路径
    int depth = Math.max(leftInfo.depth,rightInfo.depth) + 1;
    // 不同时满足三个条件的root就不是平衡二叉树
    if (!leftInfo.isBalanced || !rightInfo.isBalanced
            || Math.abs(leftInfo.depth - rightInfo.depth) > 1) {
        isBalanced = false;
    }
    return new Info(isBalanced,depth);
}
```



如果不用info类这种套路的话，我们依然是需要记录子树的信息的，左右子树是否为平衡二叉树和左右子树的高度差，显然直接使用`boolean`类型记录是不够用的，我们使用一个`int`类型就能表示我们需要的所有信息，`-1`表示不平衡，非负整数表示树的高度

```java
public boolean isBalanced(TreeNode root) {
    return getHeight(root) != -1;
}
private int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = getHeight(root.left);
    int rightHeight = getHeight(root.right);
    // 左右子树至少有一个没有平衡性 则整颗树不平衡
    if (leftHeight == -1 || rightHeight == -1) {
        return -1;
    }
    // 左右子树都为平衡二叉树 但是左右子树高度差大于1
    if (Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    }
    // 返回以root为根的树的高度
    return Math.max(leftHeight, rightHeight) + 1;
}
```



### 二叉树直径

#### 题目描述

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。



#### 题解

DFS求左右子树的最深路径，左右子树最深路径之和的最大值就是直径

```java
private int res = 0;
public int diameterOfBinaryTree(TreeNode root) {
    process(root);
    // 注意是返回res 不是process的返回值
    return res;
}
public int process(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = process(root.left);
    int rightDepth = process(root.right);
    res = Math.max(res, leftDepth + rightDepth);
    // 返回左右子树的最深一条路径 加上来自己的一个距离
    return Math.max(leftDepth, rightDepth) + 1;
}
```

比如对于4来说，它的左右子树最深路径都为0，返回的时候要加上来4的一个距离

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220201214320795.png)

整棵树的其中一个直径就是1的左子树2的最深路径加上1的右子树3的最深路径

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220201214638741.png)



### 满二叉树检验

#### 问题描述

```
对于满二叉树的定义，国内外不一样
* 国内：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
* 国外：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。
* 这里算法按照国内的来
```

所以满二叉树满足    结点数= 2 ^ 二叉树的深度 - 1，

我们只需要返回每棵子树的结点数和深度就可以进行递归判断

#### 题解

```java
public static class Info {
    public int depth;
    public int nodes;

    public Info(int depth, int nodes) {
        this.depth = depth;
        this.nodes = nodes;
    }
}

public static boolean isFullBTree(TreeNode root) {
    Info rootInfo = process(root);
    //return Math.pow(2, rootInfo.depth) - 1 == rootInfo.nodes;
    // 次方可以用位运算
    return (1 << rootInfo.depth) - 1 == rootInfo.nodes;
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(0, 0);
    }

    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);
    int curDepth = Math.max(leftInfo.depth, rightInfo.depth) + 1;
    int curNodes = leftInfo.nodes + rightInfo.nodes + 1;
    return new Info(curDepth, curNodes);
}
```



## 二叉搜索树

- [ ] 删除二叉搜索树中的节点 
- [ ] 看二叉搜索树的基本操作
- [ ] ceshi 
- [ ] ceshi 

### 验证二叉搜索树

#### 问题描述

[LeetCode98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/BSTree.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`



#### 题解

思路一，可以用中序遍历验证是否升序

思路二，递归

**容易理解的递归**

- root的左子树满足二叉搜索树
- root的右子树满足二叉搜索树
- 左子树的最大值严格小于root.val且右子树的最小值严格大于root.val

**因为判断root == null 在递归中info比较难处理，那就换个思路，子树不为null才进入递归**

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return process(root).isBST;
}

public class Info {
    public int max;
    public int min;
    public boolean isBST;
    public Info(boolean isBST, int max, int min) {
        this.isBST = isBST;
        this.max = max;
        this.min = min;
    }
}

public Info process(TreeNode root) {
    Info curInfo = new Info(true, root.val, root.val);
    if (root.left != null) {
        Info leftInfo = process(root.left);
        if (!leftInfo.isBST || leftInfo.max >= root.val) {
            curInfo.isBST = false;
        }
        // 只需要在左子树更新最小值和在右子树更新最大值，就算出现了不是搜索子树导致更新最值不正确也没什么所谓，因为已经记录的false值了
        //curInfo.max = Math.max(leftInfo.max,root.val);
        curInfo.min = Math.min(leftInfo.min, root.val);
    }
    if (root.right != null) {
        Info rightInfo = process(root.right);
        if (!rightInfo.isBST || rightInfo.min <= root.val) {
            curInfo.isBST = false;
        }
        curInfo.max = Math.max(rightInfo.max, root.val);
        //curInfo.min = Math.min(rightInfo.min,root.val);
    }
    return curInfo;
}
```

个人比较习惯写法：

还是在递归里处理null

```java
public static Info process2(TreeNode root) {
    if (root == null) {
        return new Info(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process2(root.left);
    Info rightInfo = process2(root.right);
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    boolean curIsBST = false;
    if (leftInfo.isBST && rightInfo.isBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curIsBST = true;
    }
    return new Info(curIsBST, curMax, curMin);
}
```



**DFS**

其他写法

```java
// 更新
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return dfs(root, null, null);
}

private boolean dfs(TreeNode node, Integer min, Integer max) {
    if (node == null) {
        return true;
    }
    if (min != null && min >= node.val) {
        return false;
    }
    if (max != null && max <= node.val) {
        return false;
    }
    return dfs(node.left, min, node.val) && dfs(node.right, node.val, max);
}
```



**中序遍历**

```java
// 中序遍历验证
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }

    List<Integer> res = new ArrayList<>();
    inOrder(root, res);

    int n = res.size();
    // 注意边界
    for (int i = 0; i < n - 1; i++) {
        if (res.get(i + 1) <= res.get(i)) {
            return false;
        }
    }
    return true;
}

private void inOrder(TreeNode node, List<Integer> res) {
    if (node == null) {
        return;
    }
    inOrder(node.left, res);
    res.add(node.val);
    inOrder(node.right, res);
}
```



### 最大二叉搜索树

#### 题目描述

leetcode333

给定一个二叉树，找到其中最大的二叉搜索树（DataStructure.BST）子树，其中最大指的是子树节点数最多的。注意：子树必须包含其所有后代。

#### 题解

递归套路，自顶向下跟子树要信息

返回最大结点数量

```java
public static int findMaxSubBSTreeSize(TreeNode root) {
    /*if (root == null) {
        return 0;
    }*/
    return process(root).maxBSTSubTreeSize;
}

public static class Info {
    public boolean isAllBST;
    public int maxBSTSubTreeSize;
    public int max;
    public int min;

    public Info(boolean isAllBST, int maxBSTSubTreeSize, int max, int min) {
        this.isAllBST = isAllBST;
        this.maxBSTSubTreeSize = maxBSTSubTreeSize;
        this.max = max;
        this.min = min;
    }
}

public static Info process(TreeNode root) {
    if (root == null) {
        return new Info(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    Info leftInfo = process(root.left);
    Info rightInfo = process(root.right);

    boolean curIsAllBST = false;
    int curMin = Math.min(root.val, Math.min(leftInfo.min, rightInfo.min));
    int curMax = Math.max(root.val, Math.max(leftInfo.max, rightInfo.max));
    // 若左右子树都不存在搜索树 curMaxBSTSubTreeSize默认值就是1 自身一个节点（假定只有一个结点时也是二叉搜索树）
    int curMaxBSTSubTreeSize = 1;
    // 子树存在最大二叉搜索树，取其最大值
    if (leftInfo.maxBSTSubTreeSize != 0 || rightInfo.maxBSTSubTreeSize != 0) {
        curMaxBSTSubTreeSize = Math.max(leftInfo.maxBSTSubTreeSize, rightInfo.maxBSTSubTreeSize);
    }
    // 左右子树整颗都为二叉搜索树且满足左子树最大值 < root.val 右子树最小值> root.val
    // 更新curMaxBSTSubTreeSize 等于左+右+自身的一个节点
    if (leftInfo.isAllBST && rightInfo.isAllBST && leftInfo.max < root.val && rightInfo.min > root.val) {
        curMaxBSTSubTreeSize = leftInfo.maxBSTSubTreeSize + rightInfo.maxBSTSubTreeSize + 1;
        curIsAllBST = true;
    }
    return new Info(curIsAllBST, curMaxBSTSubTreeSize, curMax, curMin);
}
```

返回最大二叉搜索子树





### 二叉搜索树的最近公共祖先

#### 题目描述

[LeetCode235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)



#### 题解



**DFS**

根据 p、q 结点的位置分类讨论

- p、q 结点位于 node 结点的两侧，则 node 结点就是 p、q 最近公共祖先
- p、q 结点都位于 node 结点同一侧，则它们的最近公共祖先一定在 p、q 所在的一侧，继续递归调用 p、q 所在的一侧的子树
- p、q 其中之一位于 node 结点，则 node 结点就是 p、q 最近公共祖先

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%881.drawio.png)





### 删除二叉搜索树中的节点

#### 题目描述

[LeetCode450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

#### 题解



### 将有序数组转换为二叉搜索树

#### 题目描述

[LeetCode108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

#### 题解





### 二叉搜索树中第K小的元素

#### 题目描述

[LeetCode230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

#### 题解



# 并查集

### 模板

并查集的两个优化

- 路径压缩
- 按秩合并

同时使用两个的话，并查集的查询和合并的效率是可以达到O(1)的

```java
/**
 * 经典并查集
 *
 * @author novo
 * @date 2022/2/3-22:39
 */
public class UnionFindSet {
    private int[] parent;
    private int[] rank;

    public UnionFindSet(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
    }

    public void build(int n) {
        for (int i = 0; i < n; i++) {
           	rank[i] = 1;
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            //return find(parent[x]);
            // 在返回的路上进行路径压缩 在每次查找时 把查找路径上(注意只压缩路径上的)的每个结点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int x, int y) {
        if (x == y) {
            return;
        }
        // 将x接到y
        parent[find(x)] = find(y);
    }

    // 按秩合并
    public void union2(int x, int y) {
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
    }

    // 返回集合个数
    public int getUnionSize(int n) {
        int size = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i) {
                size++;
            }
        }
        return size;
    }
}
```



### 1、省份数量

#### 题目描述

[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

**示例 1：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/graph1.jpg)

```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

**示例 2：**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/graph2.jpg)

```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```



#### 题解

经典并查集模型

如果相连，就加入同一集合，最后返回集合的个数

```java
private int[] parent;
public int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}
public void union(int x, int y) {
    if (x == y) {
        return;
    }
    parent[find(x)] = find(y);
}
public int getUnionSize(int n) {
    int size = 0;
    for (int i = 0; i < n; i++) {
        if (find(i) == i) {
            size++;
        }
    }
    return size;
}
public int findCircleNum(int[][] isConnected) {
    int n = isConnected.length;
    parent = new int[n];
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
    // j = i + 1 只遍历右上角且不遍历对角线 因为对称
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                union(i, j);
            }
        }
    }
    // 返回并查集集合的个数
    return getUnionSize(n);
}
```



### 2、岛屿数量

#### 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等1527收藏分享切换为英文接收动态反馈

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示**：

- ```
  m == grid.length
  ```

- ```
  n == grid[i].length
  ```

- ```
  1 <= m, n <= 300
  ```

- ```
  grid[i][j] 的值为 '0' 或 '1'
  ```

  

#### 题解

看题目给的数据范围，时间复杂度O(m * n)是可以的

##### **深搜**

把数组都遍历一遍，将所有为1的都合并在一起，为1的进去递归，对上下左右都递归，形象的比喻成感染，对上下左右感染，递归退出则合并完毕

```java
public int numIslands(char[][] grid) {
    int islands = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == '1') {
                islands++;
                merge(grid, i, j);
            }
        }
    }
    return islands;
}

public void merge(char[][] grid, int i, int j) {
    if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] != '1') {
        return;
    }
    grid[i][j] = 'X';
    merge(grid, i - 1, j);
    merge(grid, i + 1, j);
    merge(grid, i, j - 1);
    merge(grid, i, j + 1);
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220204234121850.png)

##### **并查集**

把都为1的合并

二维数组使用并查集需要将每个二维坐标转换成一维坐标，就能使每个索引唯一

```
(i, j) ==> i * 列数 + j
就是将二维数组转换成一维数组该怎么表示
```



```java
public class UnionFindSet {
    // 并查集模板...
}
public int numIslands(char[][] grid) {
    // 方向数组
    int[][] directs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int m = grid.length;
    int n = grid[0].length;
    // 需要记录0的地方
    int zero = 0;
    UnionFindSet set = new UnionFindSet(m * n);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                // 检索四个方向
                for (int[] direct : directs) {
                    int x = i + direct[0];
                    int y = j + direct[1];
                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == '1') {
                        // 合并
                        set.union(x * n + y, i * n + j);
                    }
                }
            } else {
                zero++;
            }
        }
    }
    // 注意要记录0的数量 减去0的数量
    return set.getUnionSize(m * n) - zero;
}
```

虽然代码量比较多，而且跑出来执行用时不太好看，但是跟深搜都是一样的时间复杂度O(m * n)，都是最优解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220204233443138.png)





### 3、岛屿数量 II

#### 题目描述

[305. 岛屿数量 II](https://leetcode-cn.com/problems/number-of-islands-ii/)

给你一个大小为 `m x n` 的二进制网格 `grid` 。网格表示一个地图，其中，`0` 表示水，`1` 表示陆地。最初，`grid` 中的所有单元格都是水单元格（即，所有单元格都是 `0`）。

可以通过执行 `addLand` 操作，将某个位置的水转换成陆地。给你一个数组 `positions` ，其中 `positions[i] = [ri, ci]` 是要执行第 `i` 次操作的位置 `(ri, ci)` 。

返回一个整数数组 `answer` ，其中 `answer[i]` 是将单元格 `(ri, ci)` 转换为陆地后，地图中岛屿的数量。

**岛屿** 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/10/tmp-grid.jpg)

```
输入：m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
输出：[1,1,2,3]
解释：
起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
- 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。此时存在 2 个岛屿。
- 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。此时存在 3 个岛屿。
```

**示例 2：**

```
输入：m = 1, n = 1, positions = [[0,0]]
输出：[1]
```

注意：addland可能出现同一个位置

**提示：**

- `1 <= m, n, positions.length <= 104`
- `1 <= m * n <= 104`
- `positions[i].length == 2`
- `0 <= ri < m`
- `0 <= ci < n`

**进阶：**你可以设计一个时间复杂度 `O(k log(mn))` 的算法解决此问题吗？（其中 `k == positions.length`）



#### 题解

这题只能用并查集求连通分量，相比于岛屿数量问题1，它是动态的生成岛屿，而不是全部给出来

对于每个 addLand 操作。需要注意的逻辑是：

如果 addLand 操作的顶点已经访问过，跳过；
如果 addLand 操作的顶点没有访问过，此时需要增加连通分量个数，然后再将它与「上」「下」「左」「右」合并。



```java
public List<Integer> numIslands2(int m, int n, int[][] positions) {
    UnionFindSet set = new UnionFindSet(m * n);
    List<Integer> res = new ArrayList<>();
    int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] position : positions) {
        int i = position[0];
        int j = position[1];
        set.visited[i * n + j] = true;
        for (int[] direct : directs) {
            int x = i + direct[0];
            int y = j + direct[1];
            // x、y没有越界且已经变成岛屿
            if (x >= 0 && y >= 0 && x < m && y < n && set.visited[x * n + y]) {
                set.union2(i * n + j, x * n + y);
            }
        }
        res.add(set.getUnionSize(m * n));
    }
    return res;
}

public class UnionFindSet {
    private int[] parent;
    private int[] rank;
    public boolean[] visited;
	// ...省略常用方法
    // 返回集合个数
    public int getUnionSize(int n) {
        int size = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i && visited[i]) {
                size++;
            }
        }
        return size;
    }
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220205151254844.png)



差点超时了，如果降落的次数为k的话，总的时间复杂度是O(k + m * n)，速度太慢应该是，每次降落后都要调用set.getUnionSize(m * n)查询连通分量，于是对并查集进行了优化，再定义一个size变量来记录连通分量。

```java
public List<Integer> numIslands2(int m, int n, int[][] positions) {
    UnionFindSet set = new UnionFindSet(m * n);
    List<Integer> res = new ArrayList<>();
    int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] position : positions) {
        int i = position[0];
        int j = position[1];
        // 注意没被降落过的才size++
        if (!set.visited[i * n + j]) set.size++;
        set.visited[i * n + j] = true;
        for (int[] direct : directs) {
            int x = i + direct[0];
            int y = j + direct[1];
            // x、y没有越界且已经变成岛屿
            if (x >= 0 && y >= 0 && x < m && y < n && set.visited[x * n + y]) {
                // 注意合并的方法这里需要判断是否已经合并过 否则size不准
                set.union2(i * n + j, x * n + y);
            }
        }
        // 直接返回set.size
        res.add(set.size);
    }
    return res;
}

public class UnionFindSet {
    private int[] parent;
    private int[] rank;
    private int size;
    public boolean[] visited;
    public UnionFindSet(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
        this.visited = new boolean[size];
        build(size);
    }

    public void build(int n) {
        for (int i = 0; i < n; i++) {
            visited[i] = false;
            rank[i] = 1;
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            //return find(parent[x]);
            // 在返回的路上进行路径压缩 在每次查找时 把查找路径上(注意只压缩路径上的)的每个结点直接指向根节点
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 注意合并的时候需要判断 是否已经合并过了，因为测试用例可能会重复，否则size会多减
    public void union(int x, int y) {
        if (x == y) {
            return;
        }
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        // 将x接到y
        parent[x] = y;
        size--;
    }

    // 按秩合并
    public void union2(int x, int y) {
        x = find(x);
        y = find(y);
        // 两个结点代表结点相同 不用合并
        if (x == y) {
            return;
        }
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
        size--;
    }
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220205152410321.png)







# 递归与回溯

这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， **为什么有的时候用 `used` 数组，有的时候设置搜索起点 `begin` 变量**，理解状态变量设计的想法。

回溯其实就是横向遍历，纵向递归的组合。

说白了就是一种尝试的过程，试过了返回再次尝试下一种可能



## 排列

### 全排列

#### 题目描述

[LeetCode46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]] 
```

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used ;
public List<List<Integer>> permute(int[] nums) {
    if (nums == null || nums.length == 0) {
        return res;
    }
    used = new boolean[nums.length];
    backTracking(nums, 0);
    return res;
}

// path和index都可以作为可变参数 需要知道为什么传这个参数，这个参数的目的，而不是固定传参
public void backTracking(int[] nums, int index) {
    if (index == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++){
        if(!used[i]) {
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums, index + 1);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



### 全排列 II

#### 题目描述

[LeetCode47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

 

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

#### 题解

去重

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> permuteUnique(int[] nums) {
    used = new boolean[nums.length];
    Arrays.sort(nums);
    backTracking(nums);
    return res;
}

public void backTracking(int[] nums) {
    if (path.size() == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (!used[i]) {
            // used[i - 1] == false 说明被回溯过 回到同一层，若此时nums[i] == nums[i - 1]说明在树层出现重复，即深搜起点一样需要剪枝
            // 当used[i - 1] == true 说明在深搜树枝，可以重复
            if (i > 0 && !used[i - 1] && nums[i] == nums[i - 1]) {
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums);
            // 回溯
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



### 字符串的排列

#### 题目描述

[剑指 Offer 38. 字符串的排列](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

 

**示例:**

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

 

**限制：**

```
1 <= s 的长度 <= 8
```

#### 题解

全排列 II 解法

```java
private boolean[] visited;
List<String> res = new ArrayList<>();
public String[] permutation(String s) {
    visited = new boolean[s.length()];
    char[] charArr = s.toCharArray();
    Arrays.sort(charArr);
    dfs(charArr, "",0);
    return res.stream().toArray(String[]::new);
}
private void dfs(char[] charArr, String path,int index) {
    if (index == charArr.length) {
        res.add(path);
        return;
    }

    for (int i = 0; i < charArr.length; i++) {
        if (!visited[i]) {
            // 去重
            if (i > 0 && !visited[i - 1] && charArr[i] == charArr[i - 1]) {
                continue;
            }
            visited[i] = true;
            dfs(charArr, path + charArr[i], index + 1);
            visited[i] = false;
        }
    }
}
```



## 组合

```
// 按序搜索是避免 出现组合重复 [2, 2, 1], [2, 1, 2]
// 而used数组是为了避免在同一层级上选到值一样的元素 第三位的2虽然来源不相等 但是他们的值是一样的 [2, 1, 2], [2, 1, 2]
```



### 电话号码的字母组合

#### 题目描述

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。



#### 题解

时间复杂度: `O(2^len(digits.length))`

时间复杂度: `O(log(len(digits.length))`

以digits == "23"为例：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220207133312605.png)

```java
private String[] letterMap = {
            " ",   // 0
            "",    // 1
            "abc", // 2
            "def", // 3
            "ghi", // 4
            "jkl", // 5
            "mno", // 6
            "pqrs",// 7
            "tuv", // 8
            "wxyz" // 9
    };
    private List<String> res = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        // 测试用例为空时 输出：[] 而不是[""]
        if ("".equals(digits)){
            return res;
        }
        String path = "";
        backTracking(digits.toCharArray(), 0, path);
        return res;
    }

    public void backTracking(char[] digits, int index, String path) {
        System.out.println(index + ":" + path);
        if (index == digits.length) {
            res.add(path);
            return;
        }
        // 减去'0' 对应的就是哪个letter
        String letters = letterMap[digits[index] - '0'];
        int n = letters.length();
        for (int i = 0; i < n; i++) {
            System.out.println("digits[" + index + "] = " + path + " , use " + letters.charAt(i));
            backTracking(digits, index + 1, path + letters.charAt(i));
        }
        System.out.println("digits[" + index + "] = " + path + " complete, return");
    }
```



### 组合

#### 题目描述

[77. 组合](https://leetcode-cn.com/problems/combinations/)

#### 题解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220208153744231.png)



```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combine(int n, int k) {
    if (n <= 0 || k <= 0 || k > n) {
        return res;
    }
    backTracking(n, k, 1);
    return res;
}

public void backTracking(int n, int k, int index) {
    if (path.size() == k) {
        res.add(new ArrayList<>(path));
        return;
    }
    // [1, n]的组合 所以index从1开始 <= n
    // 还剩 k - path.size() 个空位，所以[i...n]中至少要有k-path.size()个元素
    // 例如至少要有2个元素 i要<= n-1 至少要有1个元素 i <= n
    for (int i = index; i <= n - (k - path.size()) + 1; i++) {
        /*if (path.size() >= k) {
            break;
        }*/
        path.add(i);
        /*System.out.println("index:" + index);
        System.out.println("path: " + path);*/
        backTracking(n, k, i + 1);
        path.remove(path.size() - 1);
    }
}
```



### 组合总和

#### 题目描述

[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

#### 题解

核心点就是用i来控制在一次深搜中可以回头，出现分支(另一次深搜)不可以回头

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    if (candidates == null || candidates.length == 0) {
        return res;
    }
    backTracking(candidates, 0, target);
    return res;
}

// 使用index
public void backTracking(int[] candidates, int index, int target) {
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        if (candidates[i] > target) {
            // 没用排序 只能continue  如果用排序的话可以直接break
            continue;
        }
        path.add(candidates[i]);
        // 可以用i来控制每次的深搜都可以选所有值，而不是i+1 一次完整的深搜到尽头后才会++，又保证的下一次深搜不会选到重复的值
        backTracking(candidates, i, target - candidates[i]);
        path.remove(path.size() - 1);
    }
}
```



### 组合总和 II

#### 题目描述

[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)



#### 题解

总结：

给定数组中可能出现重复元素，每次不能选相同位置的元素，用used数组，不能回头

给定数组中不会出现重复元素，而每次可以选相同的位置元素的情况下，不需要used数组，可以回头

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    if (candidates == null || candidates.length == 0) {
        return res;
    }
    used = new boolean[candidates.length];
    Arrays.sort(candidates);
    backTracking(candidates, 0, target);
    return res;
}

public void backTracking(int[] candidates, int index, int target) {
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        // 去重 used[i - 1] == false 说明现在处在同一层 被回溯过不可以选
        if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
            continue;
        }
        // 剪枝
        if (candidates[i] > target) {
            // 已经有序 可以break
            break;
            //continue;
        }
        used[i] = true;
        path.add(candidates[i]);
        backTracking(candidates, i + 1, target - candidates[i]);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}
```



### 组合总和 III

#### 题目描述

[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)



#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> combinationSum3(int k, int n) {
    if (k == 0) {
        return res;
    }
    backTracking(k, 1, n);
    return res;
}

public void backTracking(int k, int index, int n) {
    // 如果path大小等于k都要return，不需要继续深搜
    if (path.size() == k) {
        if(n == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }
    // 只能选1~9且不能重复 数据太小剪枝意义不大
    for (int i = index; i <= 9; i++) {
        path.add(i);
        backTracking(k, i + 1, n - i);
        path.remove(path.size() - 1);
    }
}
```



### 组合总和 Ⅳ

#### 题目描述

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

#### 题解

这里不能用回溯，回溯会超时

[点击跳转](#combination-sum-iv)

### 二进制手表

#### 题目描述

google面试题

[401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)



#### 题解

```java
// 比较巧妙的是这两个hours和minutes数组，相当于将所有灯的选择都合并在一起，
// for横向遍历的时候都选择两个数组的元素，实际上只选择了一个，因为另一个是0
int[] hours = new int[]{1, 2, 4, 8, 0, 0, 0, 0, 0, 0};
int[] minutes = new int[]{0, 0, 0, 0, 1, 2, 4, 8, 16, 32};
List<String> res = new ArrayList<>();

public List<String> readBinaryWatch(int turnedOn) {
    backTracking(turnedOn, 0, 0, 0);
    return res;
}

public void backTracking(int turnedOn, int index, int hour, int minute) {
    //4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。
    if (hour > 11 || minute > 59) {
        return;
    }
    if (turnedOn == 0) {
        StringBuilder path = new StringBuilder();
        path.append(hour).append(":");
        if (minute < 10) {
            path.append("0");
        }
        path.append(minute);
        res.add(path.toString());
        return;
    }
    for (int i = index; i < 9; i++) {
        backTracking(turnedOn - 1, i + 1, hour + hours[i], minute + minutes[i]);
        // 回溯体现在hour + hours[i]、minute + minutes[i]这个操作只是做了参数传递，退出来后hour已经还原了
    }
}
```



### 所有可能的路径

#### 题目描述

[LeetCode797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/all_1.jpg)

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/all_2.jpg)

```
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

 

**提示：**

- `n == graph.length`
- `2 <= n <= 15`
- `0 <= graph[i][j] < n`
- `graph[i][j] != i`（即不存在自环）
- `graph[i]` 中的所有元素 **互不相同**
- 保证输入为 **有向无环图（DAG）**



#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    if (graph.length == 0) {
        return res;
    }
    path.add(0);
    dfs(graph, 0);
    return res;
}

private void dfs(int[][] graph, int index) {
    if (index == graph.length - 1) {
        res.add(new ArrayList<>(path));
        return;
    }
    // 当前点能到达哪些点
    int[] arr = graph[index];
    for (int i = 0; i < arr.length; i++) {
        path.add(arr[i]);
        // index 为当前点
        dfs(graph, arr[i]);
        path.remove(path.size() - 1);
    }
}
```



## 子集

### 子集

#### 题目描述

[78. 子集](https://leetcode-cn.com/problems/subsets/)



#### 题解

求子集问题，本质就是要遍历整颗树，不需要剪枝



**第一种思路**

对于每个位置，只有选与选两种抉择，本质上就是一颗二叉树

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1643212121-zZXdpR-image.png)

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    backTracking(nums, 0, path);
    return res;
}

public void backTracking(int[] nums, int index, List<Integer> path) {
    if (index == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    // 为什么不需要for循环 因为本质上就是一颗二叉树 每个结点只有选和不选两种选择，而不是选什么元素的问题
    // 不选
    backTracking(nums, index + 1, path);

    // 选
    path.add(nums[index]);
    backTracking(nums, index + 1, path);
    path.remove(path.size() - 1);
```



**第二种思路**

关心选什么元素，也就是最常见的回溯，需要for遍历

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631607104-NFVwFo-file_1631607104526)

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    backTracking(nums, 0, path);
    return res;
}

public void backTracking(int[] nums, int index, List<Integer> path) {
    res.add(new ArrayList<>(path));
    // 这里判断可以省略 
    if (path.size() == nums.length) {
        return;
    }
    for (int i = index; i < nums.length; i++) {
        path.add(nums[i]);
        backTracking(nums, i + 1, path);
        path.remove(path.size() - 1);
    }
}
```





### 子集 II

#### 题目描述

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

在子集1的问题上加了used去重以及按序搜索排除组合重复

#### 题解

```java
private List<List<Integer>> res = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
private boolean[] used;
public List<List<Integer>> subsetsWithDup(int[] nums) {
    if (nums == null || nums.length == 0) {
        res.add(new ArrayList<>());
        return res;
    }
    Arrays.sort(nums);
    used = new boolean[nums.length];
    backTracking(nums, 0);
    return res;
}

public void backTracking(int[] nums, int index) {
    res.add(new ArrayList<>(path));
    // 终止条件可以不写
    if (index == nums.length) {
        return;
    }

    for (int i = index; i < nums.length; i++) {
        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false){
            continue;
        }
        used[i] = true;
        path.add(nums[i]);
        backTracking(nums, i + 1);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}
```



### 活字印刷

#### 题目描述

[LeetCode1079. 活字印刷](https://leetcode-cn.com/problems/letter-tile-possibilities/)

你有一套活字字模 `tiles`，其中每个字模上都刻有一个字母 `tiles[i]`。返回你可以印出的非空字母序列的数目。

**注意：**本题中，每个活字字模只能使用一次。

 

**示例 1：**

```
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```

**示例 2：**

```
输入："AAABBC"
输出：188
```

**示例 3：**

```
输入："V"
输出：1
```

 

#### 题解

**全排列思路**

常规解法，将问题转化为全排列 II，对每个长度的子串进行去重全排列。

例 titles 为 "AAB"

长度为1的去重全排列可能性为：A、B

长度为2的去重全排列可能性为：AA、AB、BA

长度为3的去重全排列可能性为：AAB、ABA、BAA

```java
private int res = 0;
private boolean[] used;
public int numTilePossibilities(String tiles) {
    used = new boolean[tiles.length()];
    char[] str = tiles.toCharArray();
    Arrays.sort(str);
    for (int i = 1; i <= str.length; i++) {
        // 对每个长度的子串进行去重全排列
        // 如排序后titles为AAB 则求每一个长度的全排列总数和
        dfs(str, i);
    }
    return res; // 减去 ""
}

private void dfs(char[] str, int index) {
    if (index == 0) {
        res++;
    }
    for (int i = 0; i < str.length; i++) {
        if (!used[i]) {
            if (i > 0 && str[i] == str[i - 1] && !used[i - 1]) {
                continue;
            }
            used[i] = true;
            dfs(str, index - 1);
            used[i] = false;
        }
    }
}
```



**子集思路**

该题与子集 II很像，区别在于子集 II每一个解不强调顺序，而当前问题每一个解强调顺序，不同顺序构成了一个解。即：子集 II是一个组合问题，当前问题是一个排列问题；
输入字符串还有多少字符可用是我们关注的，因此需要得到输入字符串的字符 频数 数组。题目最后说：「tiles 由大写英文字母组成」，因此可以使用长度为 26 的整型数组表示字符频数数组。

![image-20220502235314945](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220502235314945.png)

```java
public int numTilePossibilities(String tiles) {
    int[] count = new int[26];
    char[] str = tiles.toCharArray();
    for (char c : str) {
        count[c - 'A']++;
    }
    return backTracking(count);
}

private int backTracking(int[] count) {
    // 递归终止条件titles中所有字符均被使用
    int res = 0;
    for (int i = 0; i < 26; i++) {
        if (count[i] == 0) {
            continue;
        }
        count[i]--;
        res++;
        res += backTracking(count);
        count[i]++;
    }
    return res;
}
```





## 分割

### 复原IP地址

#### 题目描述

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

#### 题解

![93.复原IP地址](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631606390-ioqLGF-file_1631606390061)



这题的可以剪枝的情况很多，但是如果都要对所有情况进行剪枝判断的话，反而效率会下降，我们只考虑对每一小段IP区间进行剪枝判断

```java
private List<String> res = new ArrayList<>();
// 需要频繁修改字符串
StringBuilder IP = new StringBuilder();

public List<String> restoreIpAddresses(String s) {
    IP.append(s);
    backTracking(IP, 0, 0);
    return res;
}

public void backTracking(StringBuilder IP, int index, int pointNum) {
    // 最后一个"."添加完 判断最后一段是否合法
    if (pointNum == 3) {
        if (isValid(IP.substring(index, IP.length()))) {
            res.add(IP.toString());
        }
        return;
    }
    // 属于切割问题 给定字符串上的数字我们是不能修改的，我们只能添加"."，我们并没有用path 所以这个i是不会回退的
    for (int i = index; i < IP.length(); i++) {
        System.out.println("index:" + index + "  i+1:" + (i + 1));
        // 判断选定区间是否合法   substring 左闭右开 [ )
        if (!isValid(IP.substring(index, i + 1))) {
            break;
        }
        // 合法
        IP.insert(i + 1, ".");
        System.out.println(IP);
        backTracking(IP, i + 2, pointNum + 1);
        // 消除痕迹 回溯
        IP.deleteCharAt(i + 1);
    }
}

// 校验每一小段的IP是否合法
public boolean isValid(String str) {
    System.out.println("小段区间：" + str);
    if (str == null || str.length() == 0) {
        return false;
    }
    // 校验是否含前导0
    if (str.charAt(0) == '0' && str.length() > 1) {
        return false;
    }
    // 校验每一位字符是否为0~9
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) < '0' || str.charAt(i) > '9') {
            return false;
        }
    }
    // 校验是否属于0~255
    if (Long.parseLong(str) > 255 || Long.parseLong(str) < 0) {
        return false;
    }
    return true;
}
```



### 分割回文串

#### 题目描述

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)



#### 题解

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1631606009-OMGnoi-image.png)



```java
private List<List<String>> res = new ArrayList<>();
private List<String> path = new ArrayList<>();
private StringBuilder str = new StringBuilder();

public List<List<String>> partition(String s) {
    str.append(s);
    backTracking(str, 0);
    return res;
}

public void backTracking(StringBuilder str, int index) {
    // 切割完毕
    if (index == str.length()) {
        System.out.println("path：" + path + "切割完成");
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i < str.length(); i++) {
        System.out.print("path:" + path + "   ");
        System.out.println("index: " + index + " i: " + i);
        // 不是回文串
        if (!isPalindrome(str, index, i)) {
            continue;
        }
        // [index, i + 1)
        String s = str.substring(index, i + 1);
        path.add(s);
        backTracking(str, i + 1);
        path.remove(path.size() - 1);
    }
}

// 判断是否回文
private boolean isPalindrome(StringBuilder s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
    }
    return true;
}
```



### 拆分字符串使唯一子字符串的数目最大

#### 题目描述

[LeetCode1593. 拆分字符串使唯一子字符串的数目最大](https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/)

给你一个字符串 `s` ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。

字符串 `s` 拆分后可以得到若干 **非空子字符串** ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 **唯一的** 。

注意：**子字符串** 是字符串中的一个连续字符序列。

 

**示例 1：**

```
输入：s = "ababccc"
输出：5
解释：一种最大拆分方法为 ['a', 'b', 'ab', 'c', 'cc'] 。像 ['a', 'b', 'a', 'b', 'c', 'cc'] 这样拆分不满足题目要求，因为其中的 'a' 和 'b' 都出现了不止一次。
```

**示例 2：**

```
输入：s = "aba"
输出：2
解释：一种最大拆分方法为 ['a', 'ba'] 。
```

**示例 3：**

```
输入：s = "aa"
输出：1
解释：无法进一步拆分字符串。 
```

**提示：**

- `1 <= s.length <= 16`
- `s` 仅包含小写英文字母



#### 题解



**回溯**

题目要求拆分出来的每个子字符串都必须是 **唯一**，并且只是求这些唯一子字符串的最大数目，与顺序无关，用 Set 存储即可 

```java
//private List<String> path = new ArrayList<>();
private Set<String> set = new HashSet<>(); // 保证子字符串唯一
private int res = 0;

public int maxUniqueSplit(String s) {
    backTracking(s, 0);
    return res;
}

private void backTracking(String s, int index) {
    if (index == s.length()) {
        res = Math.max(res, set.size());
        return;
    }

    for (int i = 1; i <= s.length() - index; i++) {
        // 截取[index, index + i]的子串
        String substr = s.substring(index, index + i);
        if (!set.contains(substr)) {
            //path.add(substr);
            set.add(substr);
            backTracking(s, index + i);
            //path.remove(path.size() - 1);
            set.remove(substr);
        }

    }
}
```







## 二维平面

遇到这个问题，一个非常重要的事情是：**问清楚面试官，是否可以修改传来的 nums 数组**

如果可以修改的话，代码可以写得比较简洁，就不需要用额外的visited数组来标记了

### 单词搜索

#### 题目描述

[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

#### 题解

二维平面上使用回溯

只要是涉及下标越界的地方，先判断是否越界是更好的做法。

```java
// 也可以用二维数组
private boolean[] visited;
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private int m;
private int n;

public boolean exist(char[][] board, String word) {
    if (board == null || board.length == 0 || word == null || word.length() == 0) {
        return false;
    }
    m = board.length;
    n = board[0].length;
    visited = new boolean[m * n];
    char[] wordChar = word.toCharArray();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 只要找到一个就提前return true
            if (dfs(board, wordChar, 0, i, j)) {
                return true;
            }
        }
    }
    return false;
}

public boolean dfs(char[][] board, char[] wordChar, int index, int x, int y) {
    // 搜索到单词字母最后一个 需要返回结果 不需要再深搜 提前return
    if (index == wordChar.length - 1) {
        return board[x][y] == wordChar[index];
    }

    if (board[x][y] == wordChar[index]) {
        visited[x * n + y] = true;
        for (int[] direct : directs) {
            int newX = x + direct[0];
            int newY = y + direct[1];
            // 先判断是否越界
            if (inArea(newX, newY) && !visited[newX * n + newY]) {
                if (dfs(board, wordChar, index + 1, newX, newY)) {
                    return true;
                }
            }
        }
        // 回溯 状态重置 保证在深搜的过程不会去搜重复的，但是退出深搜进行横向遍历的时候可以搜重复的
        visited[x * n + y] = false;
    }
    return false;
}

// 搜索区域是否合法
private boolean inArea(int x, int y) {
    return x >= 0 && y >= 0 && x < m && y < n;
}
```

### N 皇后

#### 题目描述

[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

#### 题解

N 皇后问题是有很多种优化方案的，这是比较经典的解法



**diagSub对角线**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212113406422.png)

**diagMain对角线**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220212113248496.png)





```java
/**
 * 以 4 皇后为例的棋盘
 * [00, 01, 02, 03]
 * [10, 11, 12, 13]
 * [20, 21, 22, 23]
 * [30, 31, 32, 33]
 * <p>
 * 因为数组索引从0开始 我们用索引i - j + n - 1代表处于哪一条左对角线上
 * diagMain[-3, -2, -1, 0, 1, 2, 3] ==> [0, 1, 2, ..., i - j + n - 1]
 * <p>
 * diagSub[0, 1, 2, 3, 4, 5, 6] 用i + j代表代表处于哪一条右对角线上
 */
// 列状态 记录哪一列有皇后
private boolean[] col;
// 记录左上->右下的对角线状态 特点：对角线上每个元素i - j 相等
private boolean[] diagMain;
// 记录右上->左下的对角线状态 特点：对角线上每个元素i + j 相等
private boolean[] diagSub;
private List<List<String>> res = new ArrayList<>();
// 每个完整结果皇后的列坐标
private List<Integer> path = new ArrayList<>();

public List<List<String>> solveNQueens(int n) {
    col = new boolean[n];
    diagMain = new boolean[2 * n - 1];
    diagSub = new boolean[2 * n - 1];
    backTracking(n, 0);
    return res;
}

// index为行坐标
private void backTracking(int n, int index) {
    if (index == n) {
        // 将列坐标结果集转化为棋盘
        List<String> board = convert2board(path,n);
        res.add(board);
        return;
    }

    // 对列遍历 每一列选出一个皇后
    for (int j = 0; j < n; j++) {
        // 不在同一列、不在同一对角线
        if (!col[j] && !diagMain[index - j + n - 1] && !diagSub[index + j]) {
            path.add(j);
            col[j] = true;
            diagMain[index - j + n - 1] = true;
            diagSub[index + j] = true;

            backTracking(n, index + 1);
            // 回溯 状态重置
            path.remove(path.size() - 1);
            col[j] = false;
            diagMain[index - j + n - 1] = false;
            diagSub[index + j] = false;
        }
    }
}

// 将结果的列坐标转换成棋盘 path存储的是所有皇后的列坐标
private List<String> convert2board (List<Integer> path, int n) {
    List<String> board = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        char[] arr = new char[n];
        // 棋盘每一行先填充'.' 在将有皇后的位置修改为'Q'
        Arrays.fill(arr,'.');
        arr[path.get(i)] = 'Q';
        board.add(new String(arr));
    }
    return board;
}
```



### N 皇后 II

#### 题目描述

[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

N 皇后是求具体的解（棋盘的布局），而这题是求解的个数

#### 题解

可以直接用上一题的解，返回解的个数

```java
/**
    * 以 4 皇后为例的棋盘
    * [00, 01, 02, 03]
    * [10, 11, 12, 13]
    * [20, 21, 22, 23]
    * [30, 31, 32, 33]
    * <p>
    * 因为数组索引从0开始 我们用索引i - j + n - 1代表处于哪一条左对角线上
    * diagMain[-3, -2, -1, 0, 1, 2, 3] ==> [0, 1, 2, ..., i - j + n - 1]
    * <p>
    * diagSub[0, 1, 2, 3, 4, 5, 6] 用i + j代表代表处于哪一条右对角线上
    */
// 列状态 记录哪一列有皇后
private boolean[] col;
// 记录左上->右下的对角线状态 特点：对角线上每个元素i - j 相等
private boolean[] diagMain;
// 记录右上->左下的对角线状态 特点：对角线上每个元素i + j 相等
private boolean[] diagSub;
private List<List<Integer>> res = new ArrayList<>();
// 每个完整结果皇后的列坐标
private List<Integer> path = new ArrayList<>();

public int totalNQueens(int n) {
    col = new boolean[n];
    diagMain = new boolean[2 * n - 1];
    diagSub = new boolean[2 * n - 1];
    backTracking(n, 0);
    return res.size();
}

// index为行坐标
private void backTracking(int n, int index) {
    if (index == n) {
        res.add(new ArrayList<>(path));
        return;
    }

    // 对列遍历 每一列选出一个皇后
    for (int j = 0; j < n; j++) {
        // 不在同一列、不在同一对角线
        if (!col[j] && !diagMain[index - j + n - 1] && !diagSub[index + j]) {
            path.add(j);
            col[j] = true;
            diagMain[index - j + n - 1] = true;
            diagSub[index + j] = true;

            backTracking(n, index + 1);
            // 回溯 状态重置
            path.remove(path.size() - 1);
            col[j] = false;
            diagMain[index - j + n - 1] = false;
            diagSub[index + j] = false;
        }
    }
}
```



### 解数独

#### 题目描述

[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

#### 题解

这题难点是求解状态的表示

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

怎么设置上面的状态是关键

还有怎么加快搜索

```java
// 第二维的大小都设置成 10 是为了让 '1' 落在下标 1 的位置，'9' 落在下标 9 的位置
// row第一维表示哪一行，第二维表示含有哪个数字
private boolean[][] row = new boolean[9][10];
// col第一维表示哪一列，第二维表示含有哪个数字
private boolean[][] col = new boolean[9][10];
// cell 的第一维表示在哪个3*3的宫内
private boolean[][] cell = new boolean[9][10];

public void solveSudoku(char[][] board) {
    // 1 遍历一遍棋盘 将已有的数字设置状态
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                // 减去 '0' 是有 1 个位置的偏移
                int num = board[i][j] - '0';
                row[i][num] = true;
                col[j][num] = true;
                // [i][j] ==> [i / 3][j / 3]将9 * 9的小格缩小成3 * 3的大格
                // [i / 3][j / 3] ==> [i / 3 * 3 + j / 3] 二维转一维
                cell[i / 3 * 3 + j / 3][num] = true;
            }
        }
    }
    // 2 找到第一个为'.'的位置进行dfs搜索 这里至多只会执行n次，因为只是找出一个位置
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                backTracking(board, i * 9 + j);
            }
        }
    }
}

private boolean backTracking(char[][] board, int index) {
    // dfs到最后一个位置说明求解成功
    if (index == 9 * 9) {
        return true;
    }
    // 剪枝 找到下一个为'.'的一维值 否则会超时
    int next = index + 1;
    for (; next < 9 * 9; next++) {
        // 一维==>二维  i * n + j 所以二维坐标的i就等于一维值整除列数，j等于一维值模列数
        if (board[next / 9][next % 9] == '.') {
            break;
        }
    }

    int x = index / 9;
    int y = index % 9;
    for (int i = 1; i <= 9; i++) {
        if (!row[x][i] && !col[y][i] && !cell[x / 3 * 3 + y / 3][i]) {
            row[x][i] = true;
            col[y][i] = true;
            cell[x / 3 * 3 + y / 3][i] = true;
            // 将整型强制类型转换为字符型，JVM 会把数字当成字符的 ASCII 编码来处理
            // 所以要转传成正确的字符，要先加上48再强转，也是加上字符'0'
            board[x][y] = (char) ('0' + i);

            if (backTracking(board, next)) {
                return true;
            }
            // 回溯，状态重置
            row[x][i] = false;
            col[y][i] = false;
            cell[x / 3 * 3 + y / 3][i] = false;
            board[x][y] = '.';
        }
    }

    // 当前解尝试错误
    return false;
}
```



### 有效的数独

这题分类不是回溯，只是顺便放到这

#### 题目描述

[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，**验证已经填入的数字是否有效即可**。
- 空白格用 `'.'` 表示。

#### 题解

这题是比解数独简单很多的，因为只需要校验已经填入的部分数字是否有效即可

设置状态的思路是一样的

```java
private boolean[][] row = new boolean[9][10];
private boolean[][] col = new boolean[9][10];
private boolean[][] cell = new boolean[9][10];

public boolean isValidSudoku(char[][] board) {
    // 遍历棋盘
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            // 对已经填入的数字做校验
            if (board[i][j] != '.') {
                int num = board[i][j] - '0';
                // 在三个区域内第一次遇到num 设置为true
                if (!row[i][num] && !col[j][num] && !cell[i / 3 * 3 + j / 3][num]) {
                    row[i][num] = true;
                    col[j][num] = true;
                    cell[i / 3 * 3 + j / 3][num] = true;
                } else {
                    // 否则说明在同一区域内有重复数字出现
                    return false;
                }
            }
        }
    }
    // 遍历完没有非法数字
    return true;
}
```



### FloodFill算法

### 岛屿数量

#### 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)



#### 题解

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private boolean[] visited;
private int m;
private int n;

public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    int islands = 0;
    m = grid.length;
    n = grid[0].length;
    visited = new boolean[m * n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1' && !visited[i * n + j]) {
                islands++;
                dfs(grid, i, j);
            }
        }
    }
    return islands;
}

// floodfill算法实质就是深度优先遍历

/**
 * 注意点：
 * 1、这里表面并没有设置递归终止的条件
 * 但是搜索的位置的有限的，并且没有对visited进行状态重置
 * 所以递归的终止条件隐藏在if的判断语句中
 * 2、这个dfs没有回溯的过程，没有对visited进行状态重置，
 * 因为我们的目的只是将最初[i,j]这个位置相连的地方都标记为同一个岛屿而已，
 * 而不是在其中找到某一个具体的序列或值
 **/
private void dfs(char[][] grid, int x, int y) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 位置合法的陆地且没有被访问过
        if (inArea(newX, newY) && grid[newX][newY] == '1' && !visited[newX * n + newY]) {
            dfs(grid, newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && y >= 0 && x < m && y < n;
}
```



### 被围绕的区域

#### 题目描述

[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

> 注意：任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。



#### 题解

**DFS**

因为我们要区分出于在边界的'O'及与它相连的'O'，所以我们要从边界，**从外到内dfs**，对这些不需要被填充的成'X'的'O'进行一个标记

这里我用了visited数组，也可以不用，直接将不需要被填充的成'X'的'O'改成其它字符，最后再改回来

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private int m;
private int n;
private boolean[] visited;

public void solve(char[][] board) {
    if (board == null || board.length == 0) {
        return;
    }
    m = board.length;
    n = board[0].length;
    visited = new boolean[m * n];
    //1 对最外面一圈进行dfs，标记与外界相连的'0'
    // 对第一列和最后一列dfs
    for (int i = 0; i < m; i++) {
        if (board[i][0] == 'O') {
            dfs(board, i, 0);
        }
        if (board[i][n - 1] == 'O') {
            dfs(board, i, n - 1);
        }
    }
    // 对第一行和最后一行dfs
    for (int j = 0; j < n; j++) {
        if (board[0][j] == 'O') {
            dfs(board, 0, j);
        }
        if (board[m - 1][j] == 'O') {
            dfs(board, m - 1, j);
        }
    }
    // 2 遍历整个矩阵 将没有被标记到的'0'都填充成'X'
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'O' && !visited[i * n + j]) {
                board[i][j] = 'X';
            }
        }
    }
}

private void dfs(char[][] board, int x, int y) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY) && board[newX][newY] == 'O' && !visited[newX * n + newY]) {
            dfs(board, newX, newY);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



**BFS**

这里标记的过程也可以改成广度优先

**并查集**

另一种思路就是使用并查集

设置一个dummy虚拟节点，所有不需要覆盖的都和它相连，最后在遍历一遍，没有和dummy相连的就置为'X'。



### 太平洋大西洋水流问题

#### 问题描述

[417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)



#### 题解

这题跟**被围绕的区域**思路一样，都是**从外层开始dfs**，区别就是需要用两个不同的visited来标记太平洋和大西洋的访问状态



1、找出所有从**太平洋**出发升序的最高顶点

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1619850901-ToWmLO-8e9c842a24968824d18c4de2c520a6e.png)



2、找出所有从**大西洋**出发升序的最高顶点

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1619850909-byyyNx-521bfa8063d14254466a5d7f6600ae9.png)

3、这些重合的点最高顶点就是**可以使雨水同时流向太平洋和大西洋的地方**

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/1619850883-mLzTrV-06ce3f99a8742231c3f7d42dcac0c69.png)

```java
private int[][] directs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
private List<List<Integer>> res = new ArrayList<>();
private boolean[] visitedP; // dfs太平洋状态
private boolean[] visitedA; // dfs大西洋状态
private int m;
private int n;

public List<List<Integer>> pacificAtlantic(int[][] heights) {
    if (heights == null || heights.length == 0) {
        return res;
    }
    m = heights.length;
    n = heights[0].length;
    visitedA = new boolean[m * n];
    visitedP = new boolean[m * n];

    // 对最外面一层dfs
    for (int i = 0; i < m; i++) {
        // 第一列太平洋
        dfs(heights, i, 0, visitedP);
        // 最后一列大西洋
        dfs(heights, i, n - 1, visitedA);
    }
    for (int j = 0; j < n; j++) {
        // 第一行太平洋
        dfs(heights, 0, j, visitedP);
        // 最后一行大西洋
        dfs(heights, m - 1, j, visitedA);
    }
	
    // 遍历整个岛屿 找出重合点
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (visitedA[i * n + j] && visitedP[i * n + j]) {
                List<Integer> position = new ArrayList<>();
                position.add(i);
                position.add(j);
                res.add(new ArrayList<>(position));
            }
        }
    }
    return res;
}

// 找出所有逆向的的终点即山顶位置，visitedP和visitedA的交集就是结果
private void dfs(int[][] heights, int x, int y, boolean[] visited) {
    visited[x * n + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 未被访问过的合法区域且heights[x][y] <= heights[newX][newY]即逆向
        if (inArea(newX, newY) && !visited[newX * n + newY] && heights[x][y] <= heights[newX][newY]) {
            dfs(heights, newX, newY, visited);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



















逻辑图：树状

实际结构：压栈

时间复制度分析

master定理：

(只针对递归问题子规模一致的时候使用)

![image-20220126141702793](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220126141702793.png)

n/b 是递归子问题的规模，a是一次方法中调用递归的次数，f(n)是非递归的操作，用O(N^d)来表示非递归的时间复杂度
$$
当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(N^{\log_{b} {a}})\\
1) \log_{b} {a} < d ---> 复杂度为O(N^d)\\

2) \log_{b} {a} > d --> 复杂度为O(N^{\log_{b} {a}})\\

3) \log_{b} {a} = d ----> 复杂度为O(N^d*{\log_{}{N}})\\
$$





### 图像渲染

#### 题目描述

[LeetCode733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

有一幅以 `m x n` 的二维整数数组表示的图画 `image` ，其中 `image[i][j]` 表示该图画的像素值大小。

你也被给予三个整数 `sr` , `sc` 和 `newColor` 。你应该从像素 `image[sr][sc]` 开始对图像进行 上色**填充** 。

为了完成 **上色工作** ，从初始像素开始，记录初始坐标的 **上下左右四个方向上** 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 **四个方向上** 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 `newColor` 。

最后返回 *经过上色渲染后的图像* 。

 

**示例 1:**

![flood1-grid](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/flood1-grid.jpg)

```
输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。
```

**示例 2:**

```
输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
输出: [[2,2,2],[2,2,2]]
```

 

**提示:**

- `m == image.length`
- `n == image[i].length`
- `1 <= m, n <= 50`
- `0 <= image[i][j], newColor < 216`
- `0 <= sr < m`
- `0 <= sc < n`



#### 题解

```java
private int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
private int m;
private int n;
private boolean[] visited;

public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
    if (image.length == 0) return null;
    m = image.length;
    n = image[0].length;
    visited = new boolean[m * n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == sr && j == sc) {
                int init = image[i][j]; // 记录初始的像素值
                image[i][j] = newColor;
                dfs(image, i, j, newColor, init);
            }
        }
    }
    return image;
}

private void dfs(int[][] image, int x, int y, int newColor, int init) {
    visited[n * x + y] = true;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        // 未被访问过的合法区域且像素值与初始坐标相同的相连像素点继续进行深搜
        if (inArea(newX, newY) && !visited[n * newX + newY] && image[newX][newY] == init) {
            image[newX][newY] = newColor;
            dfs(image, newX, newY, newColor, init);
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



### 扫雷游戏

#### 题目描述

[LeetCode529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

让我们一起来玩扫雷游戏！

给你一个大小为 `m x n` 二维字符矩阵 `board` ，表示扫雷游戏的盘面，其中：

- `'M'` 代表一个 **未挖出的** 地雷，
- `'E'` 代表一个 **未挖出的** 空方块，
- `'B'` 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 **已挖出的** 空白方块，
- **数字**（`'1'` 到 `'8'`）表示有多少地雷与这块 **已挖出的** 方块相邻，
- `'X'` 则表示一个 **已挖出的** 地雷。

给你一个整数数组 `click` ，其中 `click = [clickr, clickc]` 表示在所有 **未挖出的** 方块（`'M'` 或者 `'E'`）中的下一个点击位置（`clickr` 是行下标，`clickc` 是列下标）。

根据以下规则，返回相应位置被点击后对应的盘面：

1. 如果一个地雷（`'M'`）被挖出，游戏就结束了- 把它改为 `'X'` 。
2. 如果一个 **没有相邻地雷** 的空方块（`'E'`）被挖出，修改它为（`'B'`），并且所有和其相邻的 **未挖出** 方块都应该被递归地揭露。
3. 如果一个 **至少与一个地雷相邻** 的空方块（`'E'`）被挖出，修改它为数字（`'1'` 到 `'8'` ），表示相邻地雷的数量。
4. 如果在此次点击中，若无更多方块可被揭露，则返回盘面。

 

**示例 1：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/minesweeper_example_1.png)

```
输入：board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]], click = [3,0]
输出：[["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
```

**示例 2：**

![img](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/minesweeper_example_2.png)

```
输入：board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]], click = [1,2]
输出：[["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
```

 

**提示：**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 50`
- `board[i][j]` 为 `'M'`、`'E'`、`'B'` 或数字 `'1'` 到 `'8'` 中的一个
- `click.length == 2`
- `0 <= clickr < m`
- `0 <= clickc < n`
- `board[clickr][clickc]` 为 `'M'` 或 `'E'`



#### 题解

先要向八个方向扫描一周，记录周围地雷的数量，再根据地雷的数量要不要决定继续进行深搜

```java
// 八个方向
private int[][] directs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
private int m;
private int n;

public char[][] updateBoard(char[][] board, int[] click) {
    if (board.length == 0) return null;
    m = board.length;
    n = board[0].length;
    int x = click[0];
    int y = click[1];
    // 点击为雷，退出
    if (board[x][y] == 'M') {
        board[x][y] = 'X';
        return board;
    }
    dfs(board, x, y);
    return board;
}

private void dfs(char[][] board, int x, int y) {
    // 先扫描一圈周围，记录地雷个数
    int count = 0;
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY) && board[newX][newY] == 'M') {
            count++;
        }
    }
    if (count > 0) {
        board[x][y] = (char) (count + '0');
    } else {
        // board[x][y] 不为数字才继续深搜 即(x, y)的八个方向没有地雷则继续深搜
        //visited[x * n + y] = true;
        board[x][y] = 'B';
        for (int[] direct : directs) {
            int newX = x + direct[0];
            int newY = y + direct[1];
            // 这里不需要visited数组，因为判断该字符是否为'E'就知道有没有被访问过
            if (inArea(newX, newY)  && board[newX][newY] == 'E') {
                dfs(board, newX, newY);
            }
        }
    }
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



### 黄金矿工

#### 题目描述

[LeetCode1219. 黄金矿工](https://leetcode.cn/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 `m * n` 的网格 `grid` 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 `0`。

为了使收益最大化，矿工需要按以下规则来开采黄金：

- 每当矿工进入一个单元，就会收集该单元格中的所有黄金。
- 矿工每次可以从当前位置向上下左右四个方向走。
- 每个单元格只能被开采（进入）一次。
- **不得开采**（进入）黄金数目为 `0` 的单元格。
- 矿工可以从网格中 **任意一个** 有黄金的单元格出发或者是停止。

 

**示例 1：**

```
输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
```

**示例 2：**

```
输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
输出：28
解释：
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。
```

 

**提示：**

- `1 <= grid.length, grid[i].length <= 15`
- `0 <= grid[i][j] <= 100`
- 最多 **25** 个单元格中有黄金。



#### 题解

```java
private int[][] directs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
private int m;
private int n;
private boolean[] visited;

public int getMaximumGold(int[][] grid) {
    if (grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    int res = 0;
    visited = new boolean[m * n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] != 0) {
                res = Math.max(res, dfs(grid, i, j));
                Arrays.fill(visited, false);
            }
        }
    }
    return res;
}

private int dfs(int[][] grid, int x, int y) {
    visited[x * n + y] = true;
    int res = grid[x][y];
    for (int[] direct : directs) {
        int newX = x + direct[0];
        int newY = y + direct[1];
        if (inArea(newX, newY) && !visited[newX * n + newY] && grid[newX][newY] != 0) {
            res = Math.max(res, grid[x][y] + dfs(grid, newX, newY));
        }
    }
    // 状态重置
    visited[x * n + y] = false;
    return res;
}

private boolean inArea(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n;
}
```



### 1、汉诺塔问题

```java
/**
 * 从最左到最右只需要三步：
 * 1.上面 N - 1 的挪去辅助柱
 * 2.剩余的一个挪去最右
 * 3.辅助柱的挪去最右
 */
public static void process(int N, String source, String target, String help) {
    if (N == 1) {
        System.out.println("move 1 from " + source + " to " + target);
    } else {
        // 1.上面 N - 1 的挪去辅助柱
        process(N - 1, source, help, target);
        // 2.剩余的一个挪去最右 打印的是 剩余的一个挪去最右
        System.out.println("move " + N + " from " + source + " to " + target);
        // 3.辅助柱的挪去最右
        process(N - 1, help, target, source);
    }

}

public static void hanoi(int N, String source, String target, String help) {
    process(N, source, target, help);
}
```









































![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220206001808032.png)

## 字符串

### 括号生成

#### 题目描述

[LeetCode22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 **提示：**

- `1 <= n <= 8`



#### 题解

**dfs**

![image-20220503233139447](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220503233139447.png)

当前左右括号都有大于 0 个可以使用的时候，才产生分支；

产生左分支的时候，只看当前是否还有左括号可以使用；

产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；

在左边和右边剩余的括号数都等于 0 的时候结算。

```java
private List<String> res = new ArrayList<>();

public List<String> generateParenthesis(int n) {
    dfs(n, n, "");
    return res;
}

//
private void dfs(int leftCount, int rightCount, String path) {
    if (leftCount == 0 && rightCount == 0) {
        res.add(path);
    }
    // 这个剪枝很巧妙 右括号比左括号多一定是不符合条件的
    if (leftCount > rightCount) {
        return;
    }
    if (leftCount > 0) {
        dfs(leftCount - 1, rightCount, path + "(");
    }
    if (rightCount > 0) {
        dfs(leftCount, rightCount - 1, path + ")");
    }
}
```



### 字母大小写全排列

#### 题目描述

[LeetCode784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

给定一个字符串 `s` ，通过将字符串 `s` 中的每个字母转变大小写，我们可以获得一个新的字符串。

返回 *所有可能得到的字符串集合* 。以 **任意顺序** 返回输出。

 

**示例 1：**

```
输入：s = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]
```

**示例 2:**

```
输入: s = "3z4"
输出: ["3z4","3Z4"]
```

 **提示:**

- `1 <= s.length <= 12`
- `s` 由小写英文字母、大写英文字母和数字组成



#### 题解

```java
private List<String> list = new ArrayList<>();

public List<String> letterCasePermutation(String s) {
    dfs(s.toCharArray(), 0, "");
    return list;
}

private void dfs(char[] str, int index, String path) {
    if (index == str.length) {
        list.add(path);
        return;
    }
    // 如果是数字则不用管
    if (Character.isDigit(str[index])) {
        dfs(str, index + 1, path + str[index]);
    } else {
        // 如果是字母则可以选择进行大小写转化也可以选择不转
        dfs(str, index + 1, path + changeLetter(str[index]));
        dfs(str, index + 1, path + str[index]);
    }
}

private char changeLetter(char ch) {
    return (ch >= 'a' && ch <= 'z') ? (char) (ch - 32) : (char) (ch + 32);
}
```



### 累加数

#### 题目描述

[LeetCode306. 累加数](https://leetcode-cn.com/problems/additive-number/)

**累加数** 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 **累加序列** 必须 **至少** 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。

给你一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是 **累加数** 。如果是，返回 `true` ；否则，返回 `false` 。

**说明：**累加序列里的数，除数字 0 之外，**不会** 以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。

 

**示例 1：**

```
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

**示例 2：**

```
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

 

**提示：**

- `1 <= num.length <= 35`
- `num` 仅由数字（`0` - `9`）组成

**进阶：**你计划如何处理由过大的整数输入导致的溢出?

#### 题解

这题关键是使高精度处理数据，避免溢出问题

```java
private Deque<List<Integer>> path = new LinkedList<>();
private boolean flag = false;

public boolean isAdditiveNumber(String num) {
    dfs(num, 0);
    return flag;
}

private void dfs(String num, int index) {
    if (index == num.length()) {
        if (path.size() >= 3) {
            flag = true;
        }
        return;
    }
    for (int i = 1; index + i <= num.length(); i++) {
        // 数字不能含有前导0 0可以单独使用
        if (num.charAt(index) == '0' && i > 1) {
            break;
        }
        List<Integer> n = getNum(num, index, index + i);
        // 剪枝 弹出栈顶两个元素，n 是否为这两个元素和，否则跳过
        if (path.size() >= 2) {
            List<Integer> a1 = path.pop();
            List<Integer> a2 = path.pop();
            List<Integer> add = add(a1, a2);
            if (!isEqual(n, add)) { // 这里判断可以细分到 n > a1 + a1的话可以break
                path.push(a2);
                path.push(a1);
                continue;
            } else {
                path.push(a2);
                path.push(a1);
            }
        }
        path.push(n);
        dfs(num, index + i);
        path.pop();
    }
}


// 高精度substring
private List<Integer> getNum(String num, int l, int r) {
    List<Integer> list = new ArrayList<>();
    for (int i = r - 1; i >= l; i--) {
        list.add(num.charAt(i) - '0');
    }
    return list;
}

// 高精度加法
private List<Integer> add(List<Integer> a, List<Integer> b) {
    List<Integer> c = new ArrayList<>();
    int carry = 0;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) carry += a.get(i);
        if (i < b.size()) carry += b.get(i);
        c.add(carry % 10);
        carry /= 10;
    }
    if (carry > 0) c.add(carry);

    return c;
}

// 判断两个数相等
private boolean isEqual(List<Integer> a, List<Integer> b) {
    if (a.size() != b.size()) {
        return false;
    }
    for (int i = 0; i < a.size(); i++) {
        if (!Objects.equals(a.get(i), b.get(i))) {
            return false;
        }
    }
    return true;
}
```



# 贪心

贪心选择性质

如果无法举出反例，如何证明贪心算法的正确性？

通过使用两种证明方法：数学归纳法(有一个变量在显然增加的情况)、反证法（假设不正确，推导出矛盾）

反证：

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220312223321634.png)



### 字典序排列最小的等效字符串

正确的贪心策略：字典序 ab < ba,而不是a < b

```java
public static String smallestString(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    Arrays.sort(strs, (String str1, String str2) -> (str1 + str2).compareTo(str2 + str1));
    StringBuilder res = new StringBuilder();
    for (String str : strs) {
        res.append(str);
    }
    return res.toString();
}
```



### 最多可以参加的会议数目

```java
public int maxEvents(int[][] events) {
    //首先排序：开始时间小的在前。这样是方便我们顺序遍历，把开始时间一样的都放进堆
    Arrays.sort(events, (o1, o2) -> o1[0] - o2[0]);
    //小顶堆
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    //结果、开始时间、events下标、有多少组数据
    int res = 0, last = 1, i = 0, n = events.length;
    while (i < n || !pq.isEmpty()) {
        //将start相同的会议都放进堆里
        while (i < n && events[i][0] == last) {
            pq.offer(events[i++][1]);
        }
        //pop掉当前天数之前的
        while (!pq.isEmpty() && pq.peek() < last) {
            pq.poll();
        }
        //顶上的就是俺们要参加的
        if (!pq.isEmpty()) {
            pq.poll();
            res++;
        }
        last++;
    }
    return res;
}
```



### 金条分割问题

最优二叉树(哈夫曼树)基于贪心算法

（1）准备一个小根堆。将数组放到这个小根堆里。

（2）每次弹出堆顶的两个数求和为A，将A再放回小根堆里。

（3）一直执行第2步，直到堆只剩一个数。最后，每一次第二步A的累加和即是最后的结果。

例如给定的金条长度为150，要分成10、20、30、40、50的块，最后花费的铜板数量即是上图中蓝色圆圈的和，即150+60+90+30=330。

也就是我们代码求解的时候是从叶子往根求的，求完后再从根往叶子即是金条的切割顺序，最后所有的叶子即是需要切成的块的大小。

```java
public static int splitGold(int[] arr) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int i : arr) {
        heap.add(i);
    }
    int payMoney = 0;
    int sum = 0;
    while (heap.size() > 1){
        sum = heap.poll() + heap.poll();
        payMoney += sum;
        heap.add(sum);
    }
    return payMoney;
}
```



### IPO

#### 题目描述

[LeetCode502. IPO](https://leetcode-cn.com/problems/ipo/)

假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。

最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。

答案保证在 32 位有符号整数范围内。

**示例 1：**

```
输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
```

**示例 2：**

```
输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
输出：6
```



#### 题解

优先队列+贪心



注意一点，启动资金是可以收回来的，所以在本题中项目不会亏本，那么只要**依次选启动资金低于本金里收益最大的项目**，就可以将收益最大化

**这种贪心符合人的思维，就是在能够做的项目里选择利润最大的去做，并不需要证明**

所以准备一个小根堆存入所有项目，从小根堆里取出当前启动资金可以做的所有项目放入另一个大根堆，这个堆按收益排序，这个大根堆堆顶就是一个局部最优，**做完一个项目后，需要更新最大利益堆**，因为此时本金已改变，可以做更多的项目

```java
public static class Project {
    int cost;
    int profit;

    public Project(int cost, int profit) {
        this.cost = cost;
        this.profit = profit;
    }
}

public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    PriorityQueue<Project> minCostHeap = new PriorityQueue<>((o1, o2) -> o1.cost - o2.cost);
    PriorityQueue<Project> maxProfitHeap = new PriorityQueue<>((o1, o2) -> o2.profit - o1.profit);
    // 将项目都加入最小成本堆
    for (int i = 0; i < profits.length; i++) {
        minCostHeap.add(new Project(capital[i], profits[i]));
    }
    for (int i = 0; i < k; i++) {
        // 项目不为空且最小成本堆顶的启动资金小于本金时，加入最大收益堆
        while (!minCostHeap.isEmpty() && minCostHeap.peek().cost <= w) {
            maxProfitHeap.add(minCostHeap.poll());
        }
        // 最大收益堆为空 说明本金w可能小于成本或者项目已经都做完，直接返回w
        if (maxProfitHeap.isEmpty()) {
            return w;
        }
        w += maxProfitHeap.poll().profit;
    }
    return w;
}
```



### 点灯问题

#### 题目描述

给定一个字符串str，只由‘X’和‘.’两种字符构成。‘X’表示墙，不能放灯，也不需要点亮。‘.’表示居民点，可以放灯，需要点亮。如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮。返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。



#### 题解

分情况讨论位置情况

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220203214705835.png)

如果i位置为墙，不放灯，i跳到下一位置

如果i位置为居民点，则往下判断i+1位置的情况，如果i+1为墙，那么灯只能放在i位置，i跳到i+2，如果i+1为居民点，那么继续往下判断i+2位置的情况，如果i+2为墙，灯放在i和i+1位置都可以，i跳到i+3，如果i+2位居民点，那么灯放在i+1位置，i跳到i+3

```java
public static int light(String road) {
    char[] str = road.toCharArray();
    int i = 0;
    int light = 0;
    while (i < str.length) {
        if (str[i] == 'X') {
            i++;
        } else {
            // 无论是那种情况此时必须放灯
            light++;
            if (i + 1 == str.length) {
                break;
            }
            // 有i+1位置的情况
            if (str[i + 1] == 'X') {
                i = i + 2;
            } else {
                i = i + 3;
            }
        }
    }
    return light;
}
```



### 分发饼干

#### 题目描述

[LeetCode455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)



#### 题解

**贪心**

贪心思想1：尽量用大的饼干满足胃口大的小朋友

```java
public int findContentChildren(int[] g, int[] s) {
    // 贪心算法 尽量用大的饼干满足胃口大的小朋友
    Arrays.sort(g);
    Arrays.sort(s);

    int res = 0;
    int i = g.length - 1;
    int j = s.length - 1;

    while (i >= 0 && j >= 0) {
        // 如果最大的饼干能满足当前最大胃口的孩子 则res + 1
        if (s[j] >= g[i]) {
            res++;
            i--;
            j--;
        } else {
            // 否则当前最大胃口的孩子无法满足 跳过该孩子
            i--;
        }
    }
    return res;
}
```



贪心思想2：尽量用小的饼干满足胃口小的小朋友

```java
public int findContentChildren1(int[] g, int[] s) {
    // 贪心算法 尽量用小的饼干满足胃口小的小朋友
    Arrays.sort(g);
    Arrays.sort(s);

    int res = 0;
    int i = 0;
    int j = 0;

    while (i < g.length && j < s.length) {
        // 如果最小的饼干能满足当前最小胃口的孩子 则res + 1
        if (s[j] >= g[i]) {
            res++;
            i++;
        }
        // 无论是否满足 当前饼干索引都要加1
        j++;
    }
    return res;
}
```



### 判断子序列

#### 题目描述

[LeetCode392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)



#### 题解

**贪心 + 双指针** 

因为这题太简单了，可能都没有意识到使用到了贪心

贪心策略：对于s中的每个字符，按顺序在t中查找是否有相同的字符，找到一个相同的字符后就继续查找下一个字符，中间遍历的顺序一直是从前向后。

```java
// 贪心 双指针
public boolean isSubsequence(String s, String t) {
    int sLen = s.length();
    int tLen = t.length();
    int i = 0;
    int j = 0;
    while (i < tLen) {
        // 在长串找到匹配的字符j++
        if (s.charAt(j) == t.charAt(i)) {
            j++;
        }
        i++;
    }
    // 如果j为短串的长度 说明能在长串中找到短串所有的字符
    return j == sLen;
}
```



**动态规划**

思路一：求出最长公共子序列，判断最长公共子序列长度是否等于 s 串

思路二：编辑距离



### 判断子序列（大数据）

https://leetcode-cn.com/problems/is-subsequence/solution/javati-jie-he-hou-xu-tiao-zhan-by-lil-q/



### 最长递增子序列

[点击跳转](#longest-increasing-subsequence)





### 无重叠区间

#### 题目描述

[LeetCode435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

**提示:**

- `1 <= intervals.length <= 10^5`
- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 10^4`



#### 题解



**暴力解**

找出所有子区间的组合，之后判断它重不重叠。`O(2 ^ n) * n`，每个区间选或不选



**动态规划**



**最少移除多少区间 --> 最多保留多少区间**



这题是可以**转化成最长递增子序列问题**，但实际上还是有区别的。因为该题是要求移除区间的最小数量，使剩余区间互不重叠，**区间的位置是无关紧要的**，是可以移动的，而最长递增子序列中的元素是不能被移动的，所以我们要**先将区间排好序**，才能在动态规划过程中忽视掉区间的位置。比如下面这两个区间是互不重叠的，但对于区间元素来说并不是递增的，我们交换两个位置就可以当做递增子序列了

排好序就可以转化成最长递增子序列

```
[[11,22],[1,11]] --> [[1,11],[11,22]]
```

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    // 因为该题是要求移除区间的最小数量，使剩余区间互不重叠，区间的位置是无关紧要的，是可以移动的，而最长递增子序列中的元素是不能被移动的，所以我们要先将区间排好序
    Arrays.sort(intervals, (o1, o2) -> (o1[0] == o2[0] ? (o1[1] - o2[1]) : (o1[0] - o2[0])));
    int n = intervals.length;
    // dp[i] 表示考虑intervals[0...i]内能构成最长不重叠区间的长度
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            // 如果存在j < i 且intervals[j]的end 小于等于 intervals[i]的start 说明这两个区间不重叠
            if (intervals[j][1] <= intervals[i][0]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    // 找到dp最大值
    int res = 1;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    // 需要移除的最少区间 = 总区间长度 - 最长不重叠区间长度
    return n - res;
}
```

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220311225607929.png)

因为这题 LeetCode 给的数据量太大，动态规划还是会超时



**贪心**

从动态规划的核心代码中，我们得知每次选择中，**每个区间的结尾很重要**，**前面区间的 end 值越小，留给后面的区间空间越大**，越能容纳更多区间，我们基于这种思想，可以设计出贪心算法：

**每次选择结尾最早的，且和前一区间不重叠的区间。**

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    int n = intervals.length;
    // 注意这里排序规则是 按end值排序 end值越小 越靠前
    Arrays.sort(intervals, (o1, o2) -> (o1[1] == o2[1] ? (o1[0] - o2[0]) : (o1[1] - o2[1])));
    int res = 1;
    int pre = 0;
    for (int i = 1; i < n; i++) {
        // 如果区间i的起始值 大于等于 前一个区间的end值 则添加区间res++ 更新pre
        if (intervals[i][0] >= intervals[pre][1]) {
            // 这里可以体现出作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不作保留
            res++;
            pre = i;
        }
    }
    return n - res;
}
```



**证明**

贪心选择性质

贪心策略：按照区间的结尾排序，每次选择结尾最早的，且和前一个区间不重叠的区间

![](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/image-20220312221850900.png)

注意理解在某一步有**两种合法的选择**，一种是按照贪心算法算出的`[s(i), f(i)]`，另一种就是假设是最优解选择的`[s(j), f(j)] `且`f(i) < f(j)`，也就是最优解不是当前选择中 end 值最小的区间。

因为`f(i) < f(j)`，而且我们不需要考虑起始值`s(i)`和`s(j)`，因为我们假设的这两种选择都是合法的，说明这两个起始值都没有与之前选择区间的 end 值重叠，那么我们可以在这一步中将贪心算法选择的区间`[s(i), f(i)]`替换掉假设的最优解选择的区间`[s(j), f(j)]`，而不影响后续区间的选择。(因为 end 值变小了)

此时，我们选择`[s(i), f(i)]`也能构成一个大小为 k 的解，与原来的假设矛盾，所以可以证明出这个问题具有贪心选择性质



### 放养但没有完全放养

#### 题目描述

[AcWing3358. 放养但没有完全放养](https://www.acwing.com/problem/content/description/3361/)



#### 题解

```java
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char[] songArr = sc.nextLine().toCharArray();
        char[] listerArr = sc.nextLine().toCharArray();
        
        // 记录song中所有字符的位置 song是26个字母的排列，每个字母卫衣
        int[] index = new int[26];
        for (int i = 0; i < 26; i++) {
            index[songArr[i] - 'a'] = i;
        }
        
        int res = 1;
        for (int i = 1; i < listerArr.length; i++) {
            // 如果短串邻接的两个字符中位置出现逆序或相等，这两个字符必然不能出现在同一次中
            if ((index[listerArr[i] - 'a']) <= (index[listerArr[i - 1] - 'a'])) {
                res++;
            }
        }
        
        System.out.println(res);
    }
}
```



# 数学



### 你知道你的ABC吗

#### 题目描述

[AcWing3346. 你知道你的ABC吗](https://www.acwing.com/problem/content/description/3349/)



#### 题解

一道推理题，因为 A B C 都为正整数且有 (A≤B≤C），那么我们将7个所给的数进行升序排序，那么必有 A + B + C 排在最后（最大值），A 排在最前（A肯定是可以排在第一位的，即使 A == B，我们也可以确定第一位的数与 A 相等）。

第二位数只有两种可能（未推理）：

- B
- A + C

当 B == C 时，第二位也可以是 C，但此时不影响 B 可以在第二位

我们假设：第二位不能是 B，也就是说，7个数中存在 x 使得 `A <= x < B`，严格小于

根据题意 C、A+B、B+C、A+B+C 都大于等于 B，x 不可能为这些数，只剩下 A + C

A + C ？B

因为 C >= B，所以 A + C >= B，所以与假设矛盾，第二位是 B

```java
import java.util.Arrays;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] nums = new int[7];
        for (int i = 0; i < 7; i++) {
            nums[i] = sc.nextInt();
        }
        
        Arrays.sort(nums);
        int C = nums[6] - nums[0] - nums[1];
        System.out.println(nums[0] + " " + nums[1] + " " + C);
    }
}
```



# 图论

## 可转化成图论的问题

### 单词接龙

#### 题目描述

[LeetCode127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)



#### 题解



**BFS**

求解*从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。

显然是一个最短路径问题，这题不难想到使用 BFS 来求解

为什么 BFS 得到的路径最短？**可以把起点和终点所在的路径拉直来看，两点之间线段最短**

两个单词对应位置只有一个字符不同，例如 "hit" 与 "hot"，这种转换是**可以逆向**的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图。

![image.png](https://zwx-images-1305338888.cos.ap-guangzhou.myqcloud.com/typora/ec8f7e4f40134b932a9ff2e306d885e427bd8ee912801361849d92ddae6226f3-image.png)


正因为可逆向，我们还需要 visited 集合来记录下所访问的结点，避免重复访问

这题难的是对单词的处理

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    if (wordList.size() == 0) {
        return 0;
    }
    // 字典放到哈希表中，因为我们需要快速的判断某个单词是否在字典中
    Set<String> wordSet = new HashSet<>(wordList);

    // 因为这个是一个无向图 为了避免匹配重复单词 需要记录已访问的结点
    Set<String> visited = new HashSet<>();
    visited.add(beginWord);

    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    int depth = 0;
    while (!queue.isEmpty()) {
        int levelCount = queue.size();
        depth++;
        // O(26 * word.length())
        for (int i = 0; i < levelCount; i++) {
            String cur = queue.poll();
            char[] curWord = cur.toCharArray();
            // 枚举cur修改一个字符后的所有单词 26 * 单词长度 - 1种可能（所有单词长度相等）
            for (int j = 0; j < endWord.length(); j++) {
                // 因为每个单词只能修改一个字符，所以在更换前需要备份，之后需要恢复
                char originChar = curWord[j];
                for (char k = 'a'; k <= 'z'; k++) {
                    // 跳过本身的字符
                    if (j == originChar) {
                        continue;
                    }
                    // 修改一个字符
                    curWord[j] = k;
                    String next = String.valueOf(curWord);
                    // 判断修改一个字符后的单词是否在字典中
                    if (wordSet.contains(next)) {
                        // 判断是否新单词是否与end匹配
                        if (next.equals(endWord)) {
                            return depth + 1;
                        }
                        // 该结点未被访问过，则选择该结点当做路径 并标记
                        if (!visited.contains(next)) {
                            visited.add(next);
                            queue.add(next);
                        }
                    }
                }
                // 恢复该字符，进入下一个字符位枚举
                curWord[j] = originChar;
            }
        }
    }
    // 不存在这样的转换序列返回0
    return 0;
}
```



**双向 BFS**

TODO
